*** ../bash-4.2-patched/sig.c	2011-03-12 13:14:06.000000000 -0500
--- sig.c	2013-01-05 18:00:28.000000000 -0500
***************
*** 1,5 ****
  /* sig.c - interface for shell signal handlers and signal initialization. */
  
! /* Copyright (C) 1994-2010 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
--- 1,5 ----
  /* sig.c - interface for shell signal handlers and signal initialization. */
  
! /* Copyright (C) 1994-2013 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
***************
*** 359,362 ****
--- 359,364 ----
      }
  #endif /* !HAVE_POSIX_SIGNALS */
+ 
+   termsigs_initialized = 0;
  }
  #undef XSIG
***************
*** 390,393 ****
--- 392,397 ----
    if (interrupt_state)
      {
+       if (last_command_exit_value < 128)
+ 	last_command_exit_value = 128 + SIGINT;
        print_newline = 1;
        DELINTERRUPT;
***************
*** 517,520 ****
--- 521,532 ----
      }
  
+ #if defined (READLINE)
+   /* Set the event hook so readline will call it after the signal handlers
+      finish executing, so if this interrupted character input we can get
+      quick response. */
+   if (interactive_shell && interactive && no_line_editing == 0)
+     bashline_set_event_hook ();
+ #endif
+ 
    SIGRETURN (0);
  }
***************
*** 538,545 ****
      run_interrupt_trap ();
  
  #if defined (HISTORY)
!   if (interactive_shell && sig != SIGABRT)
      maybe_save_shell_history ();
  #endif /* HISTORY */
  
  #if defined (JOB_CONTROL)
--- 550,559 ----
      run_interrupt_trap ();
  
+ #if 0
  #if defined (HISTORY)
!   if (interactive_shell && (sig != SIGABRT && sig != SIGINT && sig != SIGHUP && sig != SIGTERM))
      maybe_save_shell_history ();
  #endif /* HISTORY */
+ #endif
  
  #if defined (JOB_CONTROL)
***************
*** 582,585 ****
--- 596,606 ----
        throw_to_top_level ();
      }
+ #if defined (READLINE)
+   /* Set the event hook so readline will call it after the signal handlers
+      finish executing, so if this interrupted character input we can get
+      quick response. */
+   else if (RL_ISSTATE (RL_STATE_SIGHANDLER))
+     bashline_set_event_hook ();
+ #endif
  
    SIGRETURN (0);
***************
*** 618,622 ****
  #if !defined (HAVE_POSIX_SIGNALS)
  
- #if defined (JOB_CONTROL)
  /* Perform OPERATION on NEWSET, perhaps leaving information in OLDSET. */
  sigprocmask (operation, newset, oldset)
--- 639,642 ----
***************
*** 637,641 ****
  
      case SIG_SETMASK:
!       sigsetmask (new);
        break;
  
--- 657,661 ----
  
      case SIG_SETMASK:
!       old = sigsetmask (new);
        break;
  
***************
*** 647,651 ****
      *oldset = old;
  }
- #endif /* JOB_CONTROL */
  
  #else
--- 667,670 ----
***************
*** 672,677 ****
--- 691,698 ----
    /* We don't want a child death to interrupt interruptible system calls, even
       if we take the time to reap children */
+ #if defined (SIGCHLD)
    if (sig == SIGCHLD)
      act.sa_flags |= SA_RESTART;		/* XXX */
+ #endif
  
    sigemptyset (&act.sa_mask);
