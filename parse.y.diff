*** ../bash-3.1/parse.y	Fri Nov 11 23:14:18 2005
--- parse.y	Wed Jan 25 14:55:18 2006
***************
*** 1,5 ****
  /* Yacc grammar for bash. */
  
! /* Copyright (C) 1989-2005 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
--- 1,5 ----
  /* Yacc grammar for bash. */
  
! /* Copyright (C) 1989-2006 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
***************
*** 119,123 ****
  extern int posixly_correct;
  extern int last_command_exit_value;
- extern int interrupt_immediately;
  extern char *shell_name, *current_host_name;
  extern char *dist_version;
--- 119,122 ----
***************
*** 1213,1220 ****
--- 1212,1221 ----
  	  interrupt_immediately++;
  	}
+       terminate_immediately = 1;
  
        current_readline_line = readline (current_readline_prompt ?
        					  current_readline_prompt : "");
  
+       terminate_immediately = 0;
        if (signal_is_ignored (SIGINT) == 0 && old_sigint)
  	{
***************
*** 1348,1355 ****
      {
        if (interactive)
! 	interrupt_immediately++;
        result = getc_with_restart (bash_input.location.file);
        if (interactive)
! 	interrupt_immediately--;
      }
    return (result);
--- 1349,1362 ----
      {
        if (interactive)
! 	{
! 	  interrupt_immediately++;
! 	  terminate_immediately++;
! 	}
        result = getc_with_restart (bash_input.location.file);
        if (interactive)
! 	{
! 	  interrupt_immediately--;
! 	  terminate_immediately--;
! 	}
      }
    return (result);
***************
*** 2743,2751 ****
    while (count)
      {
- #if 0
-       ch = shell_getc ((qc != '\'' || (flags & P_ALLOWESC)) && pass_next_character == 0);
- #else
        ch = shell_getc (qc != '\'' && pass_next_character == 0);
! #endif
        if (ch == EOF)
  	{
--- 2750,2755 ----
    while (count)
      {
        ch = shell_getc (qc != '\'' && pass_next_character == 0);
! 
        if (ch == EOF)
  	{
***************
*** 2772,2776 ****
  	}
        /* Not exactly right yet */
!       else if (check_comment && in_comment == 0 && ch == '#' && (retind == 0 || ret[retind-1] == '\n' || whitespace (ret[retind -1])))
  	in_comment = 1;
  
--- 2776,2780 ----
  	}
        /* Not exactly right yet */
!       else if MBTEST(check_comment && in_comment == 0 && ch == '#' && (retind == 0 || ret[retind-1] == '\n' || whitespace (ret[retind - 1])))
  	in_comment = 1;
  
***************
*** 2799,2807 ****
        else if MBTEST(ch == close)		/* ending delimiter */
  	count--;
- #if 1
        /* handle nested ${...} specially. */
        else if MBTEST(open != close && was_dollar && open == '{' && ch == open) /* } */
  	count++;
- #endif
        else if MBTEST(((flags & P_FIRSTCLOSE) == 0) && ch == open)	/* nested begin */
  	count++;
--- 2803,2809 ----
***************
*** 2899,2903 ****
        else if MBTEST(qc == '`' && (ch == '"' || ch == '\'') && in_comment == 0)
  	{
! 	  nestret = parse_matched_pair (0, ch, ch, &nestlen, rflags);
  	  goto add_nestret;
  	}
--- 2901,2909 ----
        else if MBTEST(qc == '`' && (ch == '"' || ch == '\'') && in_comment == 0)
  	{
! 	  /* Add P_ALLOWESC so backslash quotes the next character and
! 	     shell_getc does the right thing with \<newline>.  We do this for
! 	     a measure  of backwards compatibility -- it's not strictly the
! 	     right POSIX thing. */
! 	  nestret = parse_matched_pair (0, ch, ch, &nestlen, rflags|P_ALLOWESC);
  	  goto add_nestret;
  	}
***************
*** 2908,2912 ****
  	    count--;
  	  if (ch == '(')		/* ) */
! 	    nestret = parse_matched_pair (0, '(', ')', &nestlen, rflags);
  	  else if (ch == '{')		/* } */
  	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|rflags);
--- 2914,2918 ----
  	    count--;
  	  if (ch == '(')		/* ) */
! 	    nestret = parse_matched_pair (0, '(', ')', &nestlen, rflags & ~P_DQUOTE);
  	  else if (ch == '{')		/* } */
  	    nestret = parse_matched_pair (0, '{', '}', &nestlen, P_FIRSTCLOSE|rflags);
***************
*** 2947,2951 ****
  	  wd = alloc_word_desc ();
  	  wd->word = wval;
- 	  wd = make_word (wval);
  	  yylval.word_list = make_word_list (wd, (WORD_LIST *)NULL);
  	  return (ARITH_FOR_EXPRS);
--- 2953,2956 ----
***************
*** 3497,3501 ****
  	      else
  		{
! 		  /* Try to locale)-expand the converted string. */
  		  ttrans = localeexpand (ttok, 0, ttoklen - 1, first_line, &ttranslen);
  		  free (ttok);
--- 3502,3506 ----
  	      else
  		{
! 		  /* Try to locale-expand the converted string. */
  		  ttrans = localeexpand (ttok, 0, ttoklen - 1, first_line, &ttranslen);
  		  free (ttok);
***************
*** 3579,3583 ****
  	      all_digit_token = 0;
  	      compound_assignment = 1;
! #if 0
  	      goto next_character;
  #else
--- 3584,3588 ----
  	      all_digit_token = 0;
  	      compound_assignment = 1;
! #if 1
  	      goto next_character;
  #else
***************
*** 3696,3700 ****
        b = builtin_address_internal (token, 0);
        if (b && (b->flags & ASSIGNMENT_BUILTIN))
!         parser_state |= PST_ASSIGNOK;
      }
  
--- 3701,3707 ----
        b = builtin_address_internal (token, 0);
        if (b && (b->flags & ASSIGNMENT_BUILTIN))
! 	parser_state |= PST_ASSIGNOK;
!       else if (STREQ (token, "eval") || STREQ (token, "let"))
! 	parser_state |= PST_ASSIGNOK;
      }
  
***************
*** 4247,4251 ****
  		}
  	      temp = (char *)xmalloc (3);
! 	      temp[0] = '\001';
  	      temp[1] = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
  	      temp[2] = '\0';
--- 4254,4258 ----
  		}
  	      temp = (char *)xmalloc (3);
! 	      temp[0] = CTLESC;
  	      temp[1] = (c == '[') ? RL_PROMPT_START_IGNORE : RL_PROMPT_END_IGNORE;
  	      temp[2] = '\0';
***************
*** 4687,4691 ****
  {
    WORD_LIST *wl, *rl;
!   int tok, orig_line_number, orig_token_size;
    char *saved_token, *ret;
  
--- 4694,4698 ----
  {
    WORD_LIST *wl, *rl;
!   int tok, orig_line_number, orig_token_size, orig_last_token, assignok;
    char *saved_token, *ret;
  
***************
*** 4693,4696 ****
--- 4700,4704 ----
    orig_token_size = token_buffer_size;
    orig_line_number = line_number;
+   orig_last_token = last_read_token;
  
    last_read_token = WORD;	/* WORD to allow reserved words here */
***************
*** 4699,4702 ****
--- 4707,4712 ----
    token_buffer_size = 0;
  
+   assignok = parser_state&PST_ASSIGNOK;		/* XXX */
+ 
    wl = (WORD_LIST *)NULL;	/* ( */
    parser_state |= PST_COMPASSIGN;
***************
*** 4741,4745 ****
      }
  
!   last_read_token = WORD;
    if (wl)
      {
--- 4751,4756 ----
      }
  
!   last_read_token = orig_last_token;		/* XXX - was WORD? */
! 
    if (wl)
      {
***************
*** 4753,4756 ****
--- 4764,4771 ----
    if (retlenp)
      *retlenp = (ret && *ret) ? strlen (ret) : 0;
+ 
+   if (assignok)
+     parser_state |= PST_ASSIGNOK;
+ 
    return ret;
  }
