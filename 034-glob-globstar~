*** ../bash-4.0-patched/lib/glob/glob.c	2009-07-22 23:18:50.000000000 -0400
--- lib/glob/glob.c	2009-09-18 17:53:25.000000000 -0400
***************
*** 247,251 ****
  	break;
      }
!   pathname[j] = '\0';
  }
  
--- 247,252 ----
  	break;
      }
!   if (pathname)
!     pathname[j] = '\0';
  }
  
***************
*** 280,284 ****
  	break;
      }
!   wpathname[j] = L'\0';
  
    /* Convert the wide character string into unibyte character set. */
--- 281,286 ----
  	break;
      }
!   if (wpathname)
!     wpathname[j] = L'\0';
  
    /* Convert the wide character string into unibyte character set. */
***************
*** 308,314 ****
  #else /* !HAVE_LSTAT */
  #  if !defined (AFS)
! #    define GLOB_TESTNAME(name)  (sh_eaccess (nextname, F_OK))
  #  else /* AFS */
! #    define GLOB_TESTNAME(name)  (access (nextname, F_OK))
  #  endif /* AFS */
  #endif /* !HAVE_LSTAT */
--- 310,316 ----
  #else /* !HAVE_LSTAT */
  #  if !defined (AFS)
! #    define GLOB_TESTNAME(name)  (sh_eaccess (name, F_OK))
  #  else /* AFS */
! #    define GLOB_TESTNAME(name)  (access (name, F_OK))
  #  endif /* AFS */
  #endif /* !HAVE_LSTAT */
***************
*** 321,324 ****
--- 323,327 ----
    struct stat finfo;
  
+ /*itrace("glob_testdir: testing %s", dir);*/
    if (stat (dir, &finfo) < 0)
      return (-1);
***************
*** 427,431 ****
    register char *nextname, *npat, *subdir;
    unsigned int count;
!   int lose, skip, ndirs, isdir, sdlen, add_current;
    register char **name_vector;
    register unsigned int i;
--- 430,434 ----
    register char *nextname, *npat, *subdir;
    unsigned int count;
!   int lose, skip, ndirs, isdir, sdlen, add_current, patlen;
    register char **name_vector;
    register unsigned int i;
***************
*** 434,437 ****
--- 437,441 ----
    int nalloca;
    struct globval *firstmalloc, *tmplink;
+   char *convfn;
  
    lastlink = 0;
***************
*** 467,470 ****
--- 471,476 ----
      }
  
+   patlen = strlen (pat);
+ 
    /* If the filename pattern (PAT) does not contain any globbing characters,
       we can dispense with reading the directory, and just see if there is
***************
*** 480,485 ****
  
        dirlen = strlen (dir);
!       nextname = (char *)malloc (dirlen + strlen (pat) + 2);
!       npat = (char *)malloc (strlen (pat) + 1);
        if (nextname == 0 || npat == 0)
  	lose = 1;
--- 486,491 ----
  
        dirlen = strlen (dir);
!       nextname = (char *)malloc (dirlen + patlen + 2);
!       npat = (char *)malloc (patlen + 1);
        if (nextname == 0 || npat == 0)
  	lose = 1;
***************
*** 634,639 ****
  	      continue;
  	    }
! 	      
! 	  if (strmatch (pat, dp->d_name, mflags) != FNM_NOMATCH)
  	    {
  	      if (nalloca < ALLOCA_MAX)
--- 640,646 ----
  	      continue;
  	    }
! 
! 	  convfn = fnx_fromfs (dp->d_name, D_NAMLEN (dp));
! 	  if (strmatch (pat, convfn, mflags) != FNM_NOMATCH)
  	    {
  	      if (nalloca < ALLOCA_MAX)
***************
*** 920,928 ****
  	  char **temp_results;
  
  	  /* Scan directory even on a NULL filename.  That way, `*h/'
  	     returns only directories ending in `h', instead of all
  	     files ending in `h' with a `/' appended. */
  	  dname = directories[i];
! 	  dflags = flags & ~GX_MARKDIRS;
  	  if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
  	    dflags |= GX_ALLDIRS|GX_ADDCURDIR;
--- 927,938 ----
  	  char **temp_results;
  
+ 	  /* XXX -- we've recursively scanned any directories resulting from
+ 	     a `**', so turn off the flag.  We turn it on again below if
+ 	     filename is `**' */
  	  /* Scan directory even on a NULL filename.  That way, `*h/'
  	     returns only directories ending in `h', instead of all
  	     files ending in `h' with a `/' appended. */
  	  dname = directories[i];
! 	  dflags = flags & ~(GX_MARKDIRS|GX_ALLDIRS|GX_ADDCURDIR);
  	  if ((flags & GX_GLOBSTAR) && filename[0] == '*' && filename[1] == '*' && filename[2] == '\0')
  	    dflags |= GX_ALLDIRS|GX_ADDCURDIR;
