# Bulgarian translation of bash po-file.
# Copyright (C) 2007 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Alexander Shopov <ash@contact.bg>, 2007.
#
msgid ""
msgstr ""
"Project-Id-Version: bash 3.2\n"
"POT-Creation-Date: 2005-10-03 17:31-0400\n"
"PO-Revision-Date: 2007-07-26 07:18+0300\n"
"Last-Translator: Alexander Shopov <ash@contact.bg>\n"
"Language-Team: Bulgarian <dict@fsa-bg.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"

#: arrayfunc.c:48
msgid "bad array subscript"
msgstr "неправилен индекс на масив"

#: arrayfunc.c:360
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: не може да се присвоява на нецифров индекс"

#: bashhist.c:328
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: не може да се създаде: %s"

#: bashline.c:2947
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr ""
"изпълнение на команда на Юникс от bash: не може да се открие подредбата на\n"
"функциите на клавишите за командата"

#: bashline.c:2996
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: първият непразен знак не е „\"“"

#: bashline.c:3025
#, c-format
msgid "no closing `%c' in %s"
msgstr "в %2$s липсва затварящ знак „%1$c“"

#: bashline.c:3059
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: разделителят двоеточие липсва"

#: builtins/bind.def:194
#, c-format
msgid "`%s': invalid keymap name"
msgstr "„%s“: грешно име на подредбата на функциите на клавишите"

#: builtins/bind.def:233
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: не може да се прочете: %s"

#: builtins/bind.def:248
#, c-format
msgid "`%s': cannot unbind"
msgstr "„%s“: не може да се премахне присвояване"

#: builtins/bind.def:283
#, c-format
msgid "`%s': unknown function name"
msgstr "„%s“: непознато име на функция"

#: builtins/bind.def:291
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s не може да се зададе на никой клавиш.\n"

#: builtins/bind.def:295
#, c-format
msgid "%s can be invoked via "
msgstr "%s може да се извика чрез "

#: builtins/break.def:128
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "валидно само за циклите с „for“, „while“ и „until“"

#: builtins/caller.def:132
msgid "Returns the context of the current subroutine call."
msgstr "Връща контекста на текущото извикване на подпрограма."

#: builtins/caller.def:133 builtins/caller.def:137 builtins/pushd.def:660
#: builtins/pushd.def:668 builtins/pushd.def:671 builtins/pushd.def:681
#: builtins/pushd.def:685 builtins/pushd.def:689 builtins/pushd.def:692
#: builtins/pushd.def:695 builtins/pushd.def:704 builtins/pushd.def:708
#: builtins/pushd.def:712 builtins/pushd.def:715
msgid " "
msgstr " "

#: builtins/caller.def:134
msgid "Without EXPR, returns returns \"$line $filename\".  With EXPR,"
msgstr "Без ИЗРАЗ връща „$ред $име_на_файл“.  С ИЗРАЗ връща"

#: builtins/caller.def:135
msgid "returns \"$line $subroutine $filename\"; this extra information"
msgstr "„$ред $функция $име_на_файл“. Тази допълнителна информация"

#: builtins/caller.def:136
msgid "can be used used to provide a stack trace."
msgstr "може да се използва да получаването на информация за стека."

#: builtins/caller.def:138
msgid "The value of EXPR indicates how many call frames to go back before the"
msgstr "Стойността на ИЗРАЗа показва колко извиквания преди текущото"

#: builtins/caller.def:139
msgid "current one; the top frame is frame 0."
msgstr "трябва да се върнат. Последното извикване е 0."

#: builtins/cd.def:203
msgid "HOME not set"
msgstr "Променливата $HOME не зададена"

#: builtins/cd.def:215
msgid "OLDPWD not set"
msgstr "Променливата $OLDPWD не е зададена"

#: builtins/common.c:133 test.c:921
msgid "too many arguments"
msgstr "прекалено много аргументи"

#: builtins/common.c:157 shell.c:474 shell.c:747
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: опцията изисква аргумент"

#: builtins/common.c:164
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: изисква се числов аргумент"

#: builtins/common.c:171
#, c-format
msgid "%s: not found"
msgstr "%s: не е открит"

#: builtins/common.c:180 shell.c:760
#, c-format
msgid "%s: invalid option"
msgstr "%s: грешна опция"

#: builtins/common.c:187
#, c-format
msgid "%s: invalid option name"
msgstr "%s: грешно име на опция"

#: builtins/common.c:194 general.c:231 general.c:236
#, c-format
msgid "`%s': not a valid identifier"
msgstr "„%s“: грешен идентификатор"

#: builtins/common.c:201
#, c-format
msgid "%s: invalid number"
msgstr "%s: грешно число"

#: builtins/common.c:208
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: грешно указване на сигнал"

#: builtins/common.c:215
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "„%s“: неправилен идентификатор на процес или задача"

#: builtins/common.c:222 error.c:453
#, c-format
msgid "%s: readonly variable"
msgstr "%s: променлива с права само за четене"

#: builtins/common.c:230
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s е извън допустимия диапазон"

#: builtins/common.c:230 builtins/common.c:232
msgid "argument"
msgstr "аргументът"

#: builtins/common.c:232
#, c-format
msgid "%s out of range"
msgstr "%s е извън допустимия диапазон"

#: builtins/common.c:240
#, c-format
msgid "%s: no such job"
msgstr "%s: няма такава задача"

#: builtins/common.c:248
#, c-format
msgid "%s: no job control"
msgstr "%s: няма управление на задачите"

#: builtins/common.c:250
msgid "no job control"
msgstr "няма управление на задачите"

#: builtins/common.c:260
#, c-format
msgid "%s: restricted"
msgstr "%s: ограничена обвивка"

#: builtins/common.c:262
msgid "restricted"
msgstr "ограничена обвивка"

#: builtins/common.c:270
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: не е команда вградена в обвивката"

#: builtins/common.c:276
#, c-format
msgid "write error: %s"
msgstr "грешка при запис: %s"

#: builtins/common.c:484
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: грешка при получаването на текущата директория: %s: %s\n"

#: builtins/common.c:550 builtins/common.c:552
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: нееднозначно указана задача"

#: builtins/complete.def:251
#, c-format
msgid "%s: invalid action name"
msgstr "%s: грешно име на действие"

#: builtins/complete.def:381 builtins/complete.def:524
#, c-format
msgid "%s: no completion specification"
msgstr "%s: не е указано дописване"

#: builtins/complete.def:571
msgid "warning: -F option may not work as you expect"
msgstr "предупреждение: опцията „-F“ може да не работи според очакванията ви"

#: builtins/complete.def:573
msgid "warning: -C option may not work as you expect"
msgstr "предупреждение: опцията „-C“ може да не работи според очакванията ви"

#: builtins/declare.def:105
msgid "can only be used in a function"
msgstr "може да се използва само във функция"

#: builtins/declare.def:301
msgid "cannot use `-f' to make functions"
msgstr "„-f“ не може да се използва за създаването на функции"

#: builtins/declare.def:313 execute_cmd.c:3986
#, c-format
msgid "%s: readonly function"
msgstr "%s: функция с права само за четене"

#: builtins/declare.def:401
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: променливите за масиви не могат да се унищожават така"

#: builtins/enable.def:128 builtins/enable.def:136
msgid "dynamic loading not available"
msgstr "липсва възможност за динамично зареждане"

#: builtins/enable.def:303
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "споделеният обект %s не може да бъде зареден: %s"

#: builtins/enable.def:326
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "не може да се открие %s в споделения обект %s: %s"

#: builtins/enable.def:450
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: не е зареден динамично"

#: builtins/enable.def:465
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: не може да се изтрие: %s"

#: builtins/evalfile.c:129 execute_cmd.c:3852 shell.c:1408
#, c-format
msgid "%s: is a directory"
msgstr "%s: е директория"

#: builtins/evalfile.c:134
#, c-format
msgid "%s: not a regular file"
msgstr "%s: не е обикновен файл"

#: builtins/evalfile.c:142
#, c-format
msgid "%s: file is too large"
msgstr "%s: файлът е прекалено голям"

#: builtins/exec.def:205
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: не може да се изпълни: %s"

#: builtins/exit.def:83
msgid "not login shell: use `exit'"
msgstr "това не е входна обвивка: използвайте „exit“"

#: builtins/exit.def:111
msgid "There are stopped jobs.\n"
msgstr "Има спрени задачи.\n"

#: builtins/fc.def:259
msgid "no command found"
msgstr "не е открита команда"

#: builtins/fc.def:329
msgid "history specification"
msgstr "указване на историята"

#: builtins/fc.def:350
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: не може да се отвори временен файл: %s"

#: builtins/fg_bg.def:149
#, c-format
msgid "job %d started without job control"
msgstr "задача %d е стартирана без управление на задачите"

#: builtins/getopt.c:109
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: непозволена опция -- %c\n"

#: builtins/getopt.c:110
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: опцията изисква аргумент -- %c\n"

#: builtins/hash.def:83
msgid "hashing disabled"
msgstr "хеширането е изключено"

#: builtins/hash.def:128
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: таблицата с хешове е празна\n"

#: builtins/help.def:108
msgid "Shell commands matching keywords `"
msgstr "Команди на обвивката, които напасват на ключовите думи „"

#: builtins/help.def:110
msgid "Shell commands matching keyword `"
msgstr "Команди на обвивката, които напасват на ключовата дума „"

#: builtins/help.def:138
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"няма теми в помощта, които да отговарят на „%s“.  Опитайте с\n"
"„help help“, „man -k %s“ или „info %s“."

#: builtins/help.def:164
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: не може да се отвори: %s"

#: builtins/help.def:182
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Тези команди на интерпретатора са дефинирани вътрешно.\n"
"Напишете „help“, за да видите списъка.\n"
"Напишете „help ИМЕ_НА_ФУНКЦИЯ“ за повече информация за съответната функция.\n"
"Напишете „info bash“ за повече информация за обвивката като цяло.\n"
"Напишете „man -k“ или „info“ за повече информация за командите извън списъка.\n"
"\n"
"Знакът звездичка „*“ до името на команда означава, че тя е изключена.\n"
"\n"

#: builtins/history.def:150
msgid "cannot use more than one of -anrw"
msgstr "не може да се ползва едновременно повече от една от опциите -anrw"

#: builtins/history.def:182
msgid "history position"
msgstr "позиция в историята"

#: builtins/history.def:400
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: неуспешно заместване чрез историята"

#: builtins/jobs.def:99
msgid "no other options allowed with `-x'"
msgstr "не е позволена друга опция с „-x“"

#: builtins/kill.def:187
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: аргументите трябва да са идентификатори на процеси или задачи"

#: builtins/kill.def:250
msgid "Unknown error"
msgstr "Неизвестна грешка"

#: builtins/let.def:94 builtins/let.def:119 expr.c:497 expr.c:512
msgid "expression expected"
msgstr "очаква се израз"

#: builtins/printf.def:327
#, c-format
msgid "`%s': missing format character"
msgstr "„%s“: липсва форматиращ знак"

#: builtins/printf.def:502
#, c-format
msgid "`%c': invalid format character"
msgstr "„%c“: грешен форматиращ знак"

#: builtins/printf.def:708
msgid "missing hex digit for \\x"
msgstr "липсва шестнадесетична цифра за \\x"

#: builtins/pushd.def:173
msgid "no other directory"
msgstr "няма друга директория"

#: builtins/pushd.def:440
msgid "<no current directory>"
msgstr "«няма текуща директория»"

#: builtins/pushd.def:657
msgid "Display the list of currently remembered directories.  Directories"
msgstr "Показване на списъка с текущо запомнените директории.  Те биват запомнени чрез"

#: builtins/pushd.def:658
msgid "find their way onto the list with the `pushd' command; you can get"
msgstr "командата „pushd“.  Можете да преминете в обратен ред в списъка чрез командата"

#: builtins/pushd.def:659
msgid "back up through the list with the `popd' command."
msgstr "„popd“."

#: builtins/pushd.def:661
msgid "The -l flag specifies that `dirs' should not print shorthand versions"
msgstr "Опцията „-l“ указва, че командата „dirs“ не трябва да извежда кратката версия на"

#: builtins/pushd.def:662
msgid "of directories which are relative to your home directory.  This means"
msgstr "на директориите, които са относителни спрямо домашната ви директория.  Това"

#: builtins/pushd.def:663
msgid "that `~/bin' might be displayed as `/homes/bfox/bin'.  The -v flag"
msgstr "означава, че вместо „~/bin“ ще бъде изведено нещо подобно на „/homes/geek/bin“."

#: builtins/pushd.def:664
msgid "causes `dirs' to print the directory stack with one entry per line,"
msgstr "Опцията „-v“ кара „dirs“ да извежда стека с директориите по една на ред, като"

#: builtins/pushd.def:665
msgid "prepending the directory name with its position in the stack.  The -p"
msgstr "пред всяка се отпечатва мястото ѝ в стека.  Опцията „-p“ прави същото, без да"

#: builtins/pushd.def:666
msgid "flag does the same thing, but the stack position is not prepended."
msgstr "включва мястото на директорията в стека.  Опцията „-c“ изчиства стека с"

#: builtins/pushd.def:667
msgid "The -c flag clears the directory stack by deleting all of the elements."
msgstr "директориите като изтрива всичките му елементи."

#: builtins/pushd.def:669
msgid "+N   displays the Nth entry counting from the left of the list shown by"
msgstr "+N    показва N-тия елемент отляво в списъка показван от"

#: builtins/pushd.def:670 builtins/pushd.def:673
msgid "     dirs when invoked without options, starting with zero."
msgstr "      командата „dirs“, когато е стартирана без опции.  Брои се от 0."

#: builtins/pushd.def:672
msgid ""
"-N   displays the Nth entry counting from the right of the list shown by"
msgstr "-N    показва N-тия елемент отдясно в списъка показван от"

#: builtins/pushd.def:678
msgid "Adds a directory to the top of the directory stack, or rotates"
msgstr "Добавя директория в стека на директориите или превърта стека,"

#: builtins/pushd.def:679
msgid "the stack, making the new top of the stack the current working"
msgstr "като най-горна директория става текущата директория.  Без"

#: builtins/pushd.def:680
msgid "directory.  With no arguments, exchanges the top two directories."
msgstr "аргументи сменя най-горните две директории."

#: builtins/pushd.def:682
msgid "+N   Rotates the stack so that the Nth directory (counting"
msgstr "+N    Превърта стека, така че N-тата директория (като се брои"

#: builtins/pushd.def:683
msgid "     from the left of the list shown by `dirs', starting with"
msgstr "      от лявата страна на списъка, показан от командата „dirs“"

#: builtins/pushd.def:684 builtins/pushd.def:688
msgid "     zero) is at the top."
msgstr "       като се почва от 0) да е най-отгоре."

#: builtins/pushd.def:686
msgid "-N   Rotates the stack so that the Nth directory (counting"
msgstr "-N    Превърта стека, така че N-тата директория (като се брои"

#: builtins/pushd.def:687
msgid "     from the right of the list shown by `dirs', starting with"
msgstr "      от дясната страна на списъка, показан от командата „dirs“"

#: builtins/pushd.def:690
msgid "-n   suppress the normal change of directory when adding directories"
msgstr "-n    подтискане на нормалното преминаване към директория при"

#: builtins/pushd.def:691
msgid "     to the stack, so only the stack is manipulated."
msgstr "       добавянето на директории към стека, така че се променя само той."

#: builtins/pushd.def:693
msgid "dir  adds DIR to the directory stack at the top, making it the"
msgstr "dir   добавя ДИР най-отгоре в стека на директориите, като я прави"

#: builtins/pushd.def:694
msgid "     new current working directory."
msgstr "      новата текуща работна директория."

#: builtins/pushd.def:696 builtins/pushd.def:716
msgid "You can see the directory stack with the `dirs' command."
msgstr "Можете да изведете стека на директорията с командата „dirs“."

#: builtins/pushd.def:701
msgid "Removes entries from the directory stack.  With no arguments,"
msgstr "Маха директории от стека с тях. Без аргументи"

#: builtins/pushd.def:702
msgid "removes the top directory from the stack, and cd's to the new"
msgstr "премахва последната директория в стека и влиза в новата"

#: builtins/pushd.def:703
msgid "top directory."
msgstr "последна директория."

#: builtins/pushd.def:705
msgid "+N   removes the Nth entry counting from the left of the list"
msgstr "+N    премахва N-тия елемент като се брои отляво в списъка"

#: builtins/pushd.def:706
msgid "     shown by `dirs', starting with zero.  For example: `popd +0'"
msgstr "      показван от командата „dirs“, като се брои от 0.  Напр.: „popd +0“"

#: builtins/pushd.def:707
msgid "     removes the first directory, `popd +1' the second."
msgstr "      премахва първата директория, „popd +1“ - втората."

#: builtins/pushd.def:709
msgid "-N   removes the Nth entry counting from the right of the list"
msgstr "-N    премахва N-тия елемент като се брои отдясно в списъка"

#: builtins/pushd.def:710
msgid "     shown by `dirs', starting with zero.  For example: `popd -0'"
msgstr "      показван от командата „dirs“, като се брои от 0.  Напр.: „popd -0“"

#: builtins/pushd.def:711
msgid "     removes the last directory, `popd -1' the next to last."
msgstr "      премахва последната директория, „popd -1“ - предпоследната."

#: builtins/pushd.def:713
msgid "-n   suppress the normal change of directory when removing directories"
msgstr "-n    подтискане на нормалното преминаване към директория при премахването на"

#: builtins/pushd.def:714
msgid "     from the stack, so only the stack is manipulated."
msgstr "      директории от стека, така че се променя само той."

#: builtins/read.def:211
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: грешно указване на изтичането на времето"

#: builtins/read.def:234
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: грешно указване на файловия дескриптор"

#: builtins/read.def:241
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: грешен файлов дескриптор: %s"

#: builtins/read.def:474
#, c-format
msgid "read error: %d: %s"
msgstr "грешка при четене: %d: %s"

#: builtins/return.def:63
msgid "can only `return' from a function or sourced script"
msgstr "„return“ е възможен само от функция или изпълнен в текущата обвивка скрипт"

#: builtins/set.def:745
msgid "cannot simultaneously unset a function and a variable"
msgstr "не може едновременно да се премахват задаванията на функция и променлива"

#: builtins/set.def:782
#, c-format
msgid "%s: cannot unset"
msgstr "%s: не може да се премахне"

#: builtins/set.def:789
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: не може да се премахне: %s е само за четене"

#: builtins/set.def:800
#, c-format
msgid "%s: not an array variable"
msgstr "%s: не е променлива за масив"

#: builtins/setattr.def:166
#, c-format
msgid "%s: not a function"
msgstr "%s: не е функция"

#: builtins/shift.def:66 builtins/shift.def:72
msgid "shift count"
msgstr "брой на преместванията"

#: builtins/shopt.def:227
msgid "cannot set and unset shell options simultaneously"
msgstr "не може едновременно да се задават и да се премахват опции на обвивката"

#: builtins/shopt.def:292
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: грешно име на опция на обвивката"

#: builtins/source.def:117
msgid "filename argument required"
msgstr "изисква се аргумент име на файл"

#: builtins/source.def:137
#, c-format
msgid "%s: file not found"
msgstr "%s: файлът не е открит"

#: builtins/suspend.def:93
msgid "cannot suspend"
msgstr "не може да бъде временно спряна"

#: builtins/suspend.def:103
msgid "cannot suspend a login shell"
msgstr "входната обвивка не може да бъде временно спряна"

#: builtins/type.def:232
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s е синоним на „%s“\n"

#: builtins/type.def:253
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s в ключова дума на обвивката\n"

#: builtins/type.def:273
#, c-format
msgid "%s is a function\n"
msgstr "%s е функция\n"

#: builtins/type.def:298
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s е вградена команда в обвивката\n"

#: builtins/type.def:319
#, c-format
msgid "%s is %s\n"
msgstr "%s е %s\n"

#: builtins/type.def:339
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s е хеширан (%s)\n"

#: builtins/ulimit.def:344
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: неправилен аргумент за ограничение"

#: builtins/ulimit.def:370
#, c-format
msgid "`%c': bad command"
msgstr "„%c“: неправилна команда"

#: builtins/ulimit.def:399
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: ограничението не може да бъде получено: %s"

#: builtins/ulimit.def:437
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: ограничението не може да бъде променено: %s"

#: builtins/umask.def:112
msgid "octal number"
msgstr "осмично число"

#: builtins/umask.def:226
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "„%c“: неправилен оператор за описателен режим"

#: builtins/umask.def:281
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "„%c“: неправилен знак за описателен режим"

#: error.c:165
#, c-format
msgid "last command: %s\n"
msgstr "последна команда: %s\n"

#: error.c:173
msgid "Aborting..."
msgstr "Преустановяване…"

#: error.c:260
#, c-format
msgid "%s: warning: "
msgstr "%s: предупреждение: "

#: error.c:405
msgid "unknown command error"
msgstr "неизвестна грешка в команда"

#: error.c:406
msgid "bad command type"
msgstr "неправилен вид команда"

#: error.c:407
msgid "bad connector"
msgstr "лоша връзка"

#: error.c:408
msgid "bad jump"
msgstr "неправилен преход"

#: error.c:446
#, c-format
msgid "%s: unbound variable"
msgstr "%s: променлива без стойност"

#: eval.c:176
msgid "timed out waiting for input: auto-logout\n"
msgstr "^Gвремето за изчакване на вход изтече: следва автоматично излизане от системата\n"

#: execute_cmd.c:471
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "стандартният вход от /dev/null не може да бъде пренасочен: %s"

#: execute_cmd.c:1036
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "в променливата $TIMEFORMAT: „%c“: грешен форматиращ знак"

#: execute_cmd.c:3551
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: ограничение: в имената на командите не може да присъства знакът „/“"

#: execute_cmd.c:3639
#, c-format
msgid "%s: command not found"
msgstr "%s: командата не е открита"

#: execute_cmd.c:3876
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: лош интерпретатор"

#: execute_cmd.c:3913
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: двоичният файл не може да бъде изпълнен"

#: execute_cmd.c:4025
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "файловият дескриптор %d не може да се дублира като дескриптор %d"

#: expr.c:240
msgid "expression recursion level exceeded"
msgstr "максималният брой нива за рекурсия в израз бяха преминати"

#: expr.c:264
msgid "recursion stack underflow"
msgstr "отрицателно препълване на стека за рекурсии"

#: expr.c:375
msgid "syntax error in expression"
msgstr "синтактична грешка в израз"

#: expr.c:415
msgid "attempted assignment to non-variable"
msgstr "опит за присвояване на стойност на нещо, което не е променлива"

#: expr.c:436 expr.c:441 expr.c:751
msgid "division by 0"
msgstr "деление на 0"

#: expr.c:467
msgid "bug: bad expassign token"
msgstr "програмна грешка: неправилна лексема за присвояване на израз"

#: expr.c:509
msgid "`:' expected for conditional expression"
msgstr "за условен израз се изисква „:“"

#: expr.c:776
msgid "exponent less than 0"
msgstr "степента е по-малка от 0"

#: expr.c:821
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "очаква се идентификатор след предварително увеличаване или намаляване"

#: expr.c:849
msgid "missing `)'"
msgstr "липсва „)“"

#: expr.c:892
msgid "syntax error: operand expected"
msgstr "синтактична грешка: очаква се оператор"

#: expr.c:1178
msgid "invalid number"
msgstr "грешно число"

#: expr.c:1182
msgid "invalid arithmetic base"
msgstr "грешна аритметична основа на бройна система"

#: expr.c:1202
msgid "value too great for base"
msgstr "стойността е прекалено голяма за основата"

#: general.c:62
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: родителските директории не могат да бъдат достъпени"

#: input.c:231
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "не може да се задели нов файлов дескриптор за вход на bash от дескриптор %d"

#: input.c:239
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "запазване на входа на bash: вече съществува буфер за новия файлов дескриптор %d"

#: jobs.c:923
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "изтриване на спряната задача %d в групата процеси %ld"

#: jobs.c:1308
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "описателен идентификатор на процес: %ld: няма такъв идентификатор на процес"

#: jobs.c:1981 nojobs.c:648
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "изчакване: процесът с идентификатор %ld не е дъщерен на тази обвивка"

#: jobs.c:2180
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "изчакване: липсват данни за процес с идентификатор %ld"

#: jobs.c:2435
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "изчакване на задача: задачата %d е спряна"

#: jobs.c:2657
#, c-format
msgid "%s: job has terminated"
msgstr "%s: задачата е приключила"

#: jobs.c:2666
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: задача %d вече е във фонов режим"

#: jobs.c:3452
msgid "no job control in this shell"
msgstr "в тази обвивка няма управление на задачите"

#: lib/malloc/malloc.c:298
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "заделяне на памет: грешно предположение: %s\n"

#: lib/malloc/malloc.c:314
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"заделяне на памет: %s:%d: предположението е отпечатано\r\n"

#: lib/malloc/malloc.c:740
msgid "malloc: block on free list clobbered"
msgstr "заделяне на памет: блок в списъка със свободни блокове е зает или неподходящ"

#: lib/malloc/malloc.c:817
msgid "free: called with already freed block argument"
msgstr "изчистване на памет: извикано е с блоков аргумент, който вече е изчистен"

#: lib/malloc/malloc.c:820
msgid "free: called with unallocated block argument"
msgstr "изчистване на памет: извикано е с незаделен блоков аргумент"

#: lib/malloc/malloc.c:839
msgid "free: underflow detected; mh_nbytes out of range"
msgstr ""
"изчистване на памет: открито е отрицателно препълване с mh_nbytes извън\n"
"допустимия диапазон"

#: lib/malloc/malloc.c:845
msgid "free: start and end chunk sizes differ"
msgstr "изчистване на памет: късовете на началната и крайната области се различават"

#: lib/malloc/malloc.c:942
msgid "realloc: called with unallocated block argument"
msgstr "презаделяне: извикано е с аргумент с незаделен блок"

#: lib/malloc/malloc.c:957
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr ""
"презаделяне: открито е отрицателно препълване с mh_nbytes извън допустимия\n"
"диапазон"

#: lib/malloc/malloc.c:963
msgid "realloc: start and end chunk sizes differ"
msgstr "презаделяне: късовете на началната и крайната области се различават"

#: lib/malloc/table.c:175
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "регистриране на презаделяне: таблицата за заделянията е пълна с FIND_ALLOC?\n"

#: lib/malloc/table.c:182
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "регистриране на презаделяне: %p вече е в таблицата като заделен?\n"

#: lib/malloc/table.c:218
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "регистриране на свободни: %p вече е в таблицата като свободен?\n"

#: lib/malloc/watch.c:46
msgid "allocated"
msgstr "заделени"

#: lib/malloc/watch.c:48
msgid "freed"
msgstr "освободени"

#: lib/malloc/watch.c:50
msgid "requesting resize"
msgstr "изисква се преоразмераване"

#: lib/malloc/watch.c:52
msgid "just resized"
msgstr "току що преораземерени"

#: lib/malloc/watch.c:54
msgid "bug: unknown operation"
msgstr "грешка: непозната операция"

#: lib/malloc/watch.c:56
#, c-format
msgid "malloc: watch alert: %p %s "
msgstr "заделяне на памет: предупреждение при наблюдение: %p %s "

#: lib/sh/fmtulong.c:101
msgid "invalid base"
msgstr "грешна основа на бройна система"

#: lib/sh/netopen.c:158
#, c-format
msgid "%s: host unknown"
msgstr "%s: непознат хост"

#: lib/sh/netopen.c:165
#, c-format
msgid "%s: invalid service"
msgstr "%s: неправилна услуга"

#: lib/sh/netopen.c:296
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: неправилно указан мрежов път"

#: lib/sh/netopen.c:336
msgid "network operations not supported"
msgstr "не се поддържат мрежови операции"

#: mailcheck.c:386
msgid "You have mail in $_"
msgstr "Имате поща в $_"

#: mailcheck.c:411
msgid "You have new mail in $_"
msgstr "Имате нова поща в $_"

#: mailcheck.c:427
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Пощата в %s вече е прочетена\n"

#: make_cmd.c:322
msgid "syntax error: arithmetic expression required"
msgstr "синтактична грешка: изисква се аритметичен израз"

#: make_cmd.c:324
msgid "syntax error: `;' unexpected"
msgstr "синтактична грешка: неочакван знак „;“"

#: make_cmd.c:325
#, c-format
msgid "syntax error: `((%s))'"
msgstr "синтактична грешка: „((%s))“"

#: make_cmd.c:566
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "вътрешен документ с „<<“: неправилен вид инструкция %d"

#: make_cmd.c:736
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "пренасочване: инструкцията за пренасочване „%d“ е извън допустимия диапазон"

#: parse.y:2747
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "неочакван знак за край на файл „EOF“, а се очакваше съответстващ знак „%c“"

#: parse.y:3043
msgid "unexpected EOF while looking for `]]'"
msgstr "неочакван знак за край на файл „EOF“, а се очакваше „]]“"

#: parse.y:3048
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "синтактична грешка в условен израз: неочаквана лексема „%s“"

#: parse.y:3052
msgid "syntax error in conditional expression"
msgstr "синтактична грешка в условен израз"

#: parse.y:3130
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "неочаквана лексема „%s“, а се очакваше знакът „)“"

#: parse.y:3134
msgid "expected `)'"
msgstr "очакваше се „)“"

#: parse.y:3162
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "неочакван аргумент „%s“ за унарен условен оператор"

#: parse.y:3166
msgid "unexpected argument to conditional unary operator"
msgstr "неочакван аргумент за унарен условен оператор"

#: parse.y:3203
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "неочаквана лексема „%s“, очакваше се бинарен условен оператор"

#: parse.y:3207
msgid "conditional binary operator expected"
msgstr "очакваше се бинарен условен оператор"

#: parse.y:3223
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "неочакван аргумент „%s“ за бинарен условен оператор"

#: parse.y:3227
msgid "unexpected argument to conditional binary operator"
msgstr "неочакван аргумент за бинарен условен оператор"

#: parse.y:3238
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "неочаквана лексема „%c“ в условна команда"

#: parse.y:3241
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "неочаквана лексема „%s“ в условна команда"

#: parse.y:3245
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "неочаквана лексема %d в условна команда"

#: parse.y:4461
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "синтактична грешка в близост до неочакваната лексема „%s“"

#: parse.y:4479
#, c-format
msgid "syntax error near `%s'"
msgstr "синтактична грешка в близост до „%s“"

#: parse.y:4489
msgid "syntax error: unexpected end of file"
msgstr "синтактична грешка: неочакван край на файл"

#: parse.y:4489
msgid "syntax error"
msgstr "синтактична грешка"

#: parse.y:4551
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Използвайте „%s“, за да излезете от обвивката.\n"

#: parse.y:4710
msgid "unexpected EOF while looking for matching `)'"
msgstr "неочакван знак за край на файл „EOF“, очакваше се знакът „)“"

#: pcomplete.c:1001
#, c-format
msgid "completion: function `%s' not found"
msgstr "дописване: функцията „%s“ не е открита"

#: pcomplib.c:179
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "вмъкване на завършване на команда: %s указване на команда, което е NULL"

#: print_cmd.c:264
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "команда за печат: лош конектор „%d“"

#: print_cmd.c:1236
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "отпечатване: „%c“: неправилен форматиращ знак"

#: redir.c:99
msgid "file descriptor out of range"
msgstr "файловият дескриптор е извън допустимия диапазон"

#: redir.c:141
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: двусмислено пренасочване"

#: redir.c:145
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: не може да се презапише съществуващ файл"

#: redir.c:150
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: поради ограничение изходът не може да се пренасочи"

#: redir.c:155
#, c-format
msgid "cannot create temp file for here document: %s"
msgstr "не може да се създаде временен файл за вътрешен документ с „<<“: %s"

#: redir.c:509
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "/dev/(tcp|udp)/host/port не се поддържа, ако няма поддръжка на мрежа"

#: redir.c:956
msgid "redirection error: cannot duplicate fd"
msgstr "грешка при пренасочване: файловият дескриптор не може да бъде дублиран"

#: shell.c:309
msgid "could not find /tmp, please create!"
msgstr "не е открита директорията /tmp. Създайте я!"

#: shell.c:313
msgid "/tmp must be a valid directory name"
msgstr "/tmp трябва да е директория"

#: shell.c:849
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: неправилна опция"

#: shell.c:1598
msgid "I have no name!"
msgstr "Не може да се получи името на текущия потребител!"

#: shell.c:1733
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Употреба:    %s [дълга опция на GNU] [опция] …\n"
"             %s [дълга опция на GNU] [опция] файл-скрипт …\n"

#: shell.c:1735
msgid "GNU long options:\n"
msgstr "Дълги опции на GNU:\n"

#: shell.c:1739
msgid "Shell options:\n"
msgstr "Опции на обвивката:\n"

#: shell.c:1740
msgid "\t-irsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "    -irsD или -c команда, или -O къса_опция        (само при стартиране)\n"

#: shell.c:1755
#, c-format
msgid "\t-%s or -o option\n"
msgstr "    -%s или -o опция\n"

#: shell.c:1761
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "За повече информация за опциите на обвивката въведете „%s -c \"help set\"“.\n"

#: shell.c:1762
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "За повече информация за вградените в обвивката команди въведете „%s -c help“.\n"

#: shell.c:1763
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "За да докладвате грешки използвайте командата „bashbug“.\n"

#: sig.c:494
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "маска за обработката на сигнали: %d: невалидна операция"

#: subst.c:1123
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "лошо заместване: липсва затварящ знак „%s“ в %s"

#: subst.c:2269
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: на член от масив не може да се присвои списък"

#: subst.c:4208 subst.c:4224
msgid "cannot make pipe for process substitution"
msgstr "не може да се създаде програмен канал за заместване на процеси"

#: subst.c:4255
msgid "cannot make child for process substitution"
msgstr "не може да се създаде дъщерен процес за заместване на процеси"

#: subst.c:4300
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "именуваният програмен канал %s не може да се отвори за четене"

#: subst.c:4302
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "именуваният програмен канал %s не може да се отвори за запис"

#: subst.c:4310
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "не може да се изчисти режимът без забавяне на файловия дескриптор %d"

#: subst.c:4320
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr ""
"именуваният програмен канал %s не може да се\n"
"дублира като файловия дескриптор %d"

#: subst.c:4495
msgid "cannot make pipe for command substitution"
msgstr "не може да се създаде програмен канал за заместване на команди"

#: subst.c:4531
msgid "cannot make child for command substitution"
msgstr "не може да се създаде дъщерен процес за заместване на команди"

#: subst.c:4548
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "заместване на команди: каналът не може да се дублира като fd 1"

#: subst.c:5013
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: аргументът е null или не е зададен"

#: subst.c:5287
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: изразът от подниза е < 0"

#: subst.c:6058
#, c-format
msgid "%s: bad substitution"
msgstr "%s: лошо заместване"

#: subst.c:6134
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: не може да се задава по този начин"

#: subst.c:7687
#, c-format
msgid "no match: %s"
msgstr "няма съвпадение: %s"

#: test.c:154
msgid "argument expected"
msgstr "очаква се аргумент"

#: test.c:163
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: очаква се целочислен израз"

#: test.c:361
msgid "`)' expected"
msgstr "очаква се „)“"

#: test.c:363
#, c-format
msgid "`)' expected, found %s"
msgstr "очаква се „)“, а е получено %s"

#: test.c:378 test.c:787 test.c:790
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: очаква се унарен оператор"

#: test.c:543 test.c:830
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: очаква се бинарен оператор"

#: test.c:905
msgid "missing `]'"
msgstr "липсва „]“"

#: trap.c:194
msgid "invalid signal number"
msgstr "неправилен номер на сигнал"

#: trap.c:309
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "стартиране на предстоящите капани: неправилна стойност в trap_list[%d]: %p"

#: trap.c:313
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr ""
"стартиране на предстоящите капани: обработката на сигнали е SIG_DFL.\n"
"%d (%s) е преизпратено на текущата обвивка"

#: trap.c:349
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "обработка на капани: неправилен сигнал %d"

#: variables.c:320
#, c-format
msgid "error importing function definition for `%s'"
msgstr "грешка при внасянето на дефиницията на функция за „%s“"

#: variables.c:692
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "нивото на обвивката (%d) е прекалено голямо. Задава се да е 1"

#: variables.c:1651
msgid "make_local_variable: no function context at current scope"
msgstr ""
"създаване на локална променлива: липсва контекст на функция в текущата област\n"
"на видимост"

#: variables.c:2807
msgid "all_local_variables: no function context at current scope"
msgstr ""
"всички локални променливи: липсва контекст на функция в текущата област на\n"
"видимост"

#: variables.c:3021 variables.c:3030
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "неправилен знак на позиция %d в низа за изнасяне за %s"

#: variables.c:3036
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "липсва „=“ в низа за изнасяне за %s"

#: variables.c:3463
msgid "pop_var_context: head of shell_variables not a function context"
msgstr ""
"изваждане на контекст на променливи: в началото на структурата за променливи на\n"
"обвивката (shell_variables) е нещо, което не е контекст на функция"

#: variables.c:3476
msgid "pop_var_context: no global_variables context"
msgstr ""
"изваждане на контекст на променливи: липсва контекст за глобални променливи\n"
"(global_variables)"

#: variables.c:3548
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr ""
"изваждане на област: последният елемент структурата за променливи на обвивката\n"
"(shell_variables) не е временна област в обкръжението"

#: version.c:82
msgid "Copyright (C) 2005 Free Software Foundation, Inc.\n"
msgstr "Авторски права (C) 2005 Free Software Foundation, Inc.\n"

#: xmalloc.c:93
#, c-format
msgid "xmalloc: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr ""
"заделяне на памет: %lu байта не могат да се заделят (заделени са\n"
"%lu байта)"

#: xmalloc.c:95
#, c-format
msgid "xmalloc: cannot allocate %lu bytes"
msgstr "заделяне на памет: %lu байта не могат да се заделят"

#: xmalloc.c:115
#, c-format
msgid "xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)"
msgstr ""
"презаделяне на памет: %lu байта не могат да се заделят наново (заделени са\n"
"%lu байта)"

#: xmalloc.c:117
#, c-format
msgid "xrealloc: cannot allocate %lu bytes"
msgstr "презаделяне на памет: %lu байта не могат да се заделят"

#: xmalloc.c:151
#, c-format
msgid "xmalloc: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr ""
"заделяне на памет: %s:%d: %lu байта не могат да се заделят (заделени са\n"
"%lu байта)"

#: xmalloc.c:153
#, c-format
msgid "xmalloc: %s:%d: cannot allocate %lu bytes"
msgstr "заделяне на памет: %s:%d: %lu байта не могат да се заделят"

#: xmalloc.c:175
#, c-format
msgid "xrealloc: %s:%d: cannot reallocate %lu bytes (%lu bytes allocated)"
msgstr "презаделяне на памет: %s:%d: %lu байта не могат да се заделят (заделени са %lu байта)"

#: xmalloc.c:177
#, c-format
msgid "xrealloc: %s:%d: cannot allocate %lu bytes"
msgstr "презаделяне на памет: %s:%d: %lu байта не могат да се заделят"

#: builtins.c:244
msgid ""
" `alias' with no arguments or with the -p option prints the list\n"
"    of aliases in the form alias NAME=VALUE on standard output.\n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.  Alias returns\n"
"    true unless a NAME is given for which no alias has been defined."
msgstr ""
" „alias“ без аргументи или с опцията „-p“ отпечатва списъка със синонимите във\n"
"    формат ИМЕ=СТОЙНОСТ на стандартния изход.  В противен случай за всяко ИМЕ,\n"
"    за което е зададена стойност, се дефинира синоним.  Интервал в края на\n"
"    стойност предизвиква синонимно заместване на следващата дума при\n"
"    заместването на синонима.  Командата „alias“ връща истина, освен в случаите,\n"
"    когато се зададе ИМЕ, за което не е дефиниран синоним."

#: builtins.c:257
msgid ""
" Remove NAMEs from the list of defined aliases.  If the -a option is given,\n"
"    then remove all alias definitions."
msgstr ""
" ИМЕната се премахват от списъка с дефинираните синоними.  Ако е е дадена и\n"
"    опцията „-a“ тогава се премахват всички синоними."

#: builtins.c:266
msgid ""
" Bind a key sequence to a Readline function or a macro, or set\n"
"    a Readline variable.  The non-option argument syntax is equivalent\n"
"    to that found in ~/.inputrc, but must be passed as a single argument:\n"
"    bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    bind accepts the following options:\n"
"      -m  keymap         Use `keymap' as the keymap for the duration of "
"this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named "
"function.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -S                 List key sequences that invoke macros and their "
"values\n"
"      -s                 List key sequences that invoke macros and their "
"values\n"
"                         in a form that can be reused as input."
msgstr ""
" Присвояване на последователност от клавиши на функция или макрос от readline\n"
"    или задаване на променлива на readline.  Синтаксисът с аргументи без опции\n"
"    е еквивалентен на този във файла „~/.inputrc“, но трябва да се подаде като\n"
"    единствен аргумент:\n"
"    bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"\n"
"    bind приема следните опции:\n"
"      -m  ПОДРЕДБА    Използване на ПОДРЕДБАта като подредба на функциите на\n"
"                          клавишите докато командата се изпълнява.  Валидни са\n"
"                          следните имена: „emacs“, „emacs-standard“,\n"
"                          „emacs-meta“, „emacs-ctlx“, „vi“, „vi-move“,\n"
"                          „vi-command“ и „vi-insert“.\n"
"      -l              Списък с имената на функциите.\n"
"      -P              Списък с имената на функциите и присвояванията.\n"
"      -p              Списък с имената на функциите и присвояванията във вид,\n"
"                          който може да се използва за вход.\n"
"      -r  КЛАВИШНА_ПОСЛЕДОВАТЕЛНОСТ\n"
"                      Премахване на присвоената функция от\n"
"                          КЛАВИШНАта_ПОСЛЕДОВАТЕЛНОСТ.\n"
"      -x  КЛАВИШНА_ПОСЛЕДОВАТЕЛНОСТ:КОМАНДА_НА_ОБВИВКАТА\n"
"                      Изпълнение на КОМАНДАта_НА_ОБВИВКАТА при въвеждането на\n"
"                          КЛАВИШНАта_ПОСЛЕДОВАТЕЛНОСТ.\n"
"      -f  ФАЙЛ        Прочитане на присвояванията на клавиши от ФАЙЛа.\n"
"      -q  ИМЕ_НА_ФУНКЦИЯ\n"
"                      Проверка кои клавиши извикват функцията с това име.\n"
"      -u  ИМЕ_НА_ФУНКЦИЯ\n"
"                      Премахване на присвояванията към всички клавиши на\n"
"                          функцията с това име.\n"
"      -V              Списък с имената на променливите и стойностите им.\n"
"      -v              Списък с имената на променливите и стойностите им във вид,\n"
"                          който може да се използва за вход.\n"
"      -S              Списък с клавишните последователности, които извикват\n"
"                           макроси и стойностите им.\n"
"      -s              Списък с клавишните последователности, които извикват\n"
"                           макроси и стойностите им във вид, който може да се\n"
"                           използва за вход."

#: builtins.c:297
msgid ""
" Exit from within a FOR, WHILE or UNTIL loop.  If N is specified,\n"
"    break N levels."
msgstr ""
" Изход от цикъл ползващ FOR, WHILE или UNTIL.  Ако е указан N, се излиза от N\n"
"    обхващащи цикъла."

#: builtins.c:304
msgid ""
" Resume the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resume at the N-th enclosing loop."
msgstr ""
" Продължение със следващата итерация от цикъл ползващ FOR, WHILE или UNTIL.\n"
"    Ако е указан N, се продължава от N-тия обхващащ цикъл."

#: builtins.c:311
msgid ""
" Run a shell builtin.  This is useful when you wish to rename a\n"
"    shell builtin to be a function, but need the functionality of the\n"
"    builtin within the function itself."
msgstr ""
" Изпълнение на команда вградена в обвивката.  Това е полезно, когато искате да\n"
"    използвате името на команда вградена в обвивката за име на функция, но във\n"
"    функцията се нуждаете от командата."

#: builtins.c:320
msgid ""
" Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns returns \"$line $filename\".  With EXPR,\n"
"    returns \"$line $subroutine $filename\"; this extra information\n"
"    can be used used to provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
" Връща контекста на текущото извикване на подпрограма.\n"
"    \n"
"    Без ИЗРАЗ връща „$line $filename“.  С ИЗРАЗ връща\n"
"    „$line $subroutine $filename“.  Допълнителната информация може да се\n"
"    използва за получаване на информация за състоянието на стека.\n"
"    \n"
"    Стойността на ИЗРАЗа показва за колко рамки спрямо текущата да се изведе\n"
"    информация.  Най-горната рамка е 0."

#: builtins.c:334
msgid ""
" Change the current directory to DIR.  The variable $HOME is the\n"
"    default DIR.  The variable CDPATH defines the search path for\n"
"    the directory containing DIR.  Alternative directory names in CDPATH\n"
"    are separated by a colon (:).  A null directory name is the same as\n"
"    the current directory, i.e. `.'.  If DIR begins with a slash (/),\n"
"    then CDPATH is not used.  If the directory is not found, and the\n"
"    shell option `cdable_vars' is set, then try the word as a variable\n"
"    name.  If that variable has a value, then cd to the value of that\n"
"    variable.  The -P option says to use the physical directory structure\n"
"    instead of following symbolic links; the -L option forces symbolic "
"links\n"
"    to be followed."
msgstr ""
" Смяна на текущата директория да е ДИРЕКТОРИЯ.  Променливата $HOME е\n"
"    стандартната директория.  Променливата $CDPATH определя пътя за търсене\n"
"    на директории, които могат да съдържат ДИРЕКТОРИЯта.  Директориите в $CDPATH\n"
"    са разделени с „:“.  Липсващо име на директория означава текущата\n"
"    директория, т.е. „.“. Ако името на ДИРЕКТОРИЯта започва с наклонена черта\n"
"    „/“, $CDPATH не се ползва.  Ако директорията не е открита, но е зададена\n"
"    опцията на обвивката „cdable_vars“, то думата се пробва като име на\n"
"    променлива.  Ако променливата има стойност, то директорията се сменя\n"
"    към стойността на таи променлива.  Опцията „-P“ налага използването на\n"
"    фактическата подредба на директориите, вместо да се следват символните\n"
"    връзки.  Опцията „-L“ налага следването на символните връзки."

#: builtins.c:350
msgid ""
" Print the current working directory.  With the -P option, pwd prints\n"
"    the physical directory, without any symbolic links; the -L option\n"
"    makes pwd follow symbolic links."
msgstr ""
" Отпечатва текущата работна директория.  С опцията „-P“ командата „pwd“ извежда\n"
"    физическата директория - без символни връзки.  Опцията „-L“ кара командата\n"
"    „pwd“ да следва физическите връзки."

#: builtins.c:358
msgid " No effect; the command does nothing.  A zero exit code is returned."
msgstr " Без ефект - командата нищо не прави.  Връща се изходен код 0."

#: builtins.c:364
msgid " Return a successful result."
msgstr " Връща успешен резултат."

#: builtins.c:370
msgid " Return an unsuccessful result."
msgstr " Връща неуспешен резултат."

#: builtins.c:376
msgid ""
" Runs COMMAND with ARGS ignoring shell functions.  If you have a shell\n"
"    function called `ls', and you wish to call the command `ls', you can\n"
"    say \"command ls\".  If the -p option is given, a default value is used\n"
"    for PATH that is guaranteed to find all of the standard utilities.  If\n"
"    the -V or -v option is given, a string is printed describing COMMAND.\n"
"    The -V option produces a more verbose description."
msgstr ""
" Изпълнение на КОМАНДА с АРГументи като се пренебрегват функциите в обвивката.\n"
"    Ако съществува функция на обвивката наречена „ls“, можете да извикате\n"
"    командата чрез „command ls“.  Ако е зададена опцията „-p“ се използва\n"
"    стандартна стойност на променливата $PATH, която гарантирано открива всички\n"
"    стандартни програми.  Ако е зададена някоя от опциите „-V“ или „-v“, се\n	"
"    отпечатва описание на КОМАНДАта.  Опцията „-V“ води до по-подробен изход."

#: builtins.c:387
msgid ""
" Declare variables and/or give them attributes.  If no NAMEs are\n"
"    given, then display the values of variables instead.  The -p option\n"
"    will display the attributes and values of each NAME.\n"
"    \n"
"    The flags are:\n"
"    \n"
"      -a\tto make NAMEs arrays (if supported)\n"
"      -f\tto select from among function names only\n"
"      -F\tto display function names (and line number and source file name "
"if\n"
"    \tdebugging) without definitions\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    `let') done when the variable is assigned to.\n"
"    \n"
"    When displaying values of variables, -f displays a function's name\n"
"    and definition.  The -F option restricts the display to function\n"
"    name only.\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute instead.  When\n"
"    used in a function, makes NAMEs local, as with the `local' command."
msgstr ""
" Обявяване на променливи и/или задаване на техните атрибути.  Ако не са зададени\n"
"    ИМЕна, то се показват стойностите на променливите.  Опцията „-p“ показва\n"
"    стойността и атрибутите за всяко ИМЕ.\n"
"    \n"
"    Опциите са:\n"
"    \n"
"        -a    да се създадат масиви с тези ИМЕна (ако това се поддържа)\n"
"        -f    да се избира само измежду имената на функциите\n"
"        -F    да се изведат имената на функциите (с номер на реда и име на файла\n"
"              с изходния код при изчистване на грешки) без дефинициите.\n"
"        -i    на ИМЕто се дава атрибут „цяло число“\n"
"        -r    маха се възможността за промяна на ИМЕната\n"
"        -t    на ИМЕто се дава атрибут „проследяване“\n"
"        -x    ИМЕто да бъде изнасяно\n"
"\n"
"    При променливите с атрибут за цяло число се извършва аритметично заместване\n"
"    (вижте командата „let“) при първоначално присвояване.\n"
"    \n"
"    При извеждането на стойностите на променливите „-f“ извежда имената и\n"
"    дефинициите на функциите.  Опцията „-F“ ограничава изведената информация\n"
"    до имената.\n"
"\n"
"    Използването на „+“ вместо „-“ премахва атрибута.  При използването във\n"
"    функция ИМЕната стават локални, както при използването на командата „local“."

#: builtins.c:416
msgid " Obsolete.  See `declare'."
msgstr " Остаряло, да не се използва.  Виж „declare“."

#: builtins.c:422
msgid ""
" Create a local variable called NAME, and give it VALUE.  LOCAL\n"
"    can only be used within a function; it makes the variable NAME\n"
"    have a visible scope restricted to that function and its children."
msgstr ""
" Създаване на локална променлива с ИМЕ и присвояване на СТОЙНОСТ.  ЛОКАЛНАта може\n"
"    да се използва само във функция.  Тя кара променливата на ИМЕ да е с област\n"
"    на видимост, която е ограничена до тази функция и наследниците ѝ."

#: builtins.c:431
msgid ""
" Output the ARGs.  If -n is specified, the trailing newline is\n"
"    suppressed.  If the -e option is given, interpretation of the\n"
"    following backslash-escaped characters is turned on:\n"
"    \t\\a\talert (bell)\n"
"    \t\\b\tbackspace\n"
"    \t\\c\tsuppress trailing newline\n"
"    \t\\E\tescape character\n"
"    \t\\f\tform feed\n"
"    \t\\n\tnew line\n"
"    \t\\r\tcarriage return\n"
"    \t\\t\thorizontal tab\n"
"    \t\\v\tvertical tab\n"
"    \t\\\\\tbackslash\n"
"    \t\\num\tthe character whose ASCII code is NUM (octal).\n"
"    \n"
"    You can explicitly turn off the interpretation of the above characters\n"
"    with the -E option."
msgstr ""
" Извеждане на АРГУМЕНТите.  Когато е зададена опцията „-n“, не се извежда знак\n"
"    за нов ред.  Ако е зададена опцията „-e“, се включва интерпретирането на\n"
"    следните знаци екранирани с обратна наклонена черта - „\\“:\n"
"        \\a    системен звънец\n"
"        \\b    триене назад\n"
"        \\c    пропускане на знака за нов ред\n"
"        \\E    знак за екраниране\n"
"        \\f    знак „Завършване на формуляра“ (form feed)\n"
"        \\n    знак за нов ред\n"
"        \\r    знак „Връщане на каретката“ (carriage return)\n"
"        \\t    хоризонтална табулация\n"
"        \\v    вертикална табулация\n"
"        \\\\    обратно наклонена черта\n"
"        \\НМР  знакът с код в ASCII - НоМеР (в осмична бройна система).\n"
"\n"
"    Можете изрично да спрете интерпретирането на горните знаци с опцията „-E“."

#: builtins.c:455
msgid ""
" Output the ARGs.  If -n is specified, the trailing newline is suppressed."
msgstr ""
" АРГУМЕНТите се извеждат.  Ако е дадена опцията „-n“, се подтиска извеждането\n"
"на нов ред."

#: builtins.c:462
msgid ""
" Enable and disable builtin shell commands.  This allows\n"
"    you to use a disk command which has the same name as a shell\n"
"    builtin without specifying a full pathname.  If -n is used, the\n"
"    NAMEs become disabled; otherwise NAMEs are enabled.  For example,\n"
"    to use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.  On systems supporting dynamic\n"
"    loading, the -f option may be used to load new builtins from the\n"
"    shared object FILENAME.  The -d option will delete a builtin\n"
"    previously loaded with -f.  If no non-option names are given, or\n"
"    the -p option is supplied, a list of builtins is printed.  The\n"
"    -a option means to print every builtin with an indication of whether\n"
"    or not it is enabled.  The -s option restricts the output to the "
"POSIX.2\n"
"    `special' builtins.  The -n option displays a list of all disabled "
"builtins."
msgstr ""
" Включване или изключване на вградените в обвивката команди.  Това ви позволява\n"
"    да използвате външна команда, която има същото име като вградена в обвивката\n"
"    команда, без да указвате име съдържащо път.  Ако използвате опцията „-n“\n"
"    ИМЕната се изключват, в противен случай се включват.  Например, за да\n"
"    използвате командата „test“, която се намира в пътищата указани с $PATH, а\n"
"    не версията вградена в обвивката, използвайте „enable -n test“.  При\n"
"    системите, които разполагат с динамично зареждане, опцията „-f“ може да се\n"
"    използва за зареждането на нова команда вградена в обвивката от споделен\n"
"    обект със съответното ИМЕ_НА_ФАЙЛ.  Опцията „-d“ изтрива ресурса зареден с\n"
"    „-f“.  Ако не са зададени имена, които да не са опции, или се използва\n"
"    опцията „-p“, се извеждат имената на вградените команди.  Опцията „-a“\n"
"    означава всяка вградена команда да се изведе заедно с това дали е включена\n"
"    или изключена.  Опцията „-s“ ограничава изхода до „специалните“ вградени\n"
"    команди на POSIX.2.  Опцията „-s“ извежда списъка на всички изключени\n"
"    вградени команди."

#: builtins.c:480
msgid " Read ARGs as input to the shell and execute the resulting command(s)."
msgstr ""
" Изчитане на АРГУМЕНТите като вход за обвивката и изпълнение на получените\n"
"команди."

#: builtins.c:486
msgid ""
" Getopts is used by shell procedures to parse positional parameters.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters ($0 - $9), but if\n"
"    more arguments are given, they are parsed instead."
msgstr ""
" getopts се използва от процедурите на обвивката за анализа на позиционните\n"
"    аргументи.\n"
"    \n"
"    НИЗът_С_ОПЦИИ съдържа знаците, които трябва да се разпознават като опции.\n"
"    Ако буквата е следвана от двоеточие, очаква се опцията да получава аргумент,\n"
"    който да е разделен от нея с интервал(и).\n"
"    \n"
"    При всяко извикване, „getopts“ поставя следващата опция в променливата на\n"
"    обвивката $name, като я инициализира, ако тя не съществува, а индексът на\n"
"    следващия аргумент, който трябва да се обработи, в променливата на обвивката\n"
"    $OPTIND.  $OPTIND се инициализира да е 1 при всяко извикване на обвивка или\n"
"    скрипт.  Когато опцията се нуждае от аргумент, той се поставя в променливата\n"
"    на обвивката $OPTARG.\n"
"    \n"
"    „getopts“ докладва грешки по един от два начина.  Ако първият знак на\n"
"    $OPTSTRING е двоеточие, „getopts“ използва тихо докладване.  В този режим\n"
"    не се извеждат никакви съобщения за грешка.  Ако се срещне неправилна опция,\n"
"    „getopts“ слага „:“ в $NAME, а в $OPTARG - срещнатия знак за опция.  Ако\n"
"    „getopts“ не е в режим на тихо докладване, в $NAME се слага „?“, $OPTARG се\n"
"    премахва и се изписва диагностично съобщение.\n"
"    \n"
"    Ако променливата на обвивката $OPTERR е със стойност 0, „getopts“ изключва\n"
"    извеждането на диагностични съобщения, дори първият знак в $OPTSTRING да не\n"
"    е двоеточие.  По подразбиране $OPTERR е със стойност 1.\n"
"    \n"
"    „getopts“ по принцип анализира позиционните аргументи ($0 - $9), но ако са\n"
"    дадени повече аргументи, те биват анализирани вместо това."

#: builtins.c:521
msgid ""
" Exec FILE, replacing this shell with the specified program.\n"
"    If FILE is not specified, the redirections take effect in this\n"
"    shell.  If the first argument is `-l', then place a dash in the\n"
"    zeroth arg passed to FILE, as login does.  If the `-c' option\n"
"    is supplied, FILE is executed with a null environment.  The `-a'\n"
"    option means to make set argv[0] of the executed process to NAME.\n"
"    If the file cannot be executed and the shell is not interactive,\n"
"    then the shell exits, unless the shell option `execfail' is set."
msgstr ""
" Изпълнение на ФАЙЛ, като обвивката бива заменена с указаната програма.  Ако\n"
"    ФАЙЛът не е указан, пренасочването се извършва в тази обвивка.  Ако първата\n"
"    опция е „-l“, нулевият аргумент подаден на ФАЙЛа e тире - подобно на това,\n"
"    което се случва при влизане в системата.   При подаването на опцията „-c“\n"
"    ФАЙЛът се изпълнява с празно обкръжение.  Опцията „-a“ означава нулевият\n"
"    елемент от масива с аргументи (argv[0]) да е ИМЕ.  Ако ФАЙЛът не може да се\n"
"    изпълни и обвивката не е интерактивна, обвивката завършва работа, освен ако\n"
"    не е зададена опцията на обвивката „execfail“."

#: builtins.c:534
msgid ""
" Exit the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
" Изход от обвивката с код N.  Ако N е изпуснат, то изходният код е този на\n"
"     последната изпълнена команда."

#: builtins.c:541
msgid " Logout of a login shell."
msgstr " Изход от входна обвивка"

#: builtins.c:548
msgid ""
" fc is used to list or edit and re-execute commands from the history list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"       -e ENAME selects which editor to use.  Default is FCEDIT, then "
"EDITOR,\n"
"          then vi.\n"
"    \n"
"       -l means list lines instead of editing.\n"
"       -n means no line numbers listed.\n"
"       -r means reverse the order of the lines (making it newest listed "
"first).\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, the command is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command."
msgstr ""
" „fc“ се използва, за изброяването или редактирането и повторното изпълнение на\n"
"    команди от списъка на историята.  ПЪРВИ и ПОСЛЕДЕН са номера, които могат да\n"
"    указват допустимия диапазон.  Ако е зададен само ПЪРВИят аргумент,  той\n"
"    задава низ, който е началото на команда.\n"
"    \n"
"       -e РЕДАКТОР    показва редактора, който да се използва.  Стандартно е\n"
"                          $FCEDIT, след това се проверява $EDITOR и накрая „vi“.\n"
"       -l             означава редовете да се покажат вместо редактират.\n"
"       -n             означава номерата на редовете да не се показват.\n"
"       -r             означава обратна подредба (отпред да е най-новият ред).\n"
"    \n"
"    При варианта „fc -s [ШАБЛ=ЗАМЕСТ …] [КОМАНДА]“ командата се изпълнява, като\n"
"    всяка поява на ШАБЛона се заменя със ЗАМЕСТителя.\n"
"    \n"
"    Удобен за използване синоним е „r='fc -s'“.  По такъв начин, ако напишете\n"
"    „r cc“, ще се изпълни последната команда, която започва с „cc“, а когато\n"
"    се въведе само „-r“, ще се изпълни последната команда."

#: builtins.c:573
msgid ""
" Place JOB_SPEC in the foreground, and make it the current job.  If\n"
"    JOB_SPEC is not present, the shell's notion of the current job is\n"
"    used."
msgstr ""
" Изважда ЗАДАЧА от фонов режим и я прави текуща задача.  Ако липсва\n"
"    аргумент ЗАДАЧА, се използва текущата задача според обвивката."

#: builtins.c:583
msgid ""
" Place each JOB_SPEC in the background, as if it had been started with\n"
"    `&'.  If JOB_SPEC is not present, the shell's notion of the current\n"
"    job is used."
msgstr ""
" Поставя всяка ЗАДАЧА във фонов режим, все едно е била стартирана с „&“.\n"
"    Ако липсва аргумент ЗАДАЧА, се използва текущата задача според обвивката."

#: builtins.c:592
msgid ""
" For each NAME, the full pathname of the command is determined and\n"
"    remembered.  If the -p option is supplied, PATHNAME is used as the\n"
"    full pathname of NAME, and no path search is performed.  The -r\n"
"    option causes the shell to forget all remembered locations.  The -d\n"
"    option causes the shell to forget the remembered location of each NAME.\n"
"    If the -t option is supplied the full pathname to which each NAME\n"
"    corresponds is printed.  If multiple NAME arguments are supplied with\n"
"    -t, the NAME is printed before the hashed full pathname.  The -l option\n"
"    causes output to be displayed in a format that may be reused as input.\n"
"    If no arguments are given, information about remembered commands is "
"displayed."
msgstr ""
" За всяко ИМЕ се определя и запомня пълното име с пътя на командата.\n"
"    Когато е указана опцията „-p“, ПЪТят се използва като пълен път за името и\n"
"    не се търси в нормалния път.  Опцията „-r“ кара обвивката да забрави всички\n"
"    запомнени места.  Опцията „-d“ кара обвивката да забрави запомненото място\n"
"    на обекта със съответното ИМЕ.  Ако е зададена опцията „-t“, извежда се\n"
"    цялото име с пътя на съответното ИМЕ.  Ако на опцията „-t“ са подадени\n"
"    множество ИМЕна, те се отпечатват преди хешираното пълно име.  Опцията „-l“\n"
"    форматира изхода по начин, който го прави удобен за вход.  Ако не са\n"
"    подадени аргументи, се извежда информация за запомнените команди."

#: builtins.c:608
msgid ""
" Display helpful information about builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise a list of the builtins is printed.  The -s option\n"
"    restricts the output for each builtin command matching PATTERN to\n"
"    a short usage synopsis."
msgstr ""
" Извеждане на полезна информация за вградените команди.  Ако е указан ШАБЛОН,\n"
"    се извежда информация само за командите, които напасват, в противен случай\n"
"    се извежда информация за всички команди.  Опцията „-s“  ограничава\n"
"    информацията за всяка вградена команда до кратко съобщение за\n"
"    предназначението ѝ."

#: builtins.c:620
msgid ""
" Display the history list with line numbers.  Lines listed with\n"
"    with a `*' have been modified.  Argument of N says to list only\n"
"    the last N lines.  The `-c' option causes the history list to be\n"
"    cleared by deleting all of the entries.  The `-d' option deletes\n"
"    the history entry at offset OFFSET.  The `-w' option writes out the\n"
"    current history to the history file;  `-r' means to read the file and\n"
"    append the contents to the history list instead.  `-a' means\n"
"    to append history lines from this session to the history file.\n"
"    Argument `-n' means to read all history lines not already read\n"
"    from the history file and append them to the history list.\n"
"    \n"
"    If FILENAME is given, then that is used as the history file else\n"
"    if $HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    If the -s option is supplied, the non-option ARGs are appended to\n"
"    the history list as a single entry.  The -p option means to perform\n"
"    history expansion on each ARG and display the result, without storing\n"
"    anything in the history list.\n"
"    \n"
"    If the $HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed otherwise."
msgstr ""
" Показване на списъка на историята с номера на ред.  Редовете, които са\n"
"    отбелязани със знака „*“, са били променени.  Аргументът N указва да се\n"
"    извеждат само N на брой реда.  Опцията „-c“ предизвиква изчистването на\n"
"    списъка, като се изтриват всички елементи от него.  Опцията „-d“ изтрива\n"
"    елемента в историята намиращ се посочената ПОЗИЦИЯ.  Опцията „-w“ записва\n"
"    текущата история във файла за историята.  Опцията „-r“ означава същият файл\n"
"    да се прочете, а съдържанието му да се добави към историята.  Опцията „-a“\n"
"    добавя историята от текущата сесия към файла с историята.  Опцията „-n“\n"
"    предизвиква всички редове от файла с историята, които все още не са\n"
"    прочетени от файла с историята, да се прочетат и добавят към текущата\n"
"    история на командите.\n"
"    \n"
"    Ако аргументът ИМЕ_НА_ФАЙЛ е зададен, той се използва като файл за\n"
"    историята. Ако той липсва, се използва файлът сочен в променливата на\n"
"    средата $HISTFILE. В противен случай се ползва „~/.bash_history“. Ако е\n"
"    зададена опцията „-s“, аргументите, които не са опции, се добавят като един\n"
"    елемент към файла с историята.  Опцията „-p“ означава да се извърши\n"
"    историческо заместване за всеки АРГУМЕНТ, а резултатът да се изведе, без\n"
"    нищо да се записва в историята на командите.\n"
"    \n"
"    Ако променливата $HISTTIMEFORMAT е зададена и не е „null“, стойността ѝ се\n"
"    използва като форматиращия низ за функцията „strftime“, за да се отбелязва\n"
"    времето свързано с всеки елемент от историята.  В противен случай времето не\n"
"    се записва."

#: builtins.c:648
msgid ""
" Lists the active jobs.  The -l option lists process id's in addition\n"
"    to the normal information; the -p option lists process id's only.\n"
"    If -n is given, only processes that have changed status since the last\n"
"    notification are printed.  JOBSPEC restricts output to that job.  The\n"
"    -r and -s options restrict output to running and stopped jobs only,\n"
"    respectively.  Without options, the status of all active jobs is\n"
"    printed.  If -x is given, COMMAND is run after all job specifications\n"
"    that appear in ARGS have been replaced with the process ID of that "
"job's\n"
"    process group leader."
msgstr ""
" Извежда списък с активните задачи.  Опцията „-l“ включва и идентификатора на\n"
"    процесите в добавка към стандартната информация.  Опцията „-p“ извежда само\n"
"    идентификаторите на процесите.  Ако е зададена опцията „-n“ се извеждат само\n"
"    процесите с променено състояние от последното извеждане на тази информация.\n"
"    ЗАДАЧАта ограничава информацията до себе си.  Опциите „-r“ и „-s“\n"
"    ограничават съответно изхода само до работещите и спрени задачи.  Без опции\n"
"    се отпечатва състоянието на всички активни задачи.  Ако е зададена опцията\n"
"    „-x“, КОМАНДАта се изпълнява, след като всички ЗАДАЧи, които се появяват като\n"
"    аргументи, се заменят с идентификатора на водача на групата процеси."

#: builtins.c:664
msgid ""
" By default, removes each JOBSPEC argument from the table of active jobs.\n"
"    If the -h option is given, the job is not removed from the table, but "
"is\n"
"    marked so that SIGHUP is not sent to the job if the shell receives a\n"
"    SIGHUP.  The -a option, when JOBSPEC is not supplied, means to remove "
"all\n"
"    jobs from the job table; the -r option means to remove only running jobs."
msgstr ""
" По подразбиране премахва всеки аргумент ЗАДАЧА от таблицата на активните\n"
"    задачи.  Когато е зададена опцията „-h“, задачата не се премахва от\n"
"    таблицата, но се отбелязва да не получава сигнал „SIGHUP“, когато обвивката\n"
"    получи такъв сигнал.  Опцията „-а“, когато не е указана ЗАДАЧА, означава\n"
"    всички задачи да се извадят от таблицата със задачи.  Опцията „-r“ кара да\n"
"    се махнат само вървящите задачи."

#: builtins.c:675
msgid ""
" Send the processes named by PID (or JOBSPEC) the signal SIGSPEC.  If\n"
"    SIGSPEC is not present, then SIGTERM is assumed.  An argument of `-l'\n"
"    lists the signal names; if arguments follow `-l' they are assumed to\n"
"    be signal numbers for which names should be listed.  Kill is a shell\n"
"    builtin for two reasons: it allows job IDs to be used instead of\n"
"    process IDs, and, if you have reached the limit on processes that\n"
"    you can create, you don't have to start a process to kill another one."
msgstr ""
" Изпращане на сигнала SIGSPEC на процеса с идентификатор ИдП (или ЗАДАЧА).\n"
"    Ако сигналът SIGSPEC не съществува, се използва SIGTERM.\n"
"    Опцията „-l“ изброява имената на сигналите.  Ако към нея са добавени\n"
"    аргументи, те се интерпретират като номера на сигналите чиито имена\n"
"    да се изброят.  „kill“ е команда вградена в обвивката поради две\n"
"    причини: позволява да се използват и идентификатори на задачи освен\n"
"    идентификатори на процеси, а и ако сте пуснали максимално разрешения\n"
"    за вас брой процеси, няма да ви се налага да пуснете още един процес,\n"
"    за да убиете друг."

#: builtins.c:687
msgid ""
" Each ARG is an arithmetic expression to be evaluated.  Evaluation\n"
"    is done in fixed-width integers with no check for overflow, though\n"
"    division by 0 is trapped and flagged as an error.  The following\n"
"    list of operators is grouped into levels of equal-precedence operators.\n"
"    The levels are listed in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    If the last ARG evaluates to 0, let returns 1; 0 is returned\n"
"    otherwise."
msgstr ""
" Всеки аргумент е аритметичен израз, който се бъде изчислен.  Изчисленията\n"
"    се извършват в аритметика с целочислени стойности с постоянна широчина\n"
"    без проверка за препълване.  Делението на 0 се прихваща и се отбелязва\n"
"    грешка.  Следващият списък на оператори е разделен на групи според\n"
"    приоритета на операциите.  Подредбата е с намаляващ приоритет.\n"
"    \n"
"        id++, id--      последващо увеличаване/намаляване на променлива\n"
"        ++id, --id      предварително увеличаване/намаляване на променлива\n"
"        -, +            унарни минус, плюс\n"
"        !, ~            логическо и побитово отрицания\n"
"        **              вдигане на степен\n"
"        *, /, %         умножение, деление, целочислен остатък\n"
"        +, -            събиране, изваждане\n"
"        <<, >>          побитово местене наляво и надясно\n"
"        <=, >=, <, >    сравнение\n"
"        ==, !=          равно, различно\n"
"        &               побитово И\n"
"        ^               побитово ИЛИ, ИЛИ\n"
"        |               побитово ИЛИ\n"
"        &&              логическо И\n"
"        ||              логическо ИЛИ\n"
"        expr ? expr : expr\n"
"                        условен оператор\n"
"        =, *=, /=, %=,\n"
"        +=, -=, <<=, >>=,\n"
"        &=, ^=, |=      присвояване\n"
"    \n"
"    Разрешено е ползването на променливи на обвивката като операнди.\n"
"    Името на променлива се замества с нейната стойност (която се\n"
"    преобразува до цяло число с постоянна широчина) в израза.  Не\n"
"    е необходимо за променливата да е с атрибут за целочисленост, за\n"
"    да се използва в израз.\n"
"    \n"
"    Операторите се изчисляват по приоритет.  Подизразите в скоби се\n"
"    изчисляват първи и могат да променят приоритета.\n"
"    \n"
"    Ако последният АРГУМЕНТ се изчислява като 0, „let“ връща 1. В\n"
"    противен случай - връща 0."

#: builtins.c:730
msgid ""
" One line is read from the standard input, or from file descriptor FD if "
"the\n"
"    -u option is supplied, and the first word is assigned to the first "
"NAME,\n"
"    the second word to the second NAME, and so on, with leftover words "
"assigned\n"
"    to the last NAME.  Only the characters found in $IFS are recognized as "
"word\n"
"    delimiters.  If no NAMEs are supplied, the line read is stored in the "
"REPLY\n"
"    variable.  If the -r option is given, this signifies `raw' input, and\n"
"    backslash escaping is disabled.  The -d option causes read to continue\n"
"    until the first character of DELIM is read, rather than newline.  If the "
"-p\n"
"    option is supplied, the string PROMPT is output without a trailing "
"newline\n"
"    before attempting to read.  If -a is supplied, the words read are "
"assigned\n"
"    to sequential indices of ARRAY, starting at zero.  If -e is supplied "
"and\n"
"    the shell is interactive, readline is used to obtain the line.  If -n "
"is\n"
"    supplied with a non-zero NCHARS argument, read returns after NCHARS\n"
"    characters have been read.  The -s option causes input coming from a\n"
"    terminal to not be echoed.\n"
"    \n"
"    The -t option causes read to time out and return failure if a complete "
"line\n"
"    of input is not read within TIMEOUT seconds.  If the TMOUT variable is "
"set,\n"
"    its value is the default timeout.  The return code is zero, unless end-"
"of-file\n"
"    is encountered, read times out, or an invalid file descriptor is "
"supplied as\n"
"    the argument to -u."
msgstr ""
" От стандартния вход или от файловия дескриптор ФД, ако е използвана опцията „-u“,\n"
"    се прочита един ред и първата дума се присвоява на първото ИМЕ, втората дума\n"
"    на второто ИМЕ и т.н., а на последното ИМЕ се присвояват оставащите думи.\n"
"    Като разделители на думи се използват само знаците указани в $IFS.  Ако не са\n"
"    дадени ИМЕна, прочетеният ред се запазва в променливата $REPLY. Когато е\n"
"    използвана опцията „-r“, входът не се обработва и заместването на\n"
"    екранираните с „\\“ знаци се изключва. Опцията „-d“ кара „read“ да\n"
"    продължи до прочитането на първия знак, който присъства в променливата\n"
"    $DELIM, а не до минаването на нов ред.  Ако е зададена опцията „-p“, се\n"
"    извежда низът ПОДСКАЗКА без минаване на нов ред, преди да се четат знаци на\n"
"    входа.  Когато е зададена опцията „-a“, прочетените уми се присвояват\n"
"    последователно на елементите на МАСИВа, като индексът му започва от 0.  Ако\n"
"    присъства опцията „-e“, а обвивката е интерактивна, за четене на реда се\n"
"    използва „readline“.  Когато опцията „-n“ има аргумент БРОЙ_ЗНАЦИ, то „read“\n"
"    свършва след прочитането на този БРОЙ_ЗНАЦИ.  С опцията „-s“ входът от\n"
"    терминал не се отпечатва на екрана.\n"
"    \n"
"    Опцията „-t“ задава ИНТЕРВАЛ, в който трябва да се въведе цял ред.  В\n"
"    противен случай „read“ завършва с грешка.  Ако е зададена, стойността на\n"
"    променливата $TMOUT обозначава времето, за което трябва да се въведе редът.\n"
"    Изходният код е 0, освен ако не се срещне знак за край на файл „EOF“, мине\n"
"    ИНТЕРВАЛът за въвеждане или е зададен неправилен файлов дескриптор като\n"
"    аргумент на „-u“."

#: builtins.c:756
msgid ""
" Causes a function to exit with the return value specified by N.  If N\n"
"    is omitted, the return status is that of the last command."
msgstr ""
" Води до изход от функция с върнат код N.  Ако не е указан N, връща се изходния\n"
"    код на последната команда."

#: builtins.c:763
msgid ""
"     -a  Mark variables which are modified or created for export.\n"
"        -b  Notify of job termination immediately.\n"
"        -e  Exit immediately if a command exits with a non-zero status.\n"
"        -f  Disable file name generation (globbing).\n"
"        -h  Remember the location of commands as they are looked up.\n"
"        -k  All assignment arguments are placed in the environment for a\n"
"            command, not just those that precede the command name.\n"
"        -m  Job control is enabled.\n"
"        -n  Read commands but do not execute them.\n"
"        -o option-name\n"
"            Set the variable corresponding to option-name:\n"
"                allexport    same as -a\n"
"                braceexpand  same as -B\n"
"                emacs        use an emacs-style line editing interface\n"
"                errexit      same as -e\n"
"                errtrace     same as -E\n"
"                functrace    same as -T\n"
"                hashall      same as -h\n"
"                histexpand   same as -H\n"
"                history      enable command history\n"
"                ignoreeof    the shell will not exit upon reading EOF\n"
"                interactive-comments\n"
"                             allow comments to appear in interactive "
"commands\n"
"                keyword      same as -k\n"
"                monitor      same as -m\n"
"                noclobber    same as -C\n"
"                noexec       same as -n\n"
"                noglob       same as -f\n"
"                nolog        currently accepted but ignored\n"
"                notify       same as -b\n"
"                nounset      same as -u\n"
"                onecmd       same as -t\n"
"                physical     same as -P\n"
"                pipefail     the return value of a pipeline is the status "
"of\n"
"                             the last command to exit with a non-zero "
"status,\n"
"                             or zero if no command exited with a non-zero "
"status\n"
"                posix        change the behavior of bash where the default\n"
"                             operation differs from the 1003.2 standard to\n"
"                             match the standard\n"
"                privileged   same as -p\n"
"                verbose      same as -v\n"
"                vi           use a vi-style line editing interface\n"
"                xtrace       same as -x\n"
"        -p  Turned on whenever the real and effective user ids do not "
"match.\n"
"            Disables processing of the $ENV file and importing of shell\n"
"            functions.  Turning this option off causes the effective uid "
"and\n"
"            gid to be set to the real uid and gid.\n"
"        -t  Exit after reading and executing one command.\n"
"        -u  Treat unset variables as an error when substituting.\n"
"        -v  Print shell input lines as they are read.\n"
"        -x  Print commands and their arguments as they are executed.\n"
"        -B  the shell will perform brace expansion\n"
"        -C  If set, disallow existing regular files to be overwritten\n"
"            by redirection of output.\n"
"        -E  If set, the ERR trap is inherited by shell functions.\n"
"        -H  Enable ! style history substitution.  This flag is on\n"
"            by default when the shell is interactive.\n"
"        -P  If set, do not follow symbolic links when executing commands\n"
"            such as cd which change the current directory.\n"
"        -T  If set, the DEBUG trap is inherited by shell functions.\n"
"        -   Assign any remaining arguments to the positional parameters.\n"
"            The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed."
msgstr ""
"    -a    Отбелязване на променливите, които са създадени или променени, да\n"
"              бъдат изнесени.\n"
"    -b    Незабавно известяване на спиране на задача.\n"
"    -e    Незабавен изход, ако команда приключи команда с код, който не е 0.\n"
"    -f    Изключване на генерирането на имена на файлове (чрез „*“, „?“ и т.н.).\n"
"    -h    Запомняне на местоположението на команди при търсенето им.\n"
"    -k    Всички аргументи за присвояване се поместват в средата на команда, не\n"
"              само тези, които предхождат името на команда.\n"
"    -m    Включване на управлението на задачи.\n"
"    -n    Прочитане на команди, без да се изпълняват.\n"
"    -o ИМЕ_НА_ОПЦИЯ\n"
"          Задаване на променливата, която отговаря на ИМЕто_НА_ОПЦИЯ:\n"
"        allexport    същото като „-a“\n"
"        braceexpand  същото като „-B“\n"
"        emacs        използване на интерфейс за редактиране подобен на „emacs“\n"
"        errexit      същото като „-e“\n"
"        errtrace     същото като „-E“\n"
"        functrace    същото като „-T“\n"
"        hashall      същото като „-h“\n"
"        histexpand   същото като „-H“\n"
"        history      включване на историята на командите\n"
"        ignoreeof    обвивката няма да излезе при откриване на знак за край на\n"
"                         файл „EOF“.\n"
"        interactive-comments\n"
"                     позволяване на коментари в интерактивните команди\n"
"        keyword      същото като „-k“\n"
"        monitor      същото като „-m“\n"
"        noclobber    същото като „-C“\n"
"        noexec       същото като „-n“\n"
"        noglob       същото като „-f“\n"
"        nolog        тази опция се приема в момента, но се игнорира\n"
"        notify       същото като „-b“\n"
"        nounset      същото като „-u“\n"
"        onecmd       същото като „-t“\n"
"        physical     същото като „-P“\n"
"        pipefail     изходният код на програмния канал е този на последната\n"
"                         команда, която завършва с код различен от 0\n"
"        posix        промяна на поведението на „bash“ да отговаря на стандарт\n"
"                         1003.2\n"
"        privileged   същото като „-p“\n"
"        verbose      същото като „-v“\n"
"        vi           използване на интерфейс за редактиране подобен на „vi“\n"
"        xtrace       същото като „-x“\n"
"    -p    Опцията включена. когато реалният и ефективният идентификатори процеси\n"
"              не съвпадат.  Изключва обработката на файла $ENV и внасянето на\n"
"              функции на обвивката.  Изключването на тази опция води до това\n"
"              ефективните идентификатори за потребител и група да станат равни\n"
"              на реалните.\n"
"    -t    Изход след прочитането и изпълнението на една команда.\n"
"    -u    Незададените променливи да се третират като грешки при заместването.\n"
"    -v    Отпечатване на входните редове към обвивката при прочитането им.\n"
"    -x    Отпечатване на командите и аргументите им при изпълнението им.\n"
"    -B    Обвивката ще извършва заместване на изразите с фигурни скоби.\n"
"    -C    Предотвратяване на презаписването на съществуващите обикновени файлове\n"
"              чрез пренасочване на изхода.\n"
"    -E    Капанът за „ERR“ да се наследява от функциите на обвивката.\n"
"    -H    Включване на заместването чрез историята с „!“.  Стандартно тази опция\n"
"          е налична за интерактивните обвивки.\n"
"    -P    Да не се следват символните връзки при изпълнението на команди като\n"
"              „cd“, които променят текущата директория.\n"
"    -T    Капанът за „DEBUG“ да се наследява от функциите на обвивката.\n"
"    -     Оставащите аргументи да се тълкуват като позиционни.  Опциите „-x“ и\n"
"              са изключени.\n"
"    \n"
"    Използването на „+“ вместо „-“ изключва опциите.  Тези опции могат да се\n"
"    използват и при стартирането на обвивката.  Текущото им състояние се намира\n"
"    в „$-“.  Останалите n на брой АРГументи са позиционни и се присвояват\n"
"    съответно на $1, $2,… $n.  Ако не са зададени АРГументи, се извеждат\n"
"    всички променливи на средата."

#: builtins.c:836
msgid ""
" For each NAME, remove the corresponding variable or function.  Given\n"
"    the `-v', unset will only act on variables.  Given the `-f' flag,\n"
"    unset will only act on functions.  With neither flag, unset first\n"
"    tries to unset a variable, and if that fails, then tries to unset a\n"
"    function.  Some variables cannot be unset; also see readonly."
msgstr ""
" За всяко ИМЕ се премахва съответната променлива или име.  Когато е зададена\n"
"    опцията „-v“, „unset“ действа само на променливи.  Когато е зададена опцията\n"
"    „-f“, „unset“ действа само на функции.  Когато командата се използва без\n"
"    опции, първо се прави опита за премахване на променлива и след това на\n"
"    функция.  Някои променливи не могат да се премахнат.  Вижте вградената\n"
"    команда „readonly“."

#: builtins.c:846
msgid ""
" NAMEs are marked for automatic export to the environment of\n"
"    subsequently executed commands.  If the -f option is given,\n"
"    the NAMEs refer to functions.  If no NAMEs are given, or if `-p'\n"
"    is given, a list of all names that are exported in this shell is\n"
"    printed.  An argument of `-n' says to remove the export property\n"
"    from subsequent NAMEs.  An argument of `--' disables further option\n"
"    processing."
msgstr ""
" ИМЕната се маркират за автоматично изнасяне към средата на последвалите\n"
"    команди.  Ако е зададена опцията „-f“, ИМЕната са на функции.  Ако не са\n"
"    дадени ИМЕна, или е използвана опцията „-p“, се извежда списък с всички\n"
"    имена, които са изнесени от тази обвивка.  Опцията „-n“ указва следващите\n"
"    ИМЕна повече да не са изнесени.  Аргументът „--“ изключва третирането на\n"
"    следващите аргументи като опции."

#: builtins.c:858
msgid ""
" The given NAMEs are marked readonly and the values of these NAMEs may\n"
"    not be changed by subsequent assignment.  If the -f option is given,\n"
"    then functions corresponding to the NAMEs are so marked.  If no\n"
"    arguments are given, or if `-p' is given, a list of all readonly names\n"
"    is printed.  The `-a' option means to treat each NAME as\n"
"    an array variable.  An argument of `--' disables further option\n"
"    processing."
msgstr ""
" Премахва възможността за промяна на дадените ИМЕна при последващи присвоявания.\n"
"    Когато е използвана опцията „-f“, се премахва възможността за промяна на\n"
"    функциите с тези ИМЕна.  Ако не са дадени аргументи или е използвана опцията\n"
"    „-p“, се извеждат имената, които са без възможност за промяна.  Опцията „-a“\n"
"    означава всяко име да се интерпретира като променлива за масив.  Аргументът\n"
"    „--“ изключва третирането на следващите аргументи като опции."

#: builtins.c:870
msgid ""
" The positional parameters from $N+1 ... are renamed to $1 ...  If N is\n"
"    not given, it is assumed to be 1."
msgstr ""
" Позиционните аргументи от $N+1 и нагоре съответно се преименуват на $1 и\n"
"    нагоре.  Ако N не е зададен, приема се, че е 1."

#: builtins.c:877 builtins.c:886
msgid ""
" Read and execute commands from FILENAME and return.  The pathnames\n"
"    in $PATH are used to find the directory containing FILENAME.  If any\n"
"    ARGUMENTS are supplied, they become the positional parameters when\n"
"    FILENAME is executed."
msgstr ""
" Изчитане и изпълнение на командите от ФАЙЛа и изход.  Директориите описани в\n"
"    променливата $PATH се използват за изпълнението на командите от ФАЙЛа.  Ако\n"
"    са зададени АРГУМЕНТИ, те се превръщат в позиционни аргументи при\n"
"    изпълнението на ФАЙЛа."

#: builtins.c:896
msgid ""
" Suspend the execution of this shell until it receives a SIGCONT\n"
"    signal.  The `-f' if specified says not to complain about this\n"
"    being a login shell if it is; just suspend anyway."
msgstr ""
" Временно спиране на изпълнението на текущата обвивка до получаването на сигнала\n"
"    „SIGCONT“.  Ако е зададена опцията „-f“, се подтиска предупреждението, че\n"
"    това е входна обвивка, изпълнението ѝ просто се спира."

#: builtins.c:905
msgid ""
" Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators as well, and numeric comparison operators.\n"
"    \n"
"    File operators:\n"
"    \n"
"        -a FILE        True if file exists.\n"
"        -b FILE        True if file is block special.\n"
"        -c FILE        True if file is character special.\n"
"        -d FILE        True if file is a directory.\n"
"        -e FILE        True if file exists.\n"
"        -f FILE        True if file exists and is a regular file.\n"
"        -g FILE        True if file is set-group-id.\n"
"        -h FILE        True if file is a symbolic link.\n"
"        -L FILE        True if file is a symbolic link.\n"
"        -k FILE        True if file has its `sticky' bit set.\n"
"        -p FILE        True if file is a named pipe.\n"
"        -r FILE        True if file is readable by you.\n"
"        -s FILE        True if file exists and is not empty.\n"
"        -S FILE        True if file is a socket.\n"
"        -t FD          True if FD is opened on a terminal.\n"
"        -u FILE        True if the file is set-user-id.\n"
"        -w FILE        True if the file is writable by you.\n"
"        -x FILE        True if the file is executable by you.\n"
"        -O FILE        True if the file is effectively owned by you.\n"
"        -G FILE        True if the file is effectively owned by your group.\n"
"        -N FILE        True if the file has been modified since it was last "
"read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"        -z STRING      True if string is empty.\n"
"    \n"
"        -n STRING\n"
"        STRING         True if string is not empty.\n"
"    \n"
"        STRING1 = STRING2\n"
"                       True if the strings are equal.\n"
"        STRING1 != STRING2\n"
"                       True if the strings are not equal.\n"
"        STRING1 < STRING2\n"
"                       True if STRING1 sorts before STRING2 "
"lexicographically.\n"
"        STRING1 > STRING2\n"
"                       True if STRING1 sorts after STRING2 "
"lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"        -o OPTION      True if the shell option OPTION is enabled.\n"
"        ! EXPR         True if expr is false.\n"
"        EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"        EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"        arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                       -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2."
msgstr ""
" Изход с код 0 (истина) или 1 (лъжа) в зависимост от стойността на ИЗРАЗа.\n"
"    Изразите могат да бъдат унарни или бинарни.  Унарните най-често се използват\n"
"    за проверка на състоянието на файл.  Освен тях има и оператори за числови\n"
"    сравнения и низови оператори.\n"
"    \n"
"    Файлови оператори:\n"
"    \n"
"        -a ФАЙЛ    Истина, ако ФАЙЛът съществува.\n"
"        -b ФАЙЛ    Истина, ако ФАЙЛът е блоково устройство.\n"
"        -c ФАЙЛ    Истина, ако ФАЙЛът е знаково устройство.\n"
"        -d ФАЙЛ    Истина, ако ФАЙЛът е директория.\n"
"        -e ФАЙЛ    Истина, ако ФАЙЛът съществува.\n"
"        -f ФАЙЛ    Истина, ако ФАЙЛът съществува и е обикновен файл.\n"
"        -g ФАЙЛ    Истина, ако ФАЙЛът е със зададен бит за смяна на група\n"
"                       при изпълнение.\n"
"        -h ФАЙЛ    Истина, ако ФАЙЛът е символна връзка.\n"
"        -L ФАЙЛ    Истина, ако ФАЙЛът е символна връзка.\n"
"        -k ФАЙЛ    Истина, ако ФАЙЛът е със зададен лепкав бит.\n"
"        -p ФАЙЛ    Истина, ако ФАЙЛът е именуван програмен канал.\n"
"        -r ФАЙЛ    Истина, ако ФАЙЛът може да бъде прочетен от вас.\n"
"        -s ФАЙЛ    Истина, ако ФАЙЛът може да бъде записван от вас.\n"
"        -S ФАЙЛ    Истина, ако ФАЙЛът е програмно гнездо.\n"
"        -t ФДСК    Истина, ако Файловият_ДеСКриптор е отворен на терминал.\n"
"        -u ФАЙЛ    Истина, ако ФАЙЛът е със зададен бит за смяна на потребител\n"
"                       при изпълнение.\n"
"        -w ФАЙЛ    Истина, ако ФАЙЛът може да бъде записван от вас.\n"
"        -x ФАЙЛ    Истина, ако ФАЙЛът може да бъде изпълняван от вас.\n"
"        -O ФАЙЛ    Истина, ако ФАЙЛът може да бъде ефективно притежаван от вас.\n"
"        -G ФАЙЛ    Истина, ако ФАЙЛът може да бъде ефективно притежаван от вашата\n"
"                       група.\n"
"        -N ФАЙЛ    Истина, ако ФАЙЛът е бил променян от последното му прочитане.\n"
"    \n"
"         ФАЙЛ_1 -nt ФАЙЛ_2    Истина, ако ФАЙЛ_1 е по-нов от ФАЙЛ_2 (според\n"
"                                  датата на промяна).\n"
"         ФАЙЛ_1 -ot ФАЙЛ_2    Истина, ако ФАЙЛ_1 е по-стар от ФАЙЛ_2 (според\n"
"                                  датата на промяна).    \n"
"         ФАЙЛ_1 -ef ФАЙЛ_2    Истина, ако ФАЙЛ_1 е твърда връзка към ФАЙЛ_2.\n"
"    \n"
"    Низови оператори:\n"
"    \n"
"        -z НИЗ     Истина, ако НИЗът е празен.\n"
"        -n НИЗ     Истина, ако НИЗът не е празен.\n"
"         НИЗ       Истина, ако НИЗът не е празен.\n"
"    \n"
"        НИЗ_1  = НИЗ_2    Истина, ако низовете са равни.\n"
"        НИЗ_1 != НИЗ_2    Истина, ако низовете не са равни.\n"
"        НИЗ_1  < НИЗ_2    Истина, ако НИЗ_1 е лексикографски преди НИЗ_2.\n"
"        НИЗ_1  > НИЗ_2    Истина, ако НИЗ_1 е лексикографски след НИЗ_2.\n"
"    \n"
"    Други оператори:\n"
"    \n"
"        -o ОПЦИЯ                Истина, ако ОПЦИЯта на обвивката е зададена.\n"
"        !  ИЗРАЗ                Истина, ако ИЗРАЗът е лъжа.\n"
"        ИЗРАЗ_1 -a ИЗРАЗ_2      Истина, ако и двата ИЗРАЗа са истина.\n"
"        ИЗРАЗ_1 -o ИЗРАЗ_2      Истина, ако поне един от ИЗРАЗите е истина.\n"
"    \n"
"        АРГ_1 ОПЕРАТОР АРГ_2    Аритметични тестове.  Те връщат истина, ако се\n"
"                                изпълнява математическото условие на ОПЕРАТОРа,\n"
"                                който е един от следните (значението е в скоби):\n"
"                                    „-eq“ (=),  „-ne“ (!=), „-lt“ (<),\n"
"                                    „-le“ (<=), „-gt“ (>) , „-ge“ (>=)."

#: builtins.c:975
msgid ""
" This is a synonym for the \"test\" builtin, but the last\n"
"    argument must be a literal `]', to match the opening `['."
msgstr ""
" Това е синоним на вградената команда „test“, но последният аргумент трябва\n"
"    задължително да е знакът „]“, който да съответства на отварящата скоба „[“."

#: builtins.c:982
msgid ""
" Print the accumulated user and system times for processes run from\n"
"    the shell."
msgstr ""
" Отпечатване на натрупаното потребителско и системно време за процеси, които са\n"
"    стартирани през обвивката."

#: builtins.c:989
msgid ""
" The command ARG is to be read and executed when the shell receives\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.  If a SIGNAL_SPEC is EXIT (0)\n"
"    the command ARG is executed on exit from the shell.  If a SIGNAL_SPEC\n"
"    is DEBUG, ARG is executed after every simple command.  If the`-p' "
"option\n"
"    is supplied then the trap commands associated with each SIGNAL_SPEC are\n"
"    displayed.  If no arguments are supplied or if only `-p' is given, trap\n"
"    prints the list of commands associated with each signal.  Each "
"SIGNAL_SPEC\n"
"    is either a signal name in <signal.h> or a signal number.  Signal names\n"
"    are case insensitive and the SIG prefix is optional.  `trap -l' prints\n"
"    a list of signal names and their corresponding numbers.  Note that a\n"
"    signal can be sent to the shell with \"kill -signal $$\"."
msgstr ""
" Командата АРГУМЕНТ ще бъде прочетена и изпълнена, когато обвивката получи\n"
"    УКАЗАНия_СИГНАЛ(и).  Ако АРГУМЕНТът липсва (и се подава единичен\n"
"    УКАЗАН_СИГНАЛ) или е „-“, то всеки УКАЗАН_СИГНАЛ се връща към първоначалната\n"
"    си стойност.  Ако АРГУМЕНТът е нулевия низ, всеки УКАЗАН_СИГНАЛ се\n"
"    пренебрегва от обвивката и командите, които се стартират през нея.  Ако\n"
"    УКАЗАНият_СИГНАЛ е „EXIT (0)“, то командата АРГУМЕНТ се изпълнява от\n"
"    обвивката при изход.  Ако УКАЗАНият_СИГНАЛ е „DEBUG“, АРГУМЕНТът се\n"
"    изпълнява след всяка проста команда.  Ако е дадена опцията „-p“, то\n"
"    се извеждат командите свързани с всеки УКАЗАН_СИГНАЛ.  Всеки УКАЗАН_СИГНАЛ\n"
"    е или име на сигнал от файла „signal.h“ или номер на сигнал.  Няма разлика\n"
"    между главни и малки букви в имената на сигнали, а представката „SIG“ не е\n"
"    задължителна.  „trap -l“ отпечатва списъка с имената на сигналите и\n"
"    съответстващите им номера.  Забележете, че сигнал може да бъде изпратен на\n"
"    обвивката с командата „kill -signal $$“."

#: builtins.c:1008
msgid ""
" For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    If the -t option is used, `type' outputs a single word which is one of\n"
"    `alias', `keyword', `function', `builtin', `file' or `', if NAME is an\n"
"    alias, shell reserved word, shell function, shell builtin, disk file,\n"
"    or unfound, respectively.\n"
"    \n"
"    If the -p flag is used, `type' either returns the name of the disk\n"
"    file that would be executed, or nothing if `type -t NAME' would not\n"
"    return `file'.\n"
"    \n"
"    If the -a flag is used, `type' displays all of the places that contain\n"
"    an executable named `file'.  This includes aliases, builtins, and\n"
"    functions, if and only if the -p flag is not also used.\n"
"    \n"
"    The -f flag suppresses shell function lookup.\n"
"    \n"
"    The -P flag forces a PATH search for each NAME, even if it is an alias,\n"
"    builtin, or function, and returns the name of the disk file that would\n"
"    be executed."
msgstr ""
" За всяко ИМЕ се отпечатва как ще се интерпретира, ако се използва за име на\n"
"    команда.\n"
"        \n"
"    Ако се използва опцията „-t“, командата „type“ извежда единствена дума,\n"
"    която е някоя от „alias“,  „keyword“, „function“, „builtin“, „file“ или „“,\n"
"    ако ИМЕто съответно е синоним, запазена дума на обвивката, функция на\n"
"    обвивката, вградена команда в обвивката, файл или не е намерено.\n"
"    \n"
"    Ако се използва опцията „-p“, командата „type“ или извежда името на файла,\n"
"    който ще се изпълни, или не извежда в нищо, в случаите, когато „type -t ИМЕ“\n"
"    не връща „file“.\n"
"    \n"
"    Ако се използва опцията „-a“, командата „type“ извежда всички места, които\n"
"    съдържат изпълним обект с такова ИМЕ.  Това включва синонимите, вградените\n"
"    команди и функции, но само ако не се използва и опцията „-p“.\n"
"    \n"
"    Опцията „-f“ подтиска търсенето във функциите на обвивката.\n"
"    \n"
"    Опцията „-P“ кара ИМЕто да се търси в пътя $PATH, дори ИМЕто да е\n"
"    синоним, вградена команда или функция, и да се изведе името на файла, който\n"
"    би се изпълнил."

#: builtins.c:1035
msgid ""
" Ulimit provides control over the resources available to processes\n"
"    started by the shell, on systems that allow such control.  If an\n"
"    option is given, it is interpreted as follows:\n"
"    \n"
"        -S\tuse the `soft' resource limit\n"
"        -H\tuse the `hard' resource limit\n"
"        -a\tall current limits are reported\n"
"        -c\tthe maximum size of core files created\n"
"        -d\tthe maximum size of a process's data segment\n"
"        -f\tthe maximum size of files created by the shell\n"
"        -i  the maximum number of pending signals\n"
"        -l\tthe maximum size a process may lock into memory\n"
"        -m\tthe maximum resident set size\n"
"        -n\tthe maximum number of open file descriptors\n"
"        -p\tthe pipe buffer size\n"
"        -q  the maximum number of bytes in POSIX message queues\n"
"        -s\tthe maximum stack size\n"
"        -t\tthe maximum amount of cpu time in seconds\n"
"        -u\tthe maximum number of user processes\n"
"        -v\tthe size of virtual memory\n"
"        -x  the maximum number of file locks\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource;\n"
"    the special LIMIT values `soft', `hard', and `unlimited' stand for\n"
"    the current soft limit, the current hard limit, and no limit, "
"respectively.\n"
"    Otherwise, the current value of the specified resource is printed.\n"
"    If no option is given, then -f is assumed.  Values are in 1024-byte\n"
"    increments, except for -t, which is in seconds, -p, which is in\n"
"    increments of 512 bytes, and -u, which is an unscaled number of\n"
"    processes."
msgstr ""
" ulimit осъществява контрол върху ресурсите, които са достъпни на процесите\n"
"    стартирани през обвивката върху системите, които поддържат такова\n"
"    управление.  Ако са зададени опции, те означават следното:\n"
"    \n"
"        -S    използване на „мекото“ ограничение на ресурс\n"
"        -H    използване на „твърдото“ ограничение на ресурс\n"
"        -a    извеждат се всички текущи ограничения\n"
"        -c    максималният размер на създадените файлове със съдържание на\n"
"                  паметта (core)\n"
"        -d    максималният размер на сегмента на процес за данни\n"
"        -f    максималният размер на файловете създадени от обвивката\n"
"        -i    максималният брой на изчакващите сигнали\n"
"        -l    максималният размер памет, която процес може да заключи\n"
"        -m    максималният постоянно зареден в паметта сегмент\n"
"        -n    максималният брой дескриптори на отворени файлове\n"
"        -p    размер на буфера за конвейери\n"
"        -q    максималният брой байтове в опашките за съобщения по POSIX\n"
"        -s    максималният размер на стека\n"
"        -t    максималното процесорно време в секунди\n"
"        -u    максималният брой потребителски процеси\n"
"        -v    размерът на виртуалната памет\n"
"        -x    максималният брой заключвания на файлове\n"
"    \n"
"    Ако е зададено ОГРАНИЧЕНИЕ, то това е новата стойност на указания ресурс.\n"
"    Специалните стойности „soft“, „hard“ и „unlimited“ означават текущите меко,\n"
"    твърдо и никакво ограничение съответно.  В противен случай се извежда\n"
"    текущата стойност на указания ресурс.  Стойностите са в блокове от по 1024\n"
"    байта, с изключение на:\n"
"        - опцията „-p“, при която блоковете са от по 512 байта;\n"
"        - опцията „-t“, при която стойността е в секунди;\n"
"        - опцията „-u“, при която стойността е точният брой процеси."

#: builtins.c:1071
msgid ""
" The user file-creation mask is set to MODE.  If MODE is omitted, or if\n"
"    `-S' is supplied, the current value of the mask is printed.  The `-S'\n"
"    option makes the output symbolic; otherwise an octal number is output.\n"
"    If `-p' is supplied, and MODE is omitted, the output is in a form\n"
"    that may be used as input.  If MODE begins with a digit, it is\n"
"    interpreted as an octal number, otherwise it is a symbolic mode string\n"
"    like that accepted by chmod(1)."
msgstr ""
" Маската за създадените от потребителя файлове е зададена да е РЕЖИМ.  Ако той\n"
"    е пропуснат или е дадена опцията „-S“, отпечатва се текущата стойност на\n"
"    маската.  Опцията „-S“ води до описателен изход, в противен случай се\n"
"    отпечатва число в осмична бройна система.  Ако е дадена опцията „-p“, а\n"
"    режимът е пропуснат, изходът може да се използва като вход.  Ако РЕЖИМът\n"
"    започва с цифра, то той се интерпретира като осмично число, в противен\n"
"    случай е описателен низ, който се приема от командата „chmod“."

#: builtins.c:1084
msgid ""
" Wait for the specified process and report its termination status.  If\n"
"    N is not given, all currently active child processes are waited for,\n"
"    and the return code is zero.  N may be a process ID or a job\n"
"    specification; if a job spec is given, all processes in the job's\n"
"    pipeline are waited for."
msgstr ""
" Изчакване на указания процес и докладване за изходния код.  Ако не е зададен N,\n"
"    всички текущо активни дъщерни процеси се изчакват и изходният код е 0.  N\n"
"    може да е идентификатор на процес или задача.  Ако е задача, изчакват се\n"
"    всички процеси в програмния канал на задачата."

#: builtins.c:1096
msgid ""
" Wait for the specified process and report its termination status.  If\n"
"    N is not given, all currently active child processes are waited for,\n"
"    and the return code is zero.  N is a process ID; if it is not given,\n"
"    all child processes of the shell are waited for."
msgstr ""
" Изчакване на указания процес и докладване за изходния код.  Ако не е зададен N,\n"
"    всички текущо активни дъщерни процеси се изчакват и изходният код е 0.  N\n"
"    е идентификатор на процес.  Ако не е задача, изчакват се всички процеси в\n"
"    програмния канал на задачата."

#: builtins.c:1106
msgid ""
" The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed."
msgstr ""
" Цикълът „for“ изпълнява последователност от команди за всеки член в списък от\n"
"    елементи.  Ако блокът „в ДУМИ …“ не присъства, използва се „in \"$@\"“.  За\n"
"    всеки елемент в ДУМИте, ИМЕто се задава да е елементът и се изпълняват\n"
"    КОМАНДИте."

#: builtins.c:1115
msgid ""
" Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1."
msgstr ""
" Еквивалентно на:\n"
"        (( ИЗРАЗ_1 ))\n"
"        while (( ИЗРАЗ_2 )); do\n"
"                КОМАНДИ\n"
"                (( EXP_3 ))\n"
"        done\n"
"    ИЗРАЗ_1, ИЗРАЗ_2, и ИЗРАЗ_3 са аритметични изрази.  Всеки изпуснат израз се\n"
"    изчислява да е 1."

#: builtins.c:1128
msgid ""
" The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed."
msgstr ""
" ДУМИте биват замествани, което води до създаването на списък с думи.\n"
"    Наборът от заместените думи бива отпечатан на изхода за стандартната\n"
"    грешка, като всяка от тях се предшества от номер.  Ако клаузата „in ДУМИ“\n"
"    липсва, използва се „in \"$@\"“.  В такива случа се отпечатва подсказката PS3\n"
"    и от стандартния вход се прочита ред.  Ако редът се състои от номера, който\n"
"    съответства на някоя от показаните думи, ИМЕто се задава да е тази дума.\n"
"    Ако редът е празен, отново се отпечатват ДУМИте и подсказката.  Ако се\n"
"    прочете „EOF“, командата завършва.  Всяка друга стойност присвоява „null“ на\n"
"    ИМЕ.  Прочетеният ред „null“ се запазва в променливата REPLY.  КОМАНДИте се\n"
"    изпълняват след всеки избор до изпълняването на команда за прекъсване\n"
"    (break)."

#: builtins.c:1144
msgid ""
" Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    The return status is the return status of PIPELINE.  The `-p' option\n"
"    prints the timing summary in a slightly different format.  This uses\n"
"    the value of the TIMEFORMAT variable as the output format."
msgstr ""
" Изпълнение на ПРОГРАМНия_КАНАЛ и отпечатване на обобщение за реалното,\n"
"    потребителското и системно процесорни времена, които изпълнението на\n"
"    ПРОГРАМНия_КАНАЛ отнема.  Изходният код е този на ПРОГРАМНия_КАНАЛ.  Опцията\n"
"    „-p“ води до извеждане на статистиката за времето в различен формат - според\n"
"    стойността на променливата на средата $TIMEFORMAT."

#: builtins.c:1154
msgid ""
" Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns."
msgstr ""
" Избирателно се изпълняват КОМАНДИ на база ДУМА, която напасва на ШАБЛОН.\n"
"    Шаблоните се разделят със знака „|“."

#: builtins.c:1161
msgid ""
" The `if COMMANDS' list is executed.  If its exit status is zero, then the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list "
"is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  "
"Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of "
"the\n"
"    entire construct is the exit status of the last command executed, or "
"zero\n"
"    if no condition tested true."
msgstr ""
" Първо се изпълняват командите в блока „if КОМАНДИ“.  Ако изходният код е 0, то\n"
"    се изпълнява блокът „then КОМАНДИ“.  В противен случай последователно се\n"
"    изпълнява всеки блок „elif КОМАНДИ“ - ако изходният код е 0, то се изпълнява\n"
"    съответния блок „then КОМАНДИ“, след което завършва изпълнението на целия\n"
"    блок „if“.  Ако изходният код на никой от блоковете „if“ и „elif“ не е бил 0,\n"
"    изпълнява се блока „else КОМАНДИ“, стига такъв да присъства.  Изходният код\n"
"    от цялата конструкция е този на последната изпълнена команда или е 0, ако\n"
"    никое тестово условие, не се е оценило като истина."

#: builtins.c:1173
msgid ""
" Expand and execute COMMANDS as long as the final command in the\n"
"    `while' COMMANDS has an exit status of zero."
msgstr ""
" Заместване и изпълнение на КОМАНДИте докато последната команда в блока „while“\n"
"    е с изходен код, който е 0."

#: builtins.c:1180
msgid ""
" Expand and execute COMMANDS as long as the final command in the\n"
"    `until' COMMANDS has an exit status which is not zero."
msgstr ""
" Заместване и изпълнение на КОМАНДИте докато последната команда в блока „until“\n"
"    е с изходен код, който не е 0."

#: builtins.c:1187
msgid ""
" Create a simple command invoked by NAME which runs COMMANDS.\n"
"    Arguments on the command line along with NAME are passed to the\n"
"    function as $0 .. $n."
msgstr ""
" Създаване на проста команда, която се извиква чрез ИМЕ, която стартира КОМАНДИ.\n"
"    Аргументите на командния ред, заедно с ИМЕто, се предават на функцията като\n"
"    $0 … $n."

#: builtins.c:1195
msgid ""
" Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands."
msgstr ""
" Изпълняване на цял набор от команди в група.  Това е един от начините да се\n"
"    цял набор от команди."

#: builtins.c:1202
msgid ""
" Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'."
msgstr ""
" Еквивалентно на аргумента ЗАДАЧА на командата „fg“.  Възобновява спряна\n"
"    задача или такава на заден фон.  ЗАДАЧАта може да указва или име, или\n"
"    номер на задача.  Ако след ЗАДАЧАта се въведе знакът „&“, задачата\n"
"    се изпълнява във фонов режим, все едно е била подадена като аргумент\n"
"    на командата „bg“."

#: builtins.c:1212
msgid ""
" The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to \"let EXPRESSION\"."
msgstr ""
" ИЗРАЗът се изчислява според правилата на аритметичното оценяване.\n"
"    Еквивалентно на „let ИЗРАЗ“."

#: builtins.c:1219
msgid ""
" Returns a status of 0 or 1 depending on the evaluation of the conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries "
"used\n"
"    by the `test' builtin, and may be combined using the following "
"operators\n"
"    \n"
"    \t( EXPRESSION )\tReturns the value of EXPRESSION\n"
"    \t! EXPRESSION\tTrue if EXPRESSION is false; else false\n"
"    \tEXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"    \tEXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of "
"the\n"
"    operator is used as a pattern and pattern matching is performed.  The\n"
"    && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value."
msgstr ""
" Връща състояние 0 или 1 в зависимост от оценката на условния ИЗРАЗ.  Изразите\n"
"    са съставени от същите примитиви, както вградената команда „test“ и могат да\n"
"    се съчетават чрез следните оператори:\n"
"    \n"
"        ( ИЗРАЗ )        Връща стойността на ИЗРАЗа\n"
"        ! ИЗРАЗ          Истина, ако ИЗРАЗ се оценя на лъжа, в останалите случаи\n"
"                         е лъжа\n"
"        ИЗРАЗ1 && ИЗРАЗ2 Истина, ако едновременно ИЗРАЗ1 и ИЗРАЗ2 са истина,\n"
"                         в останалите случаи е лъжа.\n"
"        ИЗРАЗ1 || ИЗРАЗ2 Истина, ако поне единият от ИЗРАЗ1 и ИЗРАЗ2 е истина,\n"
"                         в останалите случаи е лъжа.\n"
"    \n"
"    Когато се използват операторите „==“ и „!=“, низът от дясната страна на\n"
"    оператора се използва като шаблон и се извършва напасване.  Операторите\n"
"    „&&“ и „||“ не оценят ИЗРАЗ2, ако ИЗРАЗ1 е достатъчен за определяне на\n"
"    стойността на израза."

#: builtins.c:1237
msgid ""
" BASH_VERSION    Version information for this Bash.\n"
"    CDPATH          A colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE        The name of the file where your command history is "
"stored.\n"
"    HISTFILESIZE    The maximum number of lines this file can contain.\n"
"    HISTSIZE        The maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME            The complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE        The type of CPU this version of Bash is running under.\n"
"    IGNOREEOF       Controls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\t\tThe version of Unix this version of Bash is running on.\n"
"    PATH            A colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND  A command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1             The primary prompt string.\n"
"    PS2             The secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM            The name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume     Non-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars       Characters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
" BASHVERSION   Информация за версията на bash.\n"
"    CDPATH          Списък с директории разделени с двоеточие, които да се\n"
"                        търсят като аргументи за командата „cd“.\n"
"    GLOBIGNORE      Списък с шаблони на файлови имена, разделени с двоеточие,\n"
"                        които да се игнорират от заместването на пътя.\n"
"    HISTFILE        Името на файла, в който се съхранява историята на командите.\n"
"    HISTFILESIZE    Максималният брой редове, които горният файл може да\n"
"                        съдържа.\n"
"    HISTSIZE        Максималният брой редове, които една работеща обвивка може да\n"
"                        достъпи.\n"
"    HOME            Пълният път до домашната ви директория.\n"
"    HOSTNAME        Името на текущата машина.\n"
"    HOSTTYPE        Видът на процесора, под който работи текущата обвивка.\n"
"    IGNOREEOF       Управлява действието на обвивката при срещането на единичен\n"
"                        знак за край на файл „EOF“.  Ако променливата е зададена,\n"
"                        тя указва броя на знаците „EOF“, който могат да се\n"
"                        срещнат самостоятелно на един ред, преди обвивката да\n"
"                        завърши работа и излезе (стандартно е 10).  Когато\n"
"                        променливата не е зададена, един „EOF“ означава край на\n"
"                        входящите данни.\n"
"    MACHTYPE        Низ, който описва текущата система, на която работи bash.\n"
"    MAILCHECK       Колко често, в секунди, да проверява bash за нови писма.\n"
"    MAILPATH        Списък с файлове, които bash проверява за нови писма.\n"
"    OSTYPE          Версията на Юникс, на която работи bash.\n"
"    PATH            Списък с директории, които да се претърсват за команди.\n"
"    PROMPTCOMMAND  Команда, която да се изпълнява преди отпечатването на\n"
"                        основната подсказка на командния ред.\n"
"    PS1             Низ за основната подсказка.\n"
"    PS2             Низ за втората подсказка.\n"
"    PWD             Пълният път и име на текущата директория.\n"
"    SHELLOPTS       Списък с включените опции на обвивката, разделени с\n"
"                        двоеточие.\n"
"    TERM            Името на текущия вид терминал.\n"
"    TIMEFORMAT      Изходният формат за статистиката за времето за изпълнение\n"
"                        на команда, който се използва от запазената дума „time“.\n"
"    autoresume     Стойност, която не е „null“, означава, че командна дума, която\n"
"                        се появява самостоятелно на ред, първо се проверява в\n"
"                        списъка с текущо спрените задачи.  Ако бъде открита там,\n"
"                        задачата се пуска и се слага на преден план.  Стойност\n"
"                        „exact“ (строго съвпадение) означава, че командната\n"
"                        дума, трябва точно да съвпада с името на команда в\n"
"                        списъка със спрени задачи.  Стойност „substring“\n"
"                        (съвпадение на подниз) означава, че командната дума\n"
"                        трябва да е подниз на задачата.  Всяка друга стойност\n"
"                        означава, че командата думата трябва да е началото на\n"
"                        спряна задача.\n"
"    histchars       Знаци, които определят бързото заместване и това по история.\n"
"                        Първият знак е за заместването по история, обикновено е\n"
"                        „!“.  Вторият е за бързото заместване, обикновено е „^“.\n"
"                        Третият е за коментарите в историята,  обикновено е „#“.\n"
"    HISTIGNORE      Списък с шаблони, разделени с двоеточие, които указват кои\n"
"                        команди да не се запазват в историята.\n"

#: builtins.c:1292
msgid ""
" Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"    -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"    -n\tsuppress the normal change of directory when adding directories\n"
"    \tto the stack, so only the stack is manipulated.\n"
"    \n"
"    dir\tadds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    You can see the directory stack with the `dirs' command."
msgstr ""
" Добавя директория в стека на директориите или превърта стека\n"
"    като най-горна директория става текущата директория.  Без\n"
"    аргументи сменя най-горните две директории.\n"
"    \n"
"    +N  Превърта стека, така че N-тата директория (като се брои\n"
"     от лявата страна на списъка, показан от командата „dirs“\n"
"     като се почва от 0) да е най-отгоре.\n"
"    \n"
"    -N  Превърта стека, така че N-тата директория (като се брои\n"
"     от дясната страна на списъка, показан от командата „dirs“\n"
"     като се почва от 0) да е най-отгоре.\n"
"    \n"
"    -n  подтискане на нормалното преминаване към директория при\n"
"    добавянето на директории към стека, така че се променя само той.\n"
"\n"
"    dir  добавя ДИР най-отгоре в стека на директориите, като я прави\n"
"    новата текуща работна директория.\n"
"    \n"
"    Можете да изведете стека на директорията с командата „dirs“."

#: builtins.c:1318
msgid ""
" Removes entries from the directory stack.  With no arguments,\n"
"    removes the top directory from the stack, and cd's to the new\n"
"    top directory.\n"
"    \n"
"    +N\tremoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"    -N\tremoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    -n\tsuppress the normal change of directory when removing directories\n"
"    \tfrom the stack, so only the stack is manipulated.\n"
"    \n"
"    You can see the directory stack with the `dirs' command."
msgstr ""
" Маха директории от стека с тях. Без аргументи\n"
"    премахва последната директория в стека и влиза в новата\n"
"    последна директория.\n"
"    \n"
"    +N  премахва N-тия елемент като се брои отляво в списъка\n"
"        показван от командата „dirs“, като се брои от 0.  Напр.: „popd +0“\n"
"        премахва първата директория, „popd +1“ - втората.\n"
"\n"
"    -N  премахва N-тия елемент като се брои отдясно в списъка\n"
"        показван от командата „dirs“, като се брои от 0.  Напр.: „popd -0“\n"
"        премахва последната директория, „popd -1“ - предпоследната.\n"
"\n"
"    -n  подтискане на нормалното преминаване към директория при добавянето на\n"
"        директории към стека, така че се променя само той.\n"
"\n"
"    Стекът с директориите се визуализира с командата „dirs“."

#: builtins.c:1341
msgid ""
" Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    The -l flag specifies that `dirs' should not print shorthand versions\n"
"    of directories which are relative to your home directory.  This means\n"
"    that `~/bin' might be displayed as `/homes/bfox/bin'.  The -v flag\n"
"    causes `dirs' to print the directory stack with one entry per line,\n"
"    prepending the directory name with its position in the stack.  The -p\n"
"    flag does the same thing, but the stack position is not prepended.\n"
"    The -c flag clears the directory stack by deleting all of the elements.\n"
"    \n"
"    +N\tdisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"    -N\tdisplays the Nth entry counting from the right of the list shown by\n"
"    \tdirs when invoked without options, starting with zero."
msgstr ""
" Показва списъка с текущо запомнените директории.  Списъкът се попълва чрез\n"
"    командата „pushd“.  Можете да вадите директории от списъка с командата\n"
"    „popd“.\n"
"    \n"
"    Опцията „-l“ кара командата „dirs“ да извежда пълните имена на директориите,\n"
"    а не съкратените спрямо домашната директория имена.  Това означава, че\n"
"    „~/bin“ може да се покаже като „/homes/pesho/bin“.  Опцията „-v“ води до\n"
"    отпечатване на стека на директориите, като всеки елемент се извежда на нов\n"
"    ред и се предхожда от номера си в стека.  Опцията „-p“ също води до поредово\n"
"    отпечатване, но без поредния номер в стека.  Опцията „-c“ изчиства стека на\n"
"    директориите като изтрива всички елементи.\n"
"    \n"
"    +N  показва N-тия елемент отляво в списъка показван от\n"
"        командата „dirs“, когато е стартирана без опции.  Брои се от 0.\n"
"    \n"
"    -N  показва N-тия елемент отдясно в списъка показван от\n"
"        командата „dirs“, когато е стартирана без опции.  Брои се от 0."

#: builtins.c:1364
msgid ""
" Toggle the values of variables controlling optional behavior.\n"
"    The -s flag means to enable (set) each OPTNAME; the -u flag\n"
"    unsets each OPTNAME.  The -q flag suppresses output; the exit\n"
"    status indicates whether each OPTNAME is set or unset.  The -o\n"
"    option restricts the OPTNAMEs to those defined for use with\n"
"    `set -o'.  With no options, or with the -p option, a list of all\n"
"    settable options is displayed, with an indication of whether or\n"
"    not each is set."
msgstr ""
" Превключва стойностите на променливите, които управляват допълнителното\n"
"    поведение.  Опцията „-s“ позволява задаването на всяка ОПЦИЯ.  Опцията „-q“\n"
"    премахва всяка ОПЦИЯ.  Опцията „-q“ предотвратява извеждането на информация.\n"
"    Върнатият код показва дали всяка опция е зададена или премахната. Опцията\n"
"    „-o“ ограничава ОПЦИите до тези, които са дефинирани да се използват със\n"
"    „set -o“.  Без опции или с опцията „-p“ се извежда списъка на всички опции\n"
"    като се показва дали са зададени или не."

#: builtins.c:1377
msgid ""
" printf formats and prints ARGUMENTS under control of the FORMAT. FORMAT\n"
"    is a character string which contains three types of objects: plain\n"
"    characters, which are simply copied to standard output, character "
"escape\n"
"    sequences which are converted and copied to the standard output, and\n"
"    format specifications, each of which causes printing of the next "
"successive\n"
"    argument.  In addition to the standard printf(1) formats, %b means to\n"
"    expand backslash escape sequences in the corresponding argument, and %q\n"
"    means to quote the argument in a way that can be reused as shell input.\n"
"    If the -v option is supplied, the output is placed into the value of "
"the\n"
"    shell variable VAR rather than being sent to the standard output."
msgstr ""
" printf форматира и отпечатва АРГУМЕНТИте според управлението на ФОРМАТа.\n"
"    ФОРМАТът е последователност от знаци, която съдържа три вида обекти:\n"
"    обикновени знаци, които биват отпечатани директно на стандартния изход;\n"
"    екраниращи знакови последователности, които биват преобразувани и отпечатани\n"
"    на стандартния изход; и форматиращи знакови последователности, всяка от\n"
"    които предизвиква отпечатването на следващ аргумент.  Освен стандартните\n"
"    форматирания описани в ръководството на printf, „%b“ предизвиква заместването\n"
"    на екраниранията с обратно наклонени черти в съответния аргумент, а „%q“\n"
"    предизвиква цитирането на аргумента, така че да може да бъде използван като\n"
"    вход за обвивката. Ако е включена опцията „-v“, изходът се поставя в\n"
"    променливата на обвивката VAR, вместо да се извежда на стандартния изход."

#: builtins.c:1393
msgid ""
" For each NAME, specify how arguments are to be completed.\n"
"    If the -p option is supplied, or if no options are supplied, existing\n"
"    completion specifications are printed in a way that allows them to be\n"
"    reused as input.  The -r option removes a completion specification for\n"
"    each NAME, or, if no NAMEs are supplied, all completion specifications."
msgstr ""
" За всяко ИМЕ посочва как да се дописват аргументите.\n"
"    Ако е зададена опцията -p или не са зададени никакви опции, съществуващите\n"
"    класове дописвания се отпечатват по начин, който позволява да се използват\n"
"    повторно за вход.  Опцията -r премахва клас дописвания за всяко посочено\n"
"    ИМЕ, а ако не е дадено такова -  махат се всички класове."

#: builtins.c:1405
msgid ""
" Display the possible completions depending on the options.  Intended\n"
"    to be used from within a shell function generating possible "
"completions.\n"
"    If the optional WORD argument is supplied, matches against WORD are\n"
"    generated."
msgstr ""
" Показване на възможните дописвания на базата на възможностите.  Целта е да се\n"
"    ползва в рамките функция на обвивката, която генерира възможните дописвания.\n"
"    Ако е зададен незадължителният аргумент ДУМА, генерират се напасванията с\n"
"    него."
