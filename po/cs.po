# Czech tranlation for bash.
# Copyright (C) 2008 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Petr Pisar <petr.pisar@atlas.cz>, 2008.
#
msgid ""
msgstr ""
"Project-Id-Version: bash 3.2\n"
"POT-Creation-Date: 2006-10-23 17:20-0400\n"
"PO-Revision-Date: 2008-08-22 17:08+0200\n"
"Last-Translator: Petr Pisar <petr.pisar@atlas.cz>\n"
"Language-Team: Czech <translation-team-cs@lists.sourceforge.net>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: arrayfunc.c:48
msgid "bad array subscript"
msgstr "chybný podskript pole"

#: arrayfunc.c:362
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: přes nečíselný indexu nelze dosadit"

#: bashhist.c:331
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: nelze vytvořit: %s"

#: bashline.c:3030
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: pro příkaz nelze nalézt klávesovou mapu "

#: bashline.c:3079
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: první nebílý znak není „\"“"

#: bashline.c:3108
#, c-format
msgid "no closing `%c' in %s"
msgstr "ne zavírající „%c“ v %s"

#: bashline.c:3142
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: chybí dvojtečkový oddělovač"

#: builtins/bind.def:194
#, c-format
msgid "`%s': invalid keymap name"
msgstr "„%s“: chybný název klávesové mapy"

#: builtins/bind.def:233
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: nelze číst: %s"

#: builtins/bind.def:248
#, c-format
msgid "`%s': cannot unbind"
msgstr "„%s“: nelze zrušit vazbu"

#: builtins/bind.def:283
#, c-format
msgid "`%s': unknown function name"
msgstr "„%s“: neznámé jméno funkce"

#: builtins/bind.def:291
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s není svázán s žádnou klávesou.\n"

#: builtins/bind.def:295
#, c-format
msgid "%s can be invoked via "
msgstr "%s lze vyvolat přes "

#: builtins/break.def:128
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "má smysl jen ve smyčkách „for“, „while“ nebo „until“"

#: builtins/caller.def:131
msgid "Returns the context of the current subroutine call."
msgstr "Vrací kontext aktuálního volání podrutiny."

#: builtins/caller.def:132 builtins/caller.def:136 builtins/pushd.def:666
#: builtins/pushd.def:674 builtins/pushd.def:677 builtins/pushd.def:687
#: builtins/pushd.def:691 builtins/pushd.def:695 builtins/pushd.def:698
#: builtins/pushd.def:701 builtins/pushd.def:710 builtins/pushd.def:714
#: builtins/pushd.def:718 builtins/pushd.def:721
msgid " "
msgstr " "

#: builtins/caller.def:133
msgid "Without EXPR, returns returns \"$line $filename\".  With EXPR,"
msgstr "Bez VÝRAZU vrací „$line $filename“. S VÝRAZEM "

#: builtins/caller.def:134
msgid "returns \"$line $subroutine $filename\"; this extra information"
msgstr "vrací „$line $subroutine $filename“. Tyto údaje"

#: builtins/caller.def:135
msgid "can be used used to provide a stack trace."
msgstr "lze využít při výpisu zásobníku volání."

#: builtins/caller.def:137
msgid "The value of EXPR indicates how many call frames to go back before the"
msgstr "Hodnota VÝRAZ značí, kolik rámců volání se má jít zpět před"

#: builtins/caller.def:138
msgid "current one; the top frame is frame 0."
msgstr "současný rámec, vrcholový rámec má číslo 0."

#: builtins/cd.def:204
msgid "HOME not set"
msgstr "není nestavena HOME"

#: builtins/cd.def:216
msgid "OLDPWD not set"
msgstr "není nastaveno OLDPWD"

#: builtins/common.c:133 test.c:822
msgid "too many arguments"
msgstr "příliš mnoho argumentů"

#: builtins/common.c:157 shell.c:474 shell.c:748
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: přepínač vyžaduje argument"

#: builtins/common.c:164
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: vyžadován číselný argument"

#: builtins/common.c:171
#, c-format
msgid "%s: not found"
msgstr "%s: nenalezeno"

#: builtins/common.c:180 shell.c:761
#, c-format
msgid "%s: invalid option"
msgstr "%s: chybný přepínač"

#: builtins/common.c:187
#, c-format
msgid "%s: invalid option name"
msgstr "%s: chybný název přepínače"

#: builtins/common.c:194 general.c:230 general.c:235
#, c-format
msgid "`%s': not a valid identifier"
msgstr "„%s“: není platným identifikátorem"

#: builtins/common.c:201
#, c-format
msgid "%s: invalid number"
msgstr "%s: chybné číslo"

#: builtins/common.c:208
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: chybné určení signálu"

#: builtins/common.c:215
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "„%s“: není PID ani platným označením úlohy"

#: builtins/common.c:222 error.c:451
#, c-format
msgid "%s: readonly variable"
msgstr "%s: proměnná pouze pro čtení"

#: builtins/common.c:230
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s mimo rozsah"

#: builtins/common.c:230 builtins/common.c:232
msgid "argument"
msgstr "argument"

#: builtins/common.c:232
#, c-format
msgid "%s out of range"
msgstr "%s mimo rozsah"

#: builtins/common.c:240
#, c-format
msgid "%s: no such job"
msgstr "%s: žádná taková úloha"

#: builtins/common.c:248
#, c-format
msgid "%s: no job control"
msgstr "%s: žádné řízení úloh"

#: builtins/common.c:250
msgid "no job control"
msgstr "žádné řízení úloh"

#: builtins/common.c:260
#, c-format
msgid "%s: restricted"
msgstr "%s: omezeno"

#: builtins/common.c:262
msgid "restricted"
msgstr "omezeno"

#: builtins/common.c:270
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: není vestavěným příkazem shellu"

#: builtins/common.c:276
#, c-format
msgid "write error: %s"
msgstr "chyba zápisu: %s"

#: builtins/common.c:481
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: chyba při zjišťování současného adresáře: %s: %s\n"

#: builtins/common.c:547 builtins/common.c:549
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: nejednoznačné určení úlohy"

#: builtins/complete.def:251
#, c-format
msgid "%s: invalid action name"
msgstr "%s: neplatný název akce"

#: builtins/complete.def:381 builtins/complete.def:524
#, c-format
msgid "%s: no completion specification"
msgstr "%s: žádné doplňování neurčeno"

#: builtins/complete.def:571
msgid "warning: -F option may not work as you expect"
msgstr "varování: přepínač -F možná nebude dělat, co jste čekali"

#: builtins/complete.def:573
msgid "warning: -C option may not work as you expect"
msgstr "varování: přepínač -C možná nebude dělat, co jste čekali"

#: builtins/declare.def:106
msgid "can only be used in a function"
msgstr "může být použito jen ve funkci"

#: builtins/declare.def:306
msgid "cannot use `-f' to make functions"
msgstr "„-f“ nezle použít na výrobu funkce"

#: builtins/declare.def:318 execute_cmd.c:4073
#, c-format
msgid "%s: readonly function"
msgstr "%s: funkce jen pro čtení"

#: builtins/declare.def:406
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: takto nelze likvidovat pole"

#: builtins/enable.def:128 builtins/enable.def:136
msgid "dynamic loading not available"
msgstr "dynamické nahrávání není dostupné"

#: builtins/enable.def:303
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "sdílený objekt %s nelze otevřít: %s"

#: builtins/enable.def:326
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "ve sdílením objektu %2$s nelze nalézt %1$s: %3$s"

#: builtins/enable.def:450
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: není dynamicky nahráno"

#: builtins/enable.def:465
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: nelze smazat: %s"

#: builtins/evalfile.c:129 execute_cmd.c:3930 shell.c:1409
#, c-format
msgid "%s: is a directory"
msgstr "%s: je adresářem"

#: builtins/evalfile.c:134
#, c-format
msgid "%s: not a regular file"
msgstr "%s: není obyčejný soubor"

#: builtins/evalfile.c:142
#, c-format
msgid "%s: file is too large"
msgstr "%s: soubor je příliš velký"

#: builtins/exec.def:205
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: nelze provést: %s"

#: builtins/exit.def:83
msgid "not login shell: use `exit'"
msgstr "toto není login shell: použijte „exit“"

#: builtins/exit.def:111
msgid "There are stopped jobs.\n"
msgstr "Jsou zde pozastavení úlohy.\n"

#: builtins/fc.def:258
msgid "no command found"
msgstr "žádný příkaz nenalezen"

#: builtins/fc.def:328
msgid "history specification"
msgstr "určení historie"

#: builtins/fc.def:349
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: dočasný soubor nelze otevřít: %s"

#: builtins/fg_bg.def:149
#, c-format
msgid "job %d started without job control"
msgstr "úloha %d spuštěna bez správy úloh"

#: builtins/getopt.c:109
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: chybný přepínač – %c\n"

#: builtins/getopt.c:110
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: přepínač vyžaduje argument – %c\n"

#: builtins/hash.def:84
msgid "hashing disabled"
msgstr "hashování zakázáno"

#: builtins/hash.def:130
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: tabulka hashů je prázdná\n"

#: builtins/help.def:108
msgid "Shell commands matching keywords `"
msgstr "Příkazy shellu shodující se s klíčovými slovy „"

#: builtins/help.def:110
msgid "Shell commands matching keyword `"
msgstr "Příkazy shellu shodující ce s klíčovým slovem „"

#: builtins/help.def:138
#, c-format
msgid "no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr "žádné téma nápovědy se nehodí pro „%s“. Zkuste „help help“ nebo „man -k %s“ nebo „info %s“."

#: builtins/help.def:164
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: nelze otevřít: %s"

#: builtins/help.def:182
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Tyto příkazy shellu jsou vnitřně definovány. Napište „help“, aby ste získali\n"
"tento seznam. Podrobnosti o funkci „název“ získáte příkazem „help název“.\n"
"Příkazem „info bash“ získáte obecné informace o tomto shellu.\n"
"Použijte „man -k“ nebo „info“, chcete-li zjistit více o příkazech, které\n"
"na tomto seznamu nejsou.\n"
"\n"
"Hvězdička (*) vedle jména znamená, že příkaz je zakázán.\n"
"\n"

#: builtins/history.def:150
msgid "cannot use more than one of -anrw"
msgstr "nelze použít více jak jeden z -anrw"

#: builtins/history.def:182
msgid "history position"
msgstr "místo v historii"

#: builtins/history.def:400
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: expanze historie selhala"

#: builtins/jobs.def:99
msgid "no other options allowed with `-x'"
msgstr "s „-x“ nejsou dovoleny další přepínače"

#: builtins/kill.def:187
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: argumenty musí být proces nebo identifikátor úlohy"

#: builtins/kill.def:250
msgid "Unknown error"
msgstr "Neznámá chyba"

#: builtins/let.def:94 builtins/let.def:119 expr.c:498 expr.c:513
msgid "expression expected"
msgstr "očekáván výraz"

#: builtins/printf.def:339
#, c-format
msgid "`%s': missing format character"
msgstr "„%s“: postrádám formátovací znak"

#: builtins/printf.def:516
#, c-format
msgid "`%c': invalid format character"
msgstr "„%c“: neplatný formátovací znak"

#: builtins/printf.def:722
msgid "missing hex digit for \\x"
msgstr "u \\x chybí šestnáctková číslovka"

#: builtins/pushd.def:175
msgid "no other directory"
msgstr "žádný další adresář"

#: builtins/pushd.def:442
msgid "<no current directory>"
msgstr "<žádný aktuální adresář>"

#: builtins/pushd.def:663
msgid "Display the list of currently remembered directories.  Directories"
msgstr "Zobrazí seznam právě zapamatovaných adresářů. Adresáře"

#: builtins/pushd.def:664
msgid "find their way onto the list with the `pushd' command; you can get"
msgstr "se na seznam umisťují příkazem „pushd“, předchozí stav seznamu lze"

#: builtins/pushd.def:665
msgid "back up through the list with the `popd' command."
msgstr "vrátit příkazem „popd“."

#: builtins/pushd.def:667
msgid "The -l flag specifies that `dirs' should not print shorthand versions"
msgstr "Příznak -l značí, že „dirs“ nemá vypisovat zkrácené verze adresářů,"

#: builtins/pushd.def:668
msgid "of directories which are relative to your home directory.  This means"
msgstr "které leží pod vaším domovským adresářem. To znamená, že „~/bin“"

#: builtins/pushd.def:669
msgid "that `~/bin' might be displayed as `/homes/bfox/bin'.  The -v flag"
msgstr "smí být zobrazen jako „/homes/bfox/bin“. Příznak -v způsobí, že"

#: builtins/pushd.def:670
msgid "causes `dirs' to print the directory stack with one entry per line,"
msgstr "„dirs“ vypíše zásobník adresářů záznam po záznamu na samostatné řádky"

#: builtins/pushd.def:671
msgid "prepending the directory name with its position in the stack.  The -p"
msgstr "a před název adresáře uvede jeho pořadí v zásobníku. Příznak -p"

#: builtins/pushd.def:672
msgid "flag does the same thing, but the stack position is not prepended."
msgstr "dělá to samé, ale bez informace o umístění na zásobníku."

#: builtins/pushd.def:673
msgid "The -c flag clears the directory stack by deleting all of the elements."
msgstr "Příznak -c vyprázdní zásobník smazáním všem prvků."

#: builtins/pushd.def:675
msgid "+N   displays the Nth entry counting from the left of the list shown by"
msgstr "+N   zobrazí N. položku počítáno zleva na seznamu, který by ukázal"

#: builtins/pushd.def:676 builtins/pushd.def:679
msgid "     dirs when invoked without options, starting with zero."
msgstr "     příkaz dirs bez jakýchkoliv přepínačů, počítáno od nuly."

#: builtins/pushd.def:678
msgid "-N   displays the Nth entry counting from the right of the list shown by"
msgstr "-N   zobrazí N. položku počítáno zprava na seznamu, který by ukázal"

#: builtins/pushd.def:684
msgid "Adds a directory to the top of the directory stack, or rotates"
msgstr "Přidá adresář na vrchol zásobníku adresářů, nebo rotuje zásobník tak,"

#: builtins/pushd.def:685
msgid "the stack, making the new top of the stack the current working"
msgstr "že nový vrchol zásobníku se stane pracovním adresářem."

#: builtins/pushd.def:686
msgid "directory.  With no arguments, exchanges the top two directories."
msgstr "Bez argumentů prohodí horní dva adresáře."

#: builtins/pushd.def:688
msgid "+N   Rotates the stack so that the Nth directory (counting"
msgstr "+N   Zrotuje zásobník tak, že N. adresář (počítáno"

#: builtins/pushd.def:689
msgid "     from the left of the list shown by `dirs', starting with"
msgstr "     zleva seznamu, který by ukázal „dirs“, počínaje od"

#: builtins/pushd.def:690 builtins/pushd.def:694
msgid "     zero) is at the top."
msgstr "     nuly) se dostane na vrchol."

#: builtins/pushd.def:692
msgid "-N   Rotates the stack so that the Nth directory (counting"
msgstr "-N   Zrotuje zásobník tak, že N. adresář (počítáno"

#: builtins/pushd.def:693
msgid "     from the right of the list shown by `dirs', starting with"
msgstr "     zprava seznamu, který by ukázal „dirs“, počínaje od"

#: builtins/pushd.def:696
msgid "-n   suppress the normal change of directory when adding directories"
msgstr "-n   potlačí obvyklou změnu pracovního adresáře při přidávání adresářů"

#: builtins/pushd.def:697
msgid "     to the stack, so only the stack is manipulated."
msgstr "     na zásobník, takže se změní jen obsah zásobníku."

#: builtins/pushd.def:699
msgid "dir  adds DIR to the directory stack at the top, making it the"
msgstr "adr  přidá ADR na vrchol zásobníku adresářů a učiní jej"

#: builtins/pushd.def:700
msgid "     new current working directory."
msgstr "     novým pracovním adresářem."

#: builtins/pushd.def:702 builtins/pushd.def:722
msgid "You can see the directory stack with the `dirs' command."
msgstr "Zásobník adresářů si lze prohlédnout příkazem „dirs“."

#: builtins/pushd.def:707
msgid "Removes entries from the directory stack.  With no arguments,"
msgstr "Odstraní položky ze zásobníku adresářů. Bez argumentů"

#: builtins/pushd.def:708
msgid "removes the top directory from the stack, and cd's to the new"
msgstr "odstraní adresář z vrcholu zásobníku a přepne se do nového"

#: builtins/pushd.def:709
msgid "top directory."
msgstr "vrcholového adresáře."

#: builtins/pushd.def:711
msgid "+N   removes the Nth entry counting from the left of the list"
msgstr "+N   odstraní N. položku počítáno zleva na seznamu,"

#: builtins/pushd.def:712
msgid "     shown by `dirs', starting with zero.  For example: `popd +0'"
msgstr "     který by ukázal „dirs“, počínaje nulou. Například „popd +0“"

#: builtins/pushd.def:713
msgid "     removes the first directory, `popd +1' the second."
msgstr "     odstraní první adresář, „popd +1“ druhý."

#: builtins/pushd.def:715
msgid "-N   removes the Nth entry counting from the right of the list"
msgstr "-N   odstraní N. položku počítáno zprava na seznamu,"

#: builtins/pushd.def:716
msgid "     shown by `dirs', starting with zero.  For example: `popd -0'"
msgstr "     který by ukázal „dirs“, počínaje nulou. Například: „popd -0“"

#: builtins/pushd.def:717
msgid "     removes the last directory, `popd -1' the next to last."
msgstr "     odstraní poslední adresář, “popd -1“ předposlední."

#: builtins/pushd.def:719
msgid "-n   suppress the normal change of directory when removing directories"
msgstr "-n   potlačí obvyklou změnu pracovního adresáře při odebírání adresářů"

#: builtins/pushd.def:720
msgid "     from the stack, so only the stack is manipulated."
msgstr "     ze zásobníku, takže pouze zásobník dozná změny."

#: builtins/read.def:210
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: chybné určení časového limitu"

#: builtins/read.def:233
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: chybné určení deskriptoru souboru"

#: builtins/read.def:240
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: neplatný deskriptor souboru: %s"

#: builtins/read.def:478
#, c-format
msgid "read error: %d: %s"
msgstr "chyba čtení: %d: %s"

#: builtins/return.def:63
msgid "can only `return' from a function or sourced script"
msgstr "„return“ lze provést jen z funkce nebo skriptu načteného přes „source“"

#: builtins/set.def:744
msgid "cannot simultaneously unset a function and a variable"
msgstr "funkci i proměnnou nelze rušit současně"

#: builtins/set.def:781
#, c-format
msgid "%s: cannot unset"
msgstr "%s: nelze zrušit"

#: builtins/set.def:788
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: nelze zrušit: %s jen pro čtení"

#: builtins/set.def:799
#, c-format
msgid "%s: not an array variable"
msgstr "%s: není (proměnnou typu) pole"

#: builtins/setattr.def:166
#, c-format
msgid "%s: not a function"
msgstr "%s: není funkcí"

#: builtins/shift.def:66 builtins/shift.def:72
msgid "shift count"
msgstr "počet shiftů"

#: builtins/shopt.def:227
msgid "cannot set and unset shell options simultaneously"
msgstr "přepínač shellu nelze zároveň nastavit a zrušit"

#: builtins/shopt.def:292
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: chybný název přepínače shellu"

#: builtins/source.def:115
msgid "filename argument required"
msgstr "vyžadován argument s názvem souboru"

#: builtins/source.def:135
#, c-format
msgid "%s: file not found"
msgstr "%s: soubor nenalezen"

#: builtins/suspend.def:95
msgid "cannot suspend"
msgstr "nelze pozastavit"

#: builtins/suspend.def:105
msgid "cannot suspend a login shell"
msgstr "login shell nelze pozastavit"

#: builtins/type.def:232
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s je alias na „%s“\n"

#: builtins/type.def:253
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s je klíčové slovo shellu\n"

#: builtins/type.def:273
#, c-format
msgid "%s is a function\n"
msgstr "%s je funkce\n"

#: builtins/type.def:298
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s je součást shellu\n"

#: builtins/type.def:319
#, c-format
msgid "%s is %s\n"
msgstr "%s je %s\n"

#: builtins/type.def:339
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s je zahashován (%s)\n"

#: builtins/ulimit.def:352
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: chybný argument s limitou"

#: builtins/ulimit.def:378
#, c-format
msgid "`%c': bad command"
msgstr "„%c“: chybný příkaz"

#: builtins/ulimit.def:407
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: limit nelze zjistit: %s"

#: builtins/ulimit.def:445
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: limit nelze změnit: %s"

#: builtins/umask.def:112
msgid "octal number"
msgstr "osmičkové číslo"

#: builtins/umask.def:226
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "„%c“: chybný operátor symbolických práv"

#: builtins/umask.def:281
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "„%c“: chybný znak symbolický práv "

#: error.c:163
#, c-format
msgid "last command: %s\n"
msgstr "poslední příkaz: %s\n"

#: error.c:171
msgid "Aborting..."
msgstr "Ukončuji…"

#: error.c:258
#, c-format
msgid "%s: warning: "
msgstr "%s: varování: "

#: error.c:403
msgid "unknown command error"
msgstr "chyba neznámého příkazu"

#: error.c:404
msgid "bad command type"
msgstr "chybný druh příkazu"

#: error.c:405
msgid "bad connector"
msgstr "chybný konektor"

#: error.c:406
msgid "bad jump"
msgstr "chybný skok"

#: error.c:444
#, c-format
msgid "%s: unbound variable"
msgstr "%s: nevázaná proměnná"

#: eval.c:176
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\ačasový limit pro čekání na vstup vypršel: automatické odhlášení\n"

#: execute_cmd.c:474
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "standardní vstup nelze přesměrovat z /dev/null: %s"

#: execute_cmd.c:1058
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: „%c“: chybný formátovací znak"

#: execute_cmd.c:3629
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: omezeno: v názvu příkazu nesmí být „/“"

#: execute_cmd.c:3717
#, c-format
msgid "%s: command not found"
msgstr "%s: příkaz nenalezen"

#: execute_cmd.c:3963
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: chybný interpretr"

#: execute_cmd.c:4000
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: binární soubor nelze spustit"

#: execute_cmd.c:4112
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "deskriptor souboru %d nelze duplikovat na deskriptor %d"

#: expr.c:241
msgid "expression recursion level exceeded"
msgstr "úroveň rekurze výrazu byla překročena"

#: expr.c:265
msgid "recursion stack underflow"
msgstr "zásobník rekurze podtekl"

#: expr.c:376
msgid "syntax error in expression"
msgstr "syntaktická chyba ve výrazu"

#: expr.c:416
msgid "attempted assignment to non-variable"
msgstr "pokus o přiřazení do ne-proměnné"

#: expr.c:437 expr.c:442 expr.c:752
msgid "division by 0"
msgstr "dělení nulou"

#: expr.c:468
msgid "bug: bad expassign token"
msgstr "chyba: chybný expassing token"

#: expr.c:510
msgid "`:' expected for conditional expression"
msgstr "v podmíněném výrazu očekávána „:“"

#: expr.c:777
msgid "exponent less than 0"
msgstr "mocnitel menší než 0"

#: expr.c:822
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "po přednostním zvýšení nebo snížení očekáván identifikátor"

#: expr.c:850
msgid "missing `)'"
msgstr "postrádám „)“"

#: expr.c:893 expr.c:1171
msgid "syntax error: operand expected"
msgstr "syntaktická chyba: očekáván operand"

#: expr.c:1173
msgid "syntax error: invalid arithmetic operator"
msgstr "syntaktická chyba: chybný aritmetický operátor"

#: expr.c:1251
msgid "invalid number"
msgstr "chybné číslo"

#: expr.c:1255
msgid "invalid arithmetic base"
msgstr "chybný aritmetický základ"

#: expr.c:1275
msgid "value too great for base"
msgstr "hodnot je pro základ příliš velká"

#: general.c:61
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: rodičovské adresáře nejsou přístupné"

#: input.c:237
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "nový deskriptor souboru pro vstup bashe z deskr. %d nelze alokovat"

#: input.c:245
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: buffer již pro nový deskriptor %d existuje"

#: jobs.c:876
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "forknutý PID %d se objevil v běžící úloze %d"

#: jobs.c:983
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "mažu pozastavenou úlohu %d se skupinou procesů %ld"

#: jobs.c:1378
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: žádný takový PID"

#: jobs.c:2061 nojobs.c:575
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: PID %ld není potomkem tohoto shellu"

#: jobs.c:2265
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: Žádný záznam o procesu %ld"

#: jobs.c:2524
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: úloha %d je pozastavena"

#: jobs.c:2746
#, c-format
msgid "%s: job has terminated"
msgstr "%s: úloha skončila"

#: jobs.c:2755
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: úloha %d je již na pozadí"

#: jobs.c:3546
msgid "no job control in this shell"
msgstr "žádná správa úloh v tomto shellu"

#: lib/malloc/malloc.c:298
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: předpoklad nesplněn: %s\n"

#: lib/malloc/malloc.c:314
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: zbabraný předpoklad\r\n"

#: lib/malloc/malloc.c:799
msgid "malloc: block on free list clobbered"
msgstr "malloc: blok v seznamu uvolněných zbit"

#: lib/malloc/malloc.c:876
msgid "free: called with already freed block argument"
msgstr "free: zavoláno s argumentem již uvolněného bloku"

#: lib/malloc/malloc.c:879
msgid "free: called with unallocated block argument"
msgstr "free: zavoláno s argumentem nenaalokovaného bloku"

#: lib/malloc/malloc.c:898
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: zjištěno podtečení, mh_nbytes mimo rozsah"

#: lib/malloc/malloc.c:904
msgid "free: start and end chunk sizes differ"
msgstr "free: velikosti počátečního a koncového kusu se liší"

#: lib/malloc/malloc.c:1003
msgid "realloc: called with unallocated block argument"
msgstr "realloc: zavoláno s argumentem nenaalokovaného bloku"

#: lib/malloc/malloc.c:1018
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: zjištěno podtečení, mh_nbytes mimo rozsah"

#: lib/malloc/malloc.c:1024
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: velikosti počátečního a koncového kusu se liší"

#: lib/malloc/table.c:176
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: tabulka alokací je plná FIND_ALLOC?\n"

#: lib/malloc/table.c:183
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p již obsažen v tabulce jako alokovaný?\n"

#: lib/malloc/table.c:219
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p již obsažen v tabulce jako volný?\n"

#: lib/malloc/watch.c:46
msgid "allocated"
msgstr "alokováno"

#: lib/malloc/watch.c:48
msgid "freed"
msgstr "uvolněno"

#: lib/malloc/watch.c:50
msgid "requesting resize"
msgstr "požadující velikost"

#: lib/malloc/watch.c:52
msgid "just resized"
msgstr "právě změněna velikost"

#: lib/malloc/watch.c:54
msgid "bug: unknown operation"
msgstr "chyba: neznámá operace"

#: lib/malloc/watch.c:56
#, c-format
msgid "malloc: watch alert: %p %s "
msgstr "malloc: výstraha sledování: %p %s"

#: lib/sh/fmtulong.c:101
msgid "invalid base"
msgstr "chybný základ"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: stroj není znám"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: chybná služba"

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: chybné určení síťové cesty"

#: lib/sh/netopen.c:346
msgid "network operations not supported"
msgstr "síťové operace nejsou podporovány"

#: mailcheck.c:386
msgid "You have mail in $_"
msgstr "V $_ máte poštu"

#: mailcheck.c:411
msgid "You have new mail in $_"
msgstr "V $_ máte novou poštu"

#: mailcheck.c:427
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Pošta v %s je přečtená\n"

#: make_cmd.c:322
msgid "syntax error: arithmetic expression required"
msgstr "chyba syntaxe: vyžadován aritmetický výraz"

#: make_cmd.c:324
msgid "syntax error: `;' unexpected"
msgstr "chyba syntaxe: neočekávaný „;“"

#: make_cmd.c:325
#, c-format
msgid "syntax error: `((%s))'"
msgstr "chyba syntaxe: „((%s))“"

#: make_cmd.c:566
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: chybný druh instrukce %d"

#: make_cmd.c:741
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: instrukce přesměrování „%d“ mimo rozsah"

#: parse.y:2759
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "neočekávaný konec souboru při hledání znaku odpovídajícímu „%c“"

#: parse.y:3071
msgid "unexpected EOF while looking for `]]'"
msgstr "neočekávaný konec souboru při hledání „]]“"

# XXX: Condional means condition (adj.) probably. Can English distinguish
# between the condition (podmínkový) and the code branch (podmíněný)? Check
# for all "conditional" string occurences.
#: parse.y:3076
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "chyba syntaxe ve výrazu podmínky: neočekávaný token „%s“"

#: parse.y:3080
msgid "syntax error in conditional expression"
msgstr "chyba syntaxe ve výrazu podmínky"

#: parse.y:3158
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "neočekávaný token „%s“, očekávána „)“"

#: parse.y:3162
msgid "expected `)'"
msgstr "očekávána „)“"

#: parse.y:3190
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "neočekávaný argument „%s“ u podmínkového unárního operátoru"

#: parse.y:3194
msgid "unexpected argument to conditional unary operator"
msgstr "neočekávaný argument u podmínkového unárního operátoru"

#: parse.y:3234
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "neočekávaný token „%s“, očekáván podmínkový binární operátor"

#: parse.y:3238
msgid "conditional binary operator expected"
msgstr "očekáván podmínkový binární operátor"

#: parse.y:3255
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "neočekávaný argument „%s„ u podmínkového binárního operátoru"

#: parse.y:3259
msgid "unexpected argument to conditional binary operator"
msgstr "neočekávaný argument u podmínkového binárního operátoru"

#: parse.y:3270
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "neočekávaný token „%c“ v podmínkovém příkazu"

#: parse.y:3273
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "neočekávaný token „%s“ v podmínkovém příkazu"

#: parse.y:3277
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "neočekávaný token %d v podmínkovém příkazu"

#: parse.y:4523
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "chyba syntaxe poblíž neočekávaného tokenu „%s“"

#: parse.y:4541
#, c-format
msgid "syntax error near `%s'"
msgstr "chyba syntaxe poblíž „%s“"

#: parse.y:4551
msgid "syntax error: unexpected end of file"
msgstr "chyba syntaxe: nenadálý konec souboru"

#: parse.y:4551
msgid "syntax error"
msgstr "chyba syntaxe"

#: parse.y:4613
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Shell lze ukončit příkazem „%s“.\n"

#: parse.y:4775
msgid "unexpected EOF while looking for matching `)'"
msgstr "nenadálý konec souboru při hledání odpovídající „)“"

#: pcomplete.c:1002
#, c-format
msgid "completion: function `%s' not found"
msgstr "doplňování: funkce „%s“ nenalezena"

#: pcomplib.c:179
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: NULLOVÝ COMPSPEC"

#: print_cmd.c:264
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: chybná propojka „%d“"

#: print_cmd.c:1236
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: „%c“: chybný formátovací znak"

#: redir.c:99
msgid "file descriptor out of range"
msgstr "deskriptor souboru mimo rozsah"

#: redir.c:141
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: nejednoznačné přesměrování"

#: redir.c:145
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: existující soubor nelze přepsat"

#: redir.c:150
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: omezeno: výstup nelze přesměrovat"

#: redir.c:155
#, c-format
msgid "cannot create temp file for here document: %s"
msgstr "pro „here“ dokument nelze vytvořit dočasný soubor: %s"

#: redir.c:509
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "/dev/(tcp|udp)/host/port není bez síťování podporováno"

#: redir.c:965
msgid "redirection error: cannot duplicate fd"
msgstr "chyba přesměrování: deskriptor souboru nelze duplikovat"

#: shell.c:309
msgid "could not find /tmp, please create!"
msgstr "nelze nalézt /tmp, vytvořte jej, prosím!"

#: shell.c:313
msgid "/tmp must be a valid directory name"
msgstr "/tmp musí být platným názvem pro adresář"

#: shell.c:850
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: chybný přepínač"

#: shell.c:1600
msgid "I have no name!"
msgstr "Nemám žádné jméno!"

#: shell.c:1735
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Použití:\t%s [Dlouhý GNU přepínač] [přepínač]…\n"
"\t%s [Dlouhý GNU přepínač] [přepínač] skriptový_soubor…\n"

#: shell.c:1737
msgid "GNU long options:\n"
msgstr "Dlouhé GNU přepínače:\n"

#: shell.c:1741
msgid "Shell options:\n"
msgstr "Přepínače shellu:\n"

#: shell.c:1742
msgid "\t-irsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-irsD nebo -c příkaz nebo -O shopt_přepínač\t(pouze při vyvolání)\n"

#: shell.c:1757
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s nebo -o přepínač\n"

#: shell.c:1763
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "Podrobnosti o přepínačích shellu získáte tím, že napíšete „%s -c \"help set\"“.\n"

#: shell.c:1764
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr ""
"Podrobnosti o příkazech vestavěných do shellu získáte tím, že\n"
"napište „%s -c help“.\n"

#: shell.c:1765
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Chyby nahlásíte příkazem „bashbug“.\n"

#: sig.c:557
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: neplatná operace"

#: subst.c:1160
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "chybná substituce: v %2$s chybí uzavírací „%1$s“"

#: subst.c:2328
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: seznam nelze přiřadit do prvku pole"

#: subst.c:4265 subst.c:4281
msgid "cannot make pipe for process substitution"
msgstr "nelze vyrobit rouru za účelem substituce procesu"

#: subst.c:4312
msgid "cannot make child for process substitution"
msgstr "nelze vytvořit potomka za účelem substituce procesu"

#: subst.c:4357
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "pojmenovanou rouru %s nelze otevřít pro čtení"

#: subst.c:4359
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "pojmenovanou rouru %s nelze otevřít pro zápis"

#: subst.c:4367
#, c-format
msgid "cannout reset nodelay mode for fd %d"
msgstr "na deskriptoru %d nelze resetovat režim nodelay"

#: subst.c:4377
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "pojmenovanou rouru %s nelze zdvojit jako deskriptor %d"

#: subst.c:4552
msgid "cannot make pipe for command substitution"
msgstr "nelze vytvořit rouru pro substituci příkazu"

#: subst.c:4588
msgid "cannot make child for command substitution"
msgstr "nelze vytvořit potomka pro substituci příkazu"

#: subst.c:4605
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: rouru nelze zdvojit jako deskriptor 1"

#: subst.c:5068
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: parametr null nebo nenastaven"

#: subst.c:5342
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: výraz podřetězce < 0"

#: subst.c:6179
#, c-format
msgid "%s: bad substitution"
msgstr "%s: chybná substituce"

#: subst.c:6255
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: takto nelze přiřazovat"

#: subst.c:7826
#, c-format
msgid "no match: %s"
msgstr "žádná shoda: %s"

#: test.c:145
msgid "argument expected"
msgstr "očekáván argument"

#: test.c:154
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: očekáván celočíselný výraz"

#: test.c:262
msgid "`)' expected"
msgstr "očekávána „)“"

#: test.c:264
#, c-format
msgid "`)' expected, found %s"
msgstr "očekávána „)“, nalezeno %s"

#: test.c:279 test.c:688 test.c:691
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: očekáván unární operátor"

#: test.c:444 test.c:731
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: očekáván binární operátor"

#: test.c:806
msgid "missing `]'"
msgstr "postrádám „]“"

#: trap.c:200
msgid "invalid signal number"
msgstr "neplatné číslo signálu"

#: trap.c:315
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: chybná hodnota v trap_list[%d]: %p"

#: trap.c:319
#, c-format
msgid "run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr "run_pending_traps: obsluha signálu je SIG_DFL, přeposílám %d (%s) sobě"

#: trap.c:355
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: chybný signál %d"

#: variables.c:334
#, c-format
msgid "error importing function definition for `%s'"
msgstr "chyba při importu definice „%s“"

#: variables.c:711
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "úroveň shellu (%d) příliš vysoká, resetuji na 1"

#: variables.c:1670
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: žádný kontext funkce v aktuálním rozsahu"

#: variables.c:2813
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: žádný kontext funkce v aktuálním rozsahu"

#: variables.c:3030 variables.c:3039
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "neplatný znak %d v exportstr pro %s"

#: variables.c:3045
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "v exportstr pro %s chybí „=“"

#: variables.c:3472
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: hlava shell_variables není kontextem funkce"

#: variables.c:3485
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: chybí kontext global_variables"

#: variables.c:3557
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: hlava shell_variables není dočasným rozsahem prostředí"

#: version.c:82
msgid "Copyright (C) 2006 Free Software Foundation, Inc.\n"
msgstr "Copyright © 2006 Free Software Foundation, Inc.\n"

#: xmalloc.c:93
#, c-format
msgid "xmalloc: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "xmalloc: nelze alokovat %'lu bajtů (%'lu bajtů alokováno)"

#: xmalloc.c:95
#, c-format
msgid "xmalloc: cannot allocate %lu bytes"
msgstr "xmalloc: nezle alokovat %'lu bajtů"

#: xmalloc.c:115
#, c-format
msgid "xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)"
msgstr "xrealloc: nelze přealokovat %'lu bajtů (%'lu bajtů alokováno)"

#: xmalloc.c:117
#, c-format
msgid "xrealloc: cannot allocate %lu bytes"
msgstr "xrealloc: nelze alokovat %'lu bajtů"

#: xmalloc.c:151
#, c-format
msgid "xmalloc: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "xmalloc: %s:%d: nelze alokovat %'lu bajtů (%'lu bajtů alokováno)"

#: xmalloc.c:153
#, c-format
msgid "xmalloc: %s:%d: cannot allocate %lu bytes"
msgstr "xmalloc: %s:%d: nelze alokovat %'lu bajtů"

#: xmalloc.c:175
#, c-format
msgid "xrealloc: %s:%d: cannot reallocate %lu bytes (%lu bytes allocated)"
msgstr "xrealloc: %s:%d: nelze přealokovat %'lu bajtů (%'lu bajtů alokováno)"

#: xmalloc.c:177
#, c-format
msgid "xrealloc: %s:%d: cannot allocate %lu bytes"
msgstr "xrealloc: %s:%d: nelze alokovat %'lu bajtů"

#: builtins.c:244
msgid ""
"`alias' with no arguments or with the -p option prints the list\n"
"    of aliases in the form alias NAME=VALUE on standard output.\n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.  Alias returns\n"
"    true unless a NAME is given for which no alias has been defined."
msgstr ""
"„alias“ bez argumentů nebo s přepínačem -p vypíše na standardní výstup\n"
"    seznam aliasů ve formátu NÁZEV=HODNOTA. Jinak bude definován alias pro\n"
"    všechny NÁZVY, které mají zadanou HODNOTU. Závěrečná mezera v HODNOTĚ\n"
"    způsobí, že při expanzi bude následující slovo zkontrolováno na substituci\n"
"    aliasů. Alias vrátí pravdu, pokud nebyl zadán NÁZEV, pro který není\n"
"    žádný alias definován."

#: builtins.c:257
msgid ""
"Remove NAMEs from the list of defined aliases.  If the -a option is given,\n"
"    then remove all alias definitions."
msgstr ""
"Odstraní NÁZEV ze seznamů definovaných aliasů. Je-li zadán přepínač -a,\n"
"    odstraní všechny definice aliasů."

#: builtins.c:266
msgid ""
"Bind a key sequence to a Readline function or a macro, or set\n"
"    a Readline variable.  The non-option argument syntax is equivalent\n"
"    to that found in ~/.inputrc, but must be passed as a single argument:\n"
"    bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    bind accepts the following options:\n"
"      -m  keymap         Use `keymap' as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named function.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -S                 List key sequences that invoke macros and their values\n"
"      -s                 List key sequences that invoke macros and their values\n"
"                         in a form that can be reused as input."
msgstr ""
"Naváže posloupnost kláves na Readline funkci nebo makro nebo nastaví\n"
"    Readline proměnnou. Syntaxe nepřepínačových argumentů je shodná se\n"
"    syntaxí ~/.inputrc, ale musí být zadána jako jediný argument:\n"
"    bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    bind přijímá následujíc přepínače:\n"
"      -m  klávmapa       Použije „klávmapu“ jako klávesovou mapu pro trvání\n"
"                         tohoto příkazu. Možné klávesové mapy jsou emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,\n"
"                         vi-command a vi-insert.\n"
"      -l                 Vypíše seznam názvů funkcí.\n"
"      -P                 Vypíše seznam názvů funkcí klávesových vazeb.\n"
"      -p                 Vypíše seznam funkcí a klávesových vazeb ve formátu,\n"
"                         který lze použít jako vstup.\n"
"      -r  klávposl       Odstraní vazbu na KLÁVPOSL.\n"
"      -x  klávposl:příkaz-shellu\n"
"                         Způsobí, že bude vykonán PŘÍKAZ-SHELLU, když bude\n"
"                         zadána KLÁVPOSL.\n"
"      -f  soubor         Načte vazby kláves ze SOUBORU.\n"
"      -q  název-funkce   Dotáže se, které klávesy vyvolají zadanou funkci.\n"
"      -u  název-funkce   Zruší všechny vazby na klávesy, které jsou napojeny\n"
"                         na zadanou funkci.\n"
"      -V                 Vypíše seznam názvů proměnných a hodnot.\n"
"      -v                 Vypíše seznam názvů funkcí a hodnot ve formát,\n"
"                         který lze použít jako vstup.\n"
"      -S                 Vypíše seznam posloupností kláves,\n"
"                         které vyvolávají makra, a jejich hodnoty.\n"
"      -s                 Vypíše seznam posloupností kláves,\n"
"                         která vyvolávají makra, a jejich hodnoty ve formátu,\n"
"                         který lze použít jako vstup."

#: builtins.c:297
msgid ""
"Exit from within a FOR, WHILE or UNTIL loop.  If N is specified,\n"
"    break N levels."
msgstr "Ukončí smyčku FOR, WHILE nebo UNTIL. Je-li zadáno N, ukončí N úrovní."

#: builtins.c:304
msgid ""
"Resume the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resume at the N-th enclosing loop."
msgstr ""
"Přejde k další iteraci obklopující smyčky FOR, WHILE nebo UNTIL.\n"
"    Je-li zadáno N, bude tak učiněno v N. obklopující smyčce."

#: builtins.c:311
msgid ""
"Run a shell builtin.  This is useful when you wish to rename a\n"
"    shell builtin to be a function, but need the functionality of the\n"
"    builtin within the function itself."
msgstr ""
"Spustí vestavěný příkaz shellu. Toto se hodí, přejete-li si přejmenovat\n"
"    vestavěný příkaz na funkci, avšak funkcionalitu vestavěného příkazu\n"
"    potřebujete v téže funkci."

#: builtins.c:320
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR,\n"
"    returns \"$line $subroutine $filename\"; this extra information\n"
"    can be used to provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
"Vrátí kontext aktuálního podprogramu.\n"
"    \n"
"    Bez VÝRAZU vrátí „$řádek $název_souboru“. S VÝRAZEM vrátí\n"
"    „$řádek $podprogram $název_souboru“; tuto zvláštní informaci lze\n"
"    využít pro výpis zásobníku volání,\n"
"    \n"
"    Hodnota VÝRAZU určuje, kolik rámců volání se má projít od toho\n"
"    současného; vrcholový rámec má číslo 0."

#: builtins.c:334
msgid ""
"Change the current directory to DIR.  The variable $HOME is the\n"
"    default DIR.  The variable CDPATH defines the search path for\n"
"    the directory containing DIR.  Alternative directory names in CDPATH\n"
"    are separated by a colon (:).  A null directory name is the same as\n"
"    the current directory, i.e. `.'.  If DIR begins with a slash (/),\n"
"    then CDPATH is not used.  If the directory is not found, and the\n"
"    shell option `cdable_vars' is set, then try the word as a variable\n"
"    name.  If that variable has a value, then cd to the value of that\n"
"    variable.  The -P option says to use the physical directory structure\n"
"    instead of following symbolic links; the -L option forces symbolic links\n"
"    to be followed."
msgstr ""
"Změní aktuální adresář na ADR. Implicitní ADR je proměnná $HOME.\n"
"    Proměnná CDPATH definuje vyhledávací cestu pro adresář obsahující ADR.\n"
"    Názvy náhradních adresářů v CDPATH se oddělují dvojtečkou (:). Prázdný\n"
"    název adresáře je stejný jako aktuální adresář, tj. „.“. Začíná-li ADR\n"
"    na lomítko (/), nebude CDPATH použita. Nebude-li adresář nalezen a\n"
"    přepínač shellu „cdable_vars“ bude je nastaven, pak se dané slovo zkusí\n"
"    jakožto název proměnné. Má-li taková proměnná hodnotu, pak se provede cd\n"
"    do hodnoty této proměnné. Přepínač -P nařizuje použít fyzickou\n"
"    adresářovou strukturu namísto následováni symbolických odkazů;\n"
"    přepínač -L vynutí následování symbolických odkazů."

#: builtins.c:350
msgid ""
"Print the current working directory.  With the -P option, pwd prints\n"
"    the physical directory, without any symbolic links; the -L option\n"
"    makes pwd follow symbolic links."
msgstr ""
"Vypíše současný pracovní adresář. S přepínačem -P vypíše pwd fyzický\n"
"    adresář prostý všech symbolický odkazů; přepínač -L přinutí pwd\n"
"    následovat symbolické odkazy."

#: builtins.c:358
msgid "No effect; the command does nothing.  A zero exit code is returned."
msgstr "Žádný účinek, tento příkaz nic nedělá. Skončí s návratovým kódem nula."

#: builtins.c:364
msgid "Return a successful result."
msgstr "Vrací výsledek úspěchu."

#: builtins.c:370
msgid "Return an unsuccessful result."
msgstr "Vrací výsledek neúspěchu."

#: builtins.c:376
msgid ""
"Runs COMMAND with ARGS ignoring shell functions.  If you have a shell\n"
"    function called `ls', and you wish to call the command `ls', you can\n"
"    say \"command ls\".  If the -p option is given, a default value is used\n"
"    for PATH that is guaranteed to find all of the standard utilities.  If\n"
"    the -V or -v option is given, a string is printed describing COMMAND.\n"
"    The -V option produces a more verbose description."
msgstr ""
"Spustí PŘÍKAZ s ARGUMENTY ignoruje funkce shellu. Máte-li shellovou\n"
"    funkci pojmenovanou „ls“, a chcete-li zavolat příkaz „ls“, použijte\n"
"    „command ls“. Je-li zadán přepínač -p, bude pro PATH použita implicitní\n"
"    hodnota, která zaručuje, že budou nalezeny všechny standardní nástroje.\n"
"    Je-li zadán přepínač -V nebo -v, bude vytištěn řetězec popisující PŘÍKAZ.\n"
"    Přepínač -V produkuje podrobnější popis."

#: builtins.c:387
msgid ""
"Declare variables and/or give them attributes.  If no NAMEs are\n"
"    given, then display the values of variables instead.  The -p option\n"
"    will display the attributes and values of each NAME.\n"
"    \n"
"    The flags are:\n"
"    \n"
"      -a\tto make NAMEs arrays (if supported)\n"
"      -f\tto select from among function names only\n"
"      -F\tto display function names (and line number and source file name if\n"
"    \tdebugging) without definitions\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    `let') done when the variable is assigned to.\n"
"    \n"
"    When displaying values of variables, -f displays a function's name\n"
"    and definition.  The -F option restricts the display to function\n"
"    name only.\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute instead.  When\n"
"    used in a function, makes NAMEs local, as with the `local' command."
msgstr ""
"Deklaruje proměnné a/nebo jim nastaví atributy. Nejsou-li zadány NÁZVY,\n"
"    tak místo toho zobrazí hodnoty proměnných. Přepínač -p zobrazí atributy\n"
"    a hodnoty pro každý NÁZEV.\n"
"    \n"
"    Příznaky jsou:\n"
"    \n"
"      -a\tučiní NÁZVY poli (je-li podporováno)\n"
"      -f\tvybírá pouze mezi názvy funkcí\n"
"      -F\tzobrazí názvy funkcí (a číslo řádku a název zdrojového souboru,\n"
"        \tje-li zapnuto ladění) bez definic\n"
"      -i\tpřiřadí NÁZVŮM atribut „integer“ (číslo)\n"
"      -r\tučiní NÁZVY jen pro čtení\n"
"      -t\tpřiřadí NÁZVŮM atribut „trace“ (sledování)\n"
"      -x\tvyexportuje NÁZVY\n"
"    \n"
"    Proměnné s atributem integer jsou aritmeticky vyhodnoceny (vizte „let“),\n"
"    když je do proměnné přiřazováno.\n"
"    \n"
"    Při zobrazování hodnot proměnných -f zobrazí názvy a definice funkcí.\n"
"    Přepínač -F omezí výpis jen na názvy funkcí.\n"
"    \n"
"    Pomocí „+“ namísto „-“ daný atribut odeberete. Je-li použito uvnitř\n"
"    funkce, učiní NÁZVY lokální stejně jako příkaz „local“."

#: builtins.c:416
msgid "Obsolete.  See `declare'."
msgstr "Zastaralé. Vizte „declare“."

#: builtins.c:422
msgid ""
"Create a local variable called NAME, and give it VALUE.  LOCAL\n"
"    can only be used within a function; it makes the variable NAME\n"
"    have a visible scope restricted to that function and its children."
msgstr ""
"Vytvoří lokální proměnnou pojmenovanou NÁZEV a přiřadí jí HODNOTU.\n"
"    LOCAL smí být použito jen uvnitř funkcí. Učiní proměnnou NÁZEV viditelnou\n"
"    jen v dané funkci a jejích potomcích."

#: builtins.c:431
msgid ""
"Output the ARGs.  If -n is specified, the trailing newline is\n"
"    suppressed.  If the -e option is given, interpretation of the\n"
"    following backslash-escaped characters is turned on:\n"
"    \t\\a\talert (bell)\n"
"    \t\\b\tbackspace\n"
"    \t\\c\tsuppress trailing newline\n"
"    \t\\E\tescape character\n"
"    \t\\f\tform feed\n"
"    \t\\n\tnew line\n"
"    \t\\r\tcarriage return\n"
"    \t\\t\thorizontal tab\n"
"    \t\\v\tvertical tab\n"
"    \t\\\\\tbackslash\n"
"    \t\\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t\t0 to 3 octal digits\n"
"    \n"
"    You can explicitly turn off the interpretation of the above characters\n"
"    with the -E option."
msgstr ""
"Vypíše své ARGUMENTY. Je-li zadáno -n, potlačí závěrečný konec řádku.\n"
"    Je-li zadán přepínač -e, interpretování následujících znaků uvozených\n"
"    zpětným lomítkem bude zapnuto:\n"
"    \t\\a\tpoplach (zvonek)\n"
"    \t\\b\tbackspace\n"
"    \t\\c\tpotlačí závěrečný konec řádku\n"
"    \t\\E\tznak escapu\n"
"    \t\\f\tposun formuláře (form feed)\n"
"    \t\\n\tnový řádek\n"
"    \t\\r\tnávrat vozíku\n"
"    \t\\t\tvodorovný tabulátor\n"
"    \t\\v\tsvislý tabulátor\n"
"    \t\\\\\tzpětné lomítko\n"
"    \t\\0nnn\tznak, jehož  ASCII kód je NNN (osmičkově). NNN smí být\n"
"    \t\t0 až 3 osmičkové číslice\n"
"    \n"
"    Interpretování výše uvedených znaků můžete explicitně vypnout\n"
"    přepínačem -E."

#: builtins.c:456
msgid "Output the ARGs.  If -n is specified, the trailing newline is suppressed."
msgstr "Vypíše ARGUMENTY. Je-li zadáni -n, závěrečný konec řádku bude potlačen."

#: builtins.c:463
msgid ""
"Enable and disable builtin shell commands.  This allows\n"
"    you to use a disk command which has the same name as a shell\n"
"    builtin without specifying a full pathname.  If -n is used, the\n"
"    NAMEs become disabled; otherwise NAMEs are enabled.  For example,\n"
"    to use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.  On systems supporting dynamic\n"
"    loading, the -f option may be used to load new builtins from the\n"
"    shared object FILENAME.  The -d option will delete a builtin\n"
"    previously loaded with -f.  If no non-option names are given, or\n"
"    the -p option is supplied, a list of builtins is printed.  The\n"
"    -a option means to print every builtin with an indication of whether\n"
"    or not it is enabled.  The -s option restricts the output to the POSIX.2\n"
"    `special' builtins.  The -n option displays a list of all disabled builtins."
msgstr ""
"Povolí nebo zakáže vestavěný příkaz shellu. To vám umožňuje použít\n"
"    příkaz z disku, který má stejné jméno jako vestavěný příkaz shellu, aniž\n"
"    byste museli zadávat celou cestu. Je-li použito -n, NÁZVY se stanou\n"
"    zakázanými, jinak budou povoleny. Například „test“ z PATH namísto verze\n"
"    vestavěné do shellu lze používat tak, že napíšete „enable -n test“. Na\n"
"    systémech podporujících dynamické zavádění přepínač -f může být použit\n"
"    pro zavedení nových vestavěných příkazů ze sdíleného objektu NÁZEV_SOUBORU.\n"
"    Přepínač -d odstraní vestavěný příkaz zavedený přes -f. Není-li zadán\n"
"    žádný přepínač nebo je-li zadán přepínač -p, bude vypsán seznam vestavěných\n"
"    příkazů. Přepínač -a znamená, že budou vypsány všechny vestavěné příkazy a\n"
"    u každého bude vyznačeno, zda je povolen nebo zakázán. Přepínač -s omezí\n"
"    výpis na příkazy uvedené v POSIX.2. Přepínač -n zobrazí seznam všech\n"
"    zakázaných vestavěných příkazů."

#: builtins.c:481
msgid "Read ARGs as input to the shell and execute the resulting command(s)."
msgstr "Načte ARGUMENTY jako vstup shellu a výsledný příkaz(y) provede."

#: builtins.c:487
msgid ""
"Getopts is used by shell procedures to parse positional parameters.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters ($0 - $9), but if\n"
"    more arguments are given, they are parsed instead."
msgstr ""
"Getopts se používá v shellových procedurách na rozebrání pozičních\n"
"    parametrů.\n"
"    \n"
"    OPTSTRING obsahuje písmena přepínačů, které mají být rozeznány, Je-li\n"
"    písmeno následováno dvojtečkou, po přepínači se očekává argument, který\n"
"    by měl být od přepínače oddělen bílým místem.\n"
"    \n"
"    Pokaždé když je getopts zavolán, je následující přepínač umístěn do\n"
"    proměnné $name (proměnná je inicializována, neexistuje-li) a pořadí\n"
"    dalšího argumentu, který čeká na zpracování, do proměnné shellu OPTIND.\n"
"    OPTIND je inicializována na 1 vždy, když je zavolán shell nebo shellový\n"
"    skript. Pokud přepínač vyžaduje argument, getopts umístí tento argument\n"
"    do proměnné shellu OPTARG.\n"
"    \n"
"    getopts hlásí chyby jedním ze dvou způsobů. Pokud prvním znakem OPTSTRING\n"
"    je dvojtečka, getopts hlásí chyby tichým způsobem. V tomto režimu, žádné\n"
"    chybové zprávy nejsou vypisovány. Když se narazí na neplatný přepínač,\n"
"    getopts umístí tento znak do OPTARG. Pokud není nalezen povinný argument,\n"
"    getopts umístí „:“ do NAME a OPTARG nastaví na znak nalezeného přepínače.\n"
"    Pokud getopts nepracuje v tomto tichém režimu a je nalezen neplatný\n"
"    přepínač, getopts umístí „?“ do NAME a zruší OPTARG. Když nenajde povinný\n"
"    argument, je do NAME zapsán „?“, OPTARG zrušen a vytištěna diagnostická\n"
"    zpráva.\n"
"    \n"
"    Pokud proměnná shellu OPTERR má hodnotu 0, getopts vypne vypisování\n"
"    chybových zpráv dokonce, i když první znak OPTSTRING není dvojtečka.\n"
"    Implicitní hodnota OPTERR je 1.    \n"
"    Normálně getopts zpracovává poziční parametry ($0–$9), avšak následuje-li\n"
"    getopts více argumentů, budou rozebrány tyto namísto pozičních."

#: builtins.c:522
msgid ""
"Exec FILE, replacing this shell with the specified program.\n"
"    If FILE is not specified, the redirections take effect in this\n"
"    shell.  If the first argument is `-l', then place a dash in the\n"
"    zeroth arg passed to FILE, as login does.  If the `-c' option\n"
"    is supplied, FILE is executed with a null environment.  The `-a'\n"
"    option means to make set argv[0] of the executed process to NAME.\n"
"    If the file cannot be executed and the shell is not interactive,\n"
"    then the shell exits, unless the shell option `execfail' is set."
msgstr ""
"Provede SOUBOR, přičemž nahradí tento shell zadaným programem.\n"
"    Není-li SOUBOR zadán, přesměrování zapůsobí v tomto shellu. Je-li prvním\n"
"    argumentem „-l“, bude do nultého argumentu SOUBORU umístěna pomlčka tak,\n"
"    jak to dělá login. Je-li zadán přepínač „-c“, bude SOUBOR spuštěn\n"
"    s prázdným prostředím. Přepínač „-a“ znamená, že argv[0] prováděného\n"
"    procesu bude nastaven na NÁZEV. Pokud soubor nemůže být proveden a shell\n"
"    není interaktivní, pak shell bude ukončen, pokud přepínač shellu\n"
"    „execfail“ není nastaven."

#: builtins.c:535
msgid ""
"Exit the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Ukončí shell se stavem N. Bez N bude návratový kód roven kódu\n"
"    posledně prováděného příkazu"

#: builtins.c:542
msgid "Logout of a login shell."
msgstr "Odhlásí z přihlašovacího (login) shellu."

#: builtins.c:549
msgid ""
"fc is used to list or edit and re-execute commands from the history list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"       -e ENAME selects which editor to use.  Default is FCEDIT, then EDITOR,\n"
"          then vi.\n"
"    \n"
"       -l means list lines instead of editing.\n"
"       -n means no line numbers listed.\n"
"       -r means reverse the order of the lines (making it newest listed first).\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, the command is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command."
msgstr ""
"fc se používá na vypsání, úpravu a znovu provedení příkazů ze seznamu\n"
"    historie.\n"
"    PRVNÍ a POSLEDNÍ mohou být čísla určující rozsah nebo PRVNÍ může být\n"
"    řetězec, což určuje nejnovější příkaz začínající na zadaný řetězec.\n"
"    \n"
"       -e ENAME vybere editor. Implicitní je FCEDIT, pak EDITOR, pak vi.\n"
"    \n"
"       -l požaduje vypsaní namísto upravování.\n"
"       -n vypne číslování řádků.\n"
"       -r obrátí pořadí řádků (nejnovější budou první).\n"
"    \n"
"    Forma příkazu „fc -s [VZOR=NÁHRADA… [PŘÍKAZ]“ znamená, že příkaz bude\n"
"    po nahrazení STARÝ=NOVÝ znovu vykonán.\n"
"    \n"
"    Užitečný alias je r='fc -s', takže napsání „r cc“ spustí poslední příkaz\n"
"    začínající na „cc“ a zadání „r“ znovu spustí poslední příkaz."

#: builtins.c:574
msgid ""
"Place JOB_SPEC in the foreground, and make it the current job.  If\n"
"    JOB_SPEC is not present, the shell's notion of the current job is\n"
"    used."
msgstr ""
"Přepne ÚLOHU na popředí a učiní ji aktuální úlohou. Není-li ÚLOHA\n"
"    zadána, použije se úloha, o které si shell myslí, že aktuální."

#: builtins.c:584
msgid ""
"Place each JOB_SPEC in the background, as if it had been started with\n"
"    `&'.  If JOB_SPEC is not present, the shell's notion of the current\n"
"    job is used."
msgstr ""
"Přepne každou ÚLOHU na pozadí, jako by byla spuštěna s „&“. Ne-li\n"
"    ÚLOHA uvedena, použije se úloha, o které si shell myslí, že je aktuální."

#: builtins.c:593
msgid ""
"For each NAME, the full pathname of the command is determined and\n"
"    remembered.  If the -p option is supplied, PATHNAME is used as the\n"
"    full pathname of NAME, and no path search is performed.  The -r\n"
"    option causes the shell to forget all remembered locations.  The -d\n"
"    option causes the shell to forget the remembered location of each NAME.\n"
"    If the -t option is supplied the full pathname to which each NAME\n"
"    corresponds is printed.  If multiple NAME arguments are supplied with\n"
"    -t, the NAME is printed before the hashed full pathname.  The -l option\n"
"    causes output to be displayed in a format that may be reused as input.\n"
"    If no arguments are given, information about remembered commands is displayed."
msgstr ""
"Pro každý NÁZEV je určena plná cesta k příkazu a je zapamatována.\n"
"    Za použití přepínače -p se vezme NÁZEV_CESTY za plnou cestu k NÁZVU a\n"
"    žádné vyhledávání cesty se nekoná. Přepínač -r způsobí, že shell zapomene\n"
"    všechny zapamatovaná umístění. Přepínač -d způsobí, že shell zapomene\n"
"    zapamatovaná umístění každého NÁZVU. Je-li zadán přepínač -t, bude vypsána\n"
"    plná cesta ke každému NÁZVU. Je-li s -t zadáno více NÁZVŮ, NÁZEV bude\n"
"    vypsán před uloženou celou cestou. Přepínač -l vytvoří takový výstup,\n"
"    který lze opět použít jako vstup. Nejsou-li zadány žádné argumenty,\n"
"    budou vypsány informace o zapamatovaných příkazech."

#: builtins.c:609
msgid ""
"Display helpful information about builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise a list of the builtins is printed.  The -s option\n"
"    restricts the output for each builtin command matching PATTERN to\n"
"    a short usage synopsis."
msgstr ""
"Zobrazí užitečné informace o vestavěných příkazech. Je-li zadán VZOREK,\n"
"    vrátí podrobnou nápovědu ke všem příkazům odpovídajícím VZORKU, jinak je\n"
"    vytištěn seznam vestavěných příkazů. Přepínač -s omezí výstup o každém\n"
"    vestavěném příkazu odpovídajícího VZORKU na stručný popis použití."

#: builtins.c:621
msgid ""
"Display the history list with line numbers.  Lines listed with\n"
"    with a `*' have been modified.  Argument of N says to list only\n"
"    the last N lines.  The `-c' option causes the history list to be\n"
"    cleared by deleting all of the entries.  The `-d' option deletes\n"
"    the history entry at offset OFFSET.  The `-w' option writes out the\n"
"    current history to the history file;  `-r' means to read the file and\n"
"    append the contents to the history list instead.  `-a' means\n"
"    to append history lines from this session to the history file.\n"
"    Argument `-n' means to read all history lines not already read\n"
"    from the history file and append them to the history list.\n"
"    \n"
"    If FILENAME is given, then that is used as the history file else\n"
"    if $HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    If the -s option is supplied, the non-option ARGs are appended to\n"
"    the history list as a single entry.  The -p option means to perform\n"
"    history expansion on each ARG and display the result, without storing\n"
"    anything in the history list.\n"
"    \n"
"    If the $HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed otherwise."
msgstr ""
"Zobrazí seznam historie s očíslovanými řádky. Řádky vypsané s „*“ byly\n"
"    změněny. Argument N říká, že se vypíše pouze posledních N řádek.\n"
"    Přepínač „-c“ způsobí, že seznam historie bude vyčištěn smazáním všech\n"
"    položek. Přepínač „-d“ smaže ze seznamu historie položku na pozici POZICE.\n"
"    Přepínač „-w“ zapíše současnou historii do souboru historie, „-r“ znamená,\n"
"    že se soubor načte a obsah se připojí do seznamu historie. „-a“ znamená,\n"
"    že řádky historie z této relace se připojí do souboru historie. Argument\n"
"    „-n“ znamená, že všechny řádky historie, které ještě nebyly načteny,\n"
"    načtou ze souboru historie a připojí se do seznamu historie.\n"
"    \n"
"    Je-li zadán JMÉNO_SOUBORU, tak ten je použit jako soubor historie. Jinak\n"
"    pokud $HISTFILE má hodnotu, tato je použita, jinak ~/.bash_history. Je-li\n"
"    zadán přepínač „-s“, nepřepínačové ARGUMENTY budou připojeny do seznamu\n"
"    historie jako jedna položka. Přepínač „-p“ značí, že se expanduje historie\n"
"    na každém ARGUMENTU a výsledek se zobrazí, aniž by cokoliv uložilo do\n"
"    seznamu historie.\n"
"    \n"
"    Je-li proměnná $HISTTIMEFORMAT nastavena a není-li prázdná, její hodnota\n"
"    se použije jako formátovací řetězec pro strftime(3) při výpisu časových\n"
"    razítek spojených s každou položkou historie. Jinak žádná časová razítka\n"
"    nebudou vypisována."

#: builtins.c:649
msgid ""
"Lists the active jobs.  The -l option lists process id's in addition\n"
"    to the normal information; the -p option lists process id's only.\n"
"    If -n is given, only processes that have changed status since the last\n"
"    notification are printed.  JOBSPEC restricts output to that job.  The\n"
"    -r and -s options restrict output to running and stopped jobs only,\n"
"    respectively.  Without options, the status of all active jobs is\n"
"    printed.  If -x is given, COMMAND is run after all job specifications\n"
"    that appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader."
msgstr ""
"Vypíše aktivní úlohy. Přepínač -l vypíše navíc ID procesů, přepínač -p\n"
"    vypíše pouze ID procesů. Je-li zadáno -n, pouze procesy, které od minulého\n"
"    oznámení změnily stav, budou vypsány. ÚLOHA omezuje výstup na danou úlohu.\n"
"    Přepínače -r a -s zužují výstup jen na běžící, respektive pozastavené\n"
"    úlohy. Bez uvedení přepínačů bude vypsán stav všech aktivních úloh. Je-li\n"
"    použito -x, poté, co všechny úlohy uvedené mezi ARGUMENTY budou nahrazeny\n"
"    ID procesu, který je vedoucím skupiny dané úlohy, bude spuštěn PŘÍKAZ."

#: builtins.c:665
msgid ""
"By default, removes each JOBSPEC argument from the table of active jobs.\n"
"    If the -h option is given, the job is not removed from the table, but is\n"
"    marked so that SIGHUP is not sent to the job if the shell receives a\n"
"    SIGHUP.  The -a option, when JOBSPEC is not supplied, means to remove all\n"
"    jobs from the job table; the -r option means to remove only running jobs."
msgstr ""
"Implicitně odstraní každý argument ÚLOHA z tabulky aktivních úloh. Je-li\n"
"    zadán přepínač -h, úloha není odstraněna z tabulky, ale je označena tak.\n"
"    že úloze nebude zaslán SIGHUP, když shell obdrží SIGHUP. Přepínač -a,\n"
"    pokud není uvedena ÚLOHA, znamená, že všechny úlohy budou odstraněny\n"
"    z tabulky úloh. Přepínač -r znamená, že pouze běžící úlohy budou\n"
"    odstraněny."

#: builtins.c:676
msgid ""
"Send the processes named by PID (or JOBSPEC) the signal SIGSPEC.  If\n"
"    SIGSPEC is not present, then SIGTERM is assumed.  An argument of `-l'\n"
"    lists the signal names; if arguments follow `-l' they are assumed to\n"
"    be signal numbers for which names should be listed.  Kill is a shell\n"
"    builtin for two reasons: it allows job IDs to be used instead of\n"
"    process IDs, and, if you have reached the limit on processes that\n"
"    you can create, you don't have to start a process to kill another one."
msgstr ""
"Zašle procesu určeném PID (nebo ÚLOHOU) uvedený signál SIGSPEC.\n"
"    Není-li SIGSPEC zadán, pak se předpokládá SIGTERM. Argumentem „-l“ lze\n"
"    vypsat názvy signálů. Pokud „-l“ následují argumenty, má se za to, že se\n"
"    jedná o čísla signálů, pro které se mají vyspat jejich názvy. Kill je\n"
"    vestavěný příkaz shellu ze dvou důvodů: umožňuje použít identifikátory\n"
"    úloh namísto ID procesů a pokud jste dosáhli limitu počtu procesů, které\n"
"    smíte vytvořit, neměli byste jak nastartovat další proces, abyste mohli\n"
"    jiný proces zabít."

#: builtins.c:688
msgid ""
"Each ARG is an arithmetic expression to be evaluated.  Evaluation\n"
"    is done in fixed-width integers with no check for overflow, though\n"
"    division by 0 is trapped and flagged as an error.  The following\n"
"    list of operators is grouped into levels of equal-precedence operators.\n"
"    The levels are listed in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    If the last ARG evaluates to 0, let returns 1; 0 is returned\n"
"    otherwise."
msgstr ""
"Každý ARGUMENT je aritmetický výraz na vyhodnocení. Vyhodnocení je\n"
"    prováděno v celých číslech o pevné šířce bez kontrol přetečení, avšak\n"
"    dělení 0 je zachyceno a označeno za chybu. Následující seznam operátorů\n"
"    je rozdělen do skupin podle úrovní přednosti.\n"
"    \n"
"    \tid++, id--\tnásledné zvýšení, snížení proměnné\n"
"    \t++id, --id\tpřednostní zvýšení, snížení proměnné\n"
"    \t-, +\t\tunární mínus, plus\n"
"    \t!, ~\t\tlogický a bitová negace\n"
"    \t**\t\tumocnění\n"
"    \t*, /, %\t\tnásobení, dělení, zbytková třída\n"
"    \t+, -\t\tsčítání, odečítání\n"
"    \t<<, >>\t\tlevý a pravý bitový posun\n"
"    \t<=, >=, <, >\tporovnání\n"
"    \t==, !=\t\trovnost, nerovnost\n"
"    \t&\t\tbitové a zároveň (AND)\n"
"    \t^\t\tbitové vylučující nebo (XOR)\n"
"    \t|\t\tbitové nebo (OR)\n"
"    \t&&\t\tlogické a zároveň (AND)\n"
"    \t||\t\tlogické nebo (OR)\n"
"    \tVÝRAZ ? VÝRAZ : VÝRAZ\n"
"    \t\t\tpodmíněný operátor\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tpřiřazení\n"
"    \n"
"    Proměnné shellu jsou povolené operandy. Název proměnné je nahrazen její\n"
"    hodnotou (s automatickým převodem na celé číslo pevné šířky) uvnitř\n"
"    výrazu. Proměnná nemusí mít atribut integer (číslo) zapnutý, aby byla\n"
"    použitelná ve výrazu.\n"
"    \n"
"    Operátory se vyhodnocují v pořadí přednosti. Podvýrazy v závorkách jsou\n"
"    vyhodnoceny přednostně a smí přebít pravidla přednosti uvedená výše.\n"
"    \n"
"    Pokud poslední ARGUMENT je vyhodnocen na 0, let vrátí 1. Jinak je\n"
"    navrácena 0."

#: builtins.c:731
msgid ""
"One line is read from the standard input, or from file descriptor FD if the\n"
"    -u option is supplied, and the first word is assigned to the first NAME,\n"
"    the second word to the second NAME, and so on, with leftover words assigned\n"
"    to the last NAME.  Only the characters found in $IFS are recognized as word\n"
"    delimiters.  If no NAMEs are supplied, the line read is stored in the REPLY\n"
"    variable.  If the -r option is given, this signifies `raw' input, and\n"
"    backslash escaping is disabled.  The -d option causes read to continue\n"
"    until the first character of DELIM is read, rather than newline.  If the -p\n"
"    option is supplied, the string PROMPT is output without a trailing newline\n"
"    before attempting to read.  If -a is supplied, the words read are assigned\n"
"    to sequential indices of ARRAY, starting at zero.  If -e is supplied and\n"
"    the shell is interactive, readline is used to obtain the line.  If -n is\n"
"    supplied with a non-zero NCHARS argument, read returns after NCHARS\n"
"    characters have been read.  The -s option causes input coming from a\n"
"    terminal to not be echoed.\n"
"    \n"
"    The -t option causes read to time out and return failure if a complete line\n"
"    of input is not read within TIMEOUT seconds.  If the TMOUT variable is set,\n"
"    its value is the default timeout.  The return code is zero, unless end-of-file\n"
"    is encountered, read times out, or an invalid file descriptor is supplied as\n"
"    the argument to -u."
msgstr ""
"Ze standardního vstupu, nebo deskriptoru souboru FD, je-li zadán\n"
"    přepínač -u,je načten jeden řádek a první slovo je přiřazeno do prvního\n"
"    JMÉNA, druhé slovo do druhého JMÉNA a tak dále, přičemž přebývající slova\n"
"    se přiřadí do posledního JMÉNA. Pouze znaky uvedené v $IFS jsou považovány\n"
"    za oddělovače slov. Nejsou-li uvedeny žádná JMÉNA, načtený řádek bude\n"
"    uložen do proměnné REPLY. Je-li zadán přepínač -r, značí to „syrový“ vstup\n"
"    a escapování zpětným lomítkem je vypnuto. Přepínač -d způsobí, že čteno\n"
"    bude dokud se nenarazí na první znak ODDĚLOVAČE namísto nového řádku.\n"
"    Je-li zadán přepínač -p, řetězec VÝZVA bude vypsán bez závěrečného nového\n"
"    řádku, dříve než se zahájí načítání.  Je-li zadáno -a, načtená slova budou\n"
"    přiřazena do postupných prvků POLE, počínaje nulou. Je-li zadáno -e a\n"
"    shell je interaktivní, bude k načtení řádku použita readline. Je-li\n"
"    zadán -n s nenulovým argumentem P_ZNAKŮ, read vrátí řízení po načtení\n"
"    P_ZNAKŮ znaků. Přepínač -s způsobí, že vstup pocházející z terminálu\n"
"    nebude zobrazován.\n"
"    \n"
"    Přepínač -t umožní vypršení časového limitu a vrácení chyby, pokud nebude\n"
"    načten celý řádek do LIMIT sekund. Návratový kód je nula, pokud se\n"
"    nenarazí na konec souboru, časový limit pro čtení nevyprší nebo není\n"
"    poskytnut neplatný deskriptor souboru jako argument -u."

#: builtins.c:757
msgid ""
"Causes a function to exit with the return value specified by N.  If N\n"
"    is omitted, the return status is that of the last command."
msgstr ""
"Způsobí ukončení funkce s návratovou hodnotou uvedenou v N. Je-li\n"
"    N vynecháno, návratový kód je roven poslednímu příkazu."

#: builtins.c:764
msgid ""
"    -a  Mark variables which are modified or created for export.\n"
"        -b  Notify of job termination immediately.\n"
"        -e  Exit immediately if a command exits with a non-zero status.\n"
"        -f  Disable file name generation (globbing).\n"
"        -h  Remember the location of commands as they are looked up.\n"
"        -k  All assignment arguments are placed in the environment for a\n"
"            command, not just those that precede the command name.\n"
"        -m  Job control is enabled.\n"
"        -n  Read commands but do not execute them.\n"
"        -o option-name\n"
"            Set the variable corresponding to option-name:\n"
"                allexport    same as -a\n"
"                braceexpand  same as -B\n"
"                emacs        use an emacs-style line editing interface\n"
"                errexit      same as -e\n"
"                errtrace     same as -E\n"
"                functrace    same as -T\n"
"                hashall      same as -h\n"
"                histexpand   same as -H\n"
"                history      enable command history\n"
"                ignoreeof    the shell will not exit upon reading EOF\n"
"                interactive-comments\n"
"                             allow comments to appear in interactive commands\n"
"                keyword      same as -k\n"
"                monitor      same as -m\n"
"                noclobber    same as -C\n"
"                noexec       same as -n\n"
"                noglob       same as -f\n"
"                nolog        currently accepted but ignored\n"
"                notify       same as -b\n"
"                nounset      same as -u\n"
"                onecmd       same as -t\n"
"                physical     same as -P\n"
"                pipefail     the return value of a pipeline is the status of\n"
"                             the last command to exit with a non-zero status,\n"
"                             or zero if no command exited with a non-zero status\n"
"                posix        change the behavior of bash where the default\n"
"                             operation differs from the 1003.2 standard to\n"
"                             match the standard\n"
"                privileged   same as -p\n"
"                verbose      same as -v\n"
"                vi           use a vi-style line editing interface\n"
"                xtrace       same as -x\n"
"        -p  Turned on whenever the real and effective user ids do not match.\n"
"            Disables processing of the $ENV file and importing of shell\n"
"            functions.  Turning this option off causes the effective uid and\n"
"            gid to be set to the real uid and gid.\n"
"        -t  Exit after reading and executing one command.\n"
"        -u  Treat unset variables as an error when substituting.\n"
"        -v  Print shell input lines as they are read.\n"
"        -x  Print commands and their arguments as they are executed.\n"
"        -B  the shell will perform brace expansion\n"
"        -C  If set, disallow existing regular files to be overwritten\n"
"            by redirection of output.\n"
"        -E  If set, the ERR trap is inherited by shell functions.\n"
"        -H  Enable ! style history substitution.  This flag is on\n"
"            by default when the shell is interactive.\n"
"        -P  If set, do not follow symbolic links when executing commands\n"
"            such as cd which change the current directory.\n"
"        -T  If set, the DEBUG trap is inherited by shell functions.\n"
"        -   Assign any remaining arguments to the positional parameters.\n"
"            The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed."
msgstr ""
"    -a  Označí měněné nebo vytvářené proměnné pro export.\n"
"        -b  Neprodleně oznámí ukončení úlohy.\n"
"        -e  Neprodleně skončí, pokud nějaký příkaz skončí s nenulovým kódem.\n"
"        -f  Zakáže vytváření jmen souborů (globbing).\n"
"        -h  Zapamatuje si umístění příkazů tehdy, když jsou vyhledány.\n"
"        -k  Všechny přiřazovací argumenty budou umístěny do prostředí\n"
"            příkazu. Nejenom ty, co předchází název příkazu.\n"
"        -m  Správa úloh je zapnuta.\n"
"        -n  Příkazy načte, ale neprovede je.\n"
"        -o NÁZEV_PŘEPÍNAČE\n"
"            Nastaví proměnnou odpovídající NÁZVU_PŘEPÍNAČE:\n"
"                allexport    stejné jako -a\n"
"                braceexpand  stejné jako -B\n"
"                emacs        použije emacsový způsob editace na řádku\n"
"                errexit      stejné jako -e\n"
"                errtrace     stejné jako -E\n"
"                functrace    stejné jako -T\n"
"                hashall      stejné jako -h\n"
"                histexpand   stejné jako -H\n"
"                history      zapne historii příkazů\n"
"                ignoreeof    shell neskončí, když načte EOF (konec souboru)\n"
"                interactive-comments\n"
"                             povolí, aby se v interaktivních příkazech\n"
"                             objevovaly komentáře\n"
"                keyword      stejné jako -k\n"
"                monitor      stejné jako -m\n"
"                noclobber    stejné jako -C\n"
"                noexec       stejné jako -n\n"
"                noglob       stejné jako -f\n"
"                nolog        v současnosti přijímáno, ale ignorováno\n"
"                notify       stejné jako -b\n"
"                nounset      stejné jako -u\n"
"                onecmd       stejné jako -t\n"
"                physical     stejné jako -P\n"
"                pipefail     návratová hodnota kolony je status posledního\n"
"                             příkazu, který skončil s nenulovým kódem.\n"
"                             Návratová hodnota je nula, pokud žádný z příkazů\n"
"                             neskončil s nenulovým kódem.\n"
"                posix        změní chování bashe tam, kde implicitní chování\n"
"                             se liší od standardu 1003.2, tak, aby bylo\n"
"                             v souladu se standardem\n"
"                privileged   stejné jako -p\n"
"                verbose      stejné jako -v\n"
"                vi           použije vi způsob editace na řádku\n"
"                xtrace       stejné jako -x\n"
"        -p  Zapnuto, kdykoliv reálné a efektivní ID uživatele se neshodují.\n"
"            Vypne zpracování souboru $ENV a importování shellových funkcí.\n"
"            Vypnutí tohoto přepínače způsobí, že efektivní UID a GID budou\n"
"            nastaveny na reálná UID a GID.\n"
"        -t  Skončí po načtení a provedení jednoho příkazu.\n"
"        -u  Při substituci považuje nenastavené proměnné za chybu.\n"
"        -v  Vstupní řádky shellu se budou vypisovat tak, jak budou načítány.\n"
"        -x  Vypisuje příkazy a jejich argumenty tak, jak jsou spouštěny.\n"
"        -B  Shell bude provádět závorkovou (brace) expanzi.\n"
"        -C  Je-li nastaveno, zakáže přepsání již existujících běžných souborů\n"
"            při přesměrování výstupu.\n"
"        -E  Je-li nastaveno, trap ERR (zachytávání chyb) bude děděn do\n"
"            funkcí shellu.\n"
"        -H  Zapne ! způsob nahrazování histore. Tento příznak je automaticky\n"
"            zapnut při interaktivním shellu.\n"
"        -P  Je-li nastaveno, nebudou následovány symbolické odkazy při\n"
"            provádění příkazů jako změna pracovního adresáře pomocí „cd“.\n"
"        -T  Je-li nastaveno, trap DEBUG (obsluha ladění) bude děděna do\n"
"            funkcí shellu.\n"
"        -   Přiřadí jakékoliv zbývající argumenty do pozičních parametrů.\n"
"            Přepínače -x a -v budou vypnuty.\n"
"    \n"
"    Použití + místo - způsobí, že tyto příznaky budou vypnuty. Příznaky lze\n"
"    použít při volání shellu. Aktuální množinu příznaků je možno nalézt v $-.\n"
"    Přebývající ARGUMENTY jsou poziční parametry a budou přiřazeny, v pořadí,\n"
"    do $1, $2, … $n. Nejsou-li zadány žádné ARGUMENTY, budou vytištěny všechny\n"
"    proměnné shellu."

#: builtins.c:837
msgid ""
"For each NAME, remove the corresponding variable or function.  Given\n"
"    the `-v', unset will only act on variables.  Given the `-f' flag,\n"
"    unset will only act on functions.  With neither flag, unset first\n"
"    tries to unset a variable, and if that fails, then tries to unset a\n"
"    function.  Some variables cannot be unset; also see readonly."
msgstr ""
"Pro každé JMÉNO odstraní odpovídající proměnnou nebo funkci.\n"
"    Spolu s „-v“ bude unset fungovat jen na proměnné. S příznakem „-f“ bude\n"
"    unset fungovat jen na funkce. Bez těchto dvou příznaků unset nejprve zkusí\n"
"    zrušit proměnnou a pokud toto selže, tak zkusí zrušit funkci. Některé\n"
"    proměnné nelze odstranit. Taktéž vizte příkaz „readonly“."

#: builtins.c:847
msgid ""
"NAMEs are marked for automatic export to the environment of\n"
"    subsequently executed commands.  If the -f option is given,\n"
"    the NAMEs refer to functions.  If no NAMEs are given, or if `-p'\n"
"    is given, a list of all names that are exported in this shell is\n"
"    printed.  An argument of `-n' says to remove the export property\n"
"    from subsequent NAMEs.  An argument of `--' disables further option\n"
"    processing."
msgstr ""
"NÁZVY jsou označeny pro automatické exportování do prostředí následně\n"
"    prováděných příkazů. Je-li zadán přepínač -f, NÁZVY se vztahují k funkcím.\n"
"    Nejsou-li zadány žádné NÁZVY nebo je-li zadáno „-p“, bude vytištěn seznam\n"
"    všech názvů, které jsou v tomto shellu exportovány. Argument „-n“ nařizuje\n"
"    odstranit vlastnost exportovat z následujících NÁZVŮ. Argument „--“\n"
"    zakazuje zpracování dalších přepínačů."

#: builtins.c:859
msgid ""
"The given NAMEs are marked readonly and the values of these NAMEs may\n"
"    not be changed by subsequent assignment.  If the -f option is given,\n"
"    then functions corresponding to the NAMEs are so marked.  If no\n"
"    arguments are given, or if `-p' is given, a list of all readonly names\n"
"    is printed.  The `-a' option means to treat each NAME as\n"
"    an array variable.  An argument of `--' disables further option\n"
"    processing."
msgstr ""
"Zadané NÁZVY budou označeny jako jen pro čtení a hodnoty těchto NÁZVŮ\n"
"    nebude možné změnit následným přiřazením. Je-li zadán přepínač -f, pak\n"
"    funkce těchto NÁZVŮ budou takto označeny. Nejsou-li zadány žádné argumenty\n"
"    nebo je-li zadáno „-p“, bude vytištěn seznam všech jmen jen pro čtení.\n"
"    Přepínač „-a“ znamená, že s každým NÁZVEM bude zacházeno jako s proměnnou\n"
"    typu pole. Argument „--“ zakáže zpracování dalších přepínačů."

#: builtins.c:871
msgid ""
"The positional parameters from $N+1 ... are renamed to $1 ...  If N is\n"
"    not given, it is assumed to be 1."
msgstr ""
"Poziční parametry budou přejmenovány z $N+1 na $1 atd. Není-li N zadáno,\n"
"    předpokládá se 1."

#: builtins.c:878 builtins.c:887
msgid ""
"Read and execute commands from FILENAME and return.  The pathnames\n"
"    in $PATH are used to find the directory containing FILENAME.  If any\n"
"    ARGUMENTS are supplied, they become the positional parameters when\n"
"    FILENAME is executed."
msgstr ""
"Načte a provede příkazy z NÁZEV_SOUBORU a vrátí řízení. Názvy cest\n"
"    v $PATH jsou použity pro vyhledání adresáře obsahujícího NÁZEV_SOUBORU.\n"
"    Jsou-li zadány nějaké ARGUMENTY, stanou se pozičními parametry při běhu\n"
"    NÁZVU_SOUBORU."

#: builtins.c:897
msgid ""
"Suspend the execution of this shell until it receives a SIGCONT\n"
"    signal.  The `-f' if specified says not to complain about this\n"
"    being a login shell if it is; just suspend anyway."
msgstr ""
"Pozastaví provádění tohoto shellu do doby, něž bude obdržen signál\n"
"    SIGCONT. „-f“, je-li zadán, potlačí stížnost na to, že se jedná\n"
"    o přihlašovací shell (pokud tomu tak je), a prostě pozastaví činnost."

#: builtins.c:906
msgid ""
"Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators as well, and numeric comparison operators.\n"
"    \n"
"    File operators:\n"
"    \n"
"        -a FILE        True if file exists.\n"
"        -b FILE        True if file is block special.\n"
"        -c FILE        True if file is character special.\n"
"        -d FILE        True if file is a directory.\n"
"        -e FILE        True if file exists.\n"
"        -f FILE        True if file exists and is a regular file.\n"
"        -g FILE        True if file is set-group-id.\n"
"        -h FILE        True if file is a symbolic link.\n"
"        -L FILE        True if file is a symbolic link.\n"
"        -k FILE        True if file has its `sticky' bit set.\n"
"        -p FILE        True if file is a named pipe.\n"
"        -r FILE        True if file is readable by you.\n"
"        -s FILE        True if file exists and is not empty.\n"
"        -S FILE        True if file is a socket.\n"
"        -t FD          True if FD is opened on a terminal.\n"
"        -u FILE        True if the file is set-user-id.\n"
"        -w FILE        True if the file is writable by you.\n"
"        -x FILE        True if the file is executable by you.\n"
"        -O FILE        True if the file is effectively owned by you.\n"
"        -G FILE        True if the file is effectively owned by your group.\n"
"        -N FILE        True if the file has been modified since it was last read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"        -z STRING      True if string is empty.\n"
"    \n"
"        -n STRING\n"
"        STRING         True if string is not empty.\n"
"    \n"
"        STRING1 = STRING2\n"
"                       True if the strings are equal.\n"
"        STRING1 != STRING2\n"
"                       True if the strings are not equal.\n"
"        STRING1 < STRING2\n"
"                       True if STRING1 sorts before STRING2 lexicographically.\n"
"        STRING1 > STRING2\n"
"                       True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"        -o OPTION      True if the shell option OPTION is enabled.\n"
"        ! EXPR         True if expr is false.\n"
"        EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"        EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"        arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                       -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2."
msgstr ""
"Skončí s kódem 0 (pravda) nebo 1 (nepravda) podle vyhodnocení VÝRAZU.\n"
"    Výraz smí být unární nebo binární. Unární výrazy se často používají pro\n"
"    zjištění stavu souboru. Rovněž jsou k dispozici řetězcové operátory a\n"
"    operátory číselného porovnávání.\n"
"    \n"
"    Souborové operátory:\n"
"    \n"
"        -a SOUBOR      Pravda, pokud soubor existuje.\n"
"        -b SOUBOR      Pravda, pokud soubor je blokovým zařízením.\n"
"        -c SOUBOR      Pravda, pokud soubor je znakovým zařízením.\n"
"        -d SOUBOR      Pravda, pokud soubor je adresářem.\n"
"        -e SOUBOR      Pravda, pokud soubor existuje.\n"
"        -f SOUBOR      Pravda, pokud soubor existuje a to běžný soubor.\n"
"        -g SOUBOR      Pravda, pokud soubor je SGID.\n"
"        -h SOUBOR      Pravda, pokud soubor je symbolickým odkazem.\n"
"        -L SOUBOR      Pravda, pokud soubor je symbolickým odkazem.\n"
"        -k SOUBOR      Pravda, pokud soubor má nastavený „sticky“ bit.\n"
"        -p SOUBOR      Pravda, pokud soubor je pojmenovanou rourou.\n"
"        -r SOUBOR      Pravda, pokud soubor je vámi čitelný.\n"
"        -s SOUBOR      Pravda, pokud soubor existuje a je neprázdný.\n"
"        -S SOUBOR      Pravda, pokud soubor je socketem.\n"
"        -t FD          Pravda, pokud FD (deskriptor souboru) je otevřený na\n"
"                       terminálu.\n"
"        -u SOUBOR      Pravda, pokud soubor je SUID.\n"
"        -w SOUBOR      Pravda, pokud soubor je vámi zapisovatelný.\n"
"        -x SOUBOR      Pravda, pokud soubor je vámi spustitelný.\n"
"        -O SOUBOR      Pravda, pokud soubor je vámi efektivně vlastněn.\n"
"        -G SOUBOR      Pravda, pokud soubor je efektivně vlastněn vaší\n"
"                       skupinou.\n"
"        -N SOUBOR      Pravda, pokud soubor byl změněn po posledním čtení.\n"
"    \n"
"      SOUBOR1 -nt SOUBOR2\n"
"                       Pravda, pokud je SOUBOR1 novější než SOUBOR2 (podle času\n"
"                       změny obsahu).\n"
"    \n"
"      SOUBOR1 -ot SOUBOR2\n"
"                       Pravda, pokud SOUBOR1 je starší než SOUBOR2.\n"
"    \n"
"      SOUBOR1 -ef SOUBOR2\n"
"                       Pravda, pokud SOUBOR1 je pevným odkazem na SOUBOR2.\n"
"    \n"
"    Řetězcové operátory:\n"
"    \n"
"        -z ŘETĚZEC     Pravda, pokud ŘETĚZEC je prázdný.\n"
"    \n"
"        -n ŘETĚZEC\n"
"        ŘETĚZEC        Pravda, pokud ŘETĚZEC není prázdný.\n"
"    \n"
"        ŘETĚZEC1 = ŘETĚZEC2\n"
"                       Pravda, pokud jsou řetězce shodné.\n"
"        ŘETĚZEC1 != ŘETĚZEC2\n"
"                       Pravda, pokud se řetězce neshodují.\n"
"        ŘETĚZEC1 < ŘETĚZEC2\n"
"                       Pravda, pokud se ŘETĚZEC1 řadí lexikograficky před\n"
"                       ŘETĚZEC2.\n"
"        ŘETĚZEC1 > ŘETĚZEC2\n"
"                       Pravda, pokud se ŘETĚZEC1 řadí lexikograficky za\n"
"                       ŘETĚZEC2.\n"
"    \n"
"    Další operátory:\n"
"    \n"
"        -o PŘEPÍNAČ    Pravda, pokud je přepínač shellu PŘEPÍNAČ zapnut.\n"
"        ! VÝRAZ        Pravda, pokud VÝRAZ je nepravdivý.\n"
"        VÝRAZ1 -a VÝRAZ2\n"
"                       Pravda, pokud oba VÝRAZ1 I VÝRAZ2 jsou pravdivé.\n"
"        VÝRAZ1 -o VÝRAZ2\n"
"                       Pravda, pokud VÝRAZ1 NEBO VÝRAZ2 je pravdivý.\n"
"    \n"
"        ARGUMENT1 OP ARGUMENT2\n"
"                       Aritmetické testy.  OP je jeden z -eq, -ne, -lt,\n"
"                       -le, -gt nebo -ge.\n"
"    \n"
"    Aritmetické binární operátory vracejí pravdu, pokud ARGUMENT1 je roven,\n"
"    neroven, menší než, menší než nebo roven, větší než, větší než nebo\n"
"    roven ARGUMENTU2."

#: builtins.c:976
msgid ""
"This is a synonym for the \"test\" builtin, but the last\n"
"    argument must be a literal `]', to match the opening `['."
msgstr ""
"Toto je synonymum pro vestavěný příkaz „test“, až na to, že\n"
"    poslední argument musí být doslovně „]“, aby se shodoval s otevírající „[“."

#: builtins.c:983
msgid ""
"Print the accumulated user and system times for processes run from\n"
"    the shell."
msgstr ""
"Vypíše celkovou dobu procesu spuštěného z shellu, kterou strávil\n"
"    v uživatelském a jaderném (system) prostoru."

#: builtins.c:990
msgid ""
"The command ARG is to be read and executed when the shell receives\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.  If a SIGNAL_SPEC is EXIT (0)\n"
"    the command ARG is executed on exit from the shell.  If a SIGNAL_SPEC\n"
"    is DEBUG, ARG is executed after every simple command.  If the`-p' option\n"
"    is supplied then the trap commands associated with each SIGNAL_SPEC are\n"
"    displayed.  If no arguments are supplied or if only `-p' is given, trap\n"
"    prints the list of commands associated with each signal.  Each SIGNAL_SPEC\n"
"    is either a signal name in <signal.h> or a signal number.  Signal names\n"
"    are case insensitive and the SIG prefix is optional.  `trap -l' prints\n"
"    a list of signal names and their corresponding numbers.  Note that a\n"
"    signal can be sent to the shell with \"kill -signal $$\"."
msgstr ""
"Příkaz ARGUMENT bude načten a proveden, až shell obdrží signál(y)\n"
"    SIGNAL_SPEC. Pokud ARGUMENT chybí (a je zadán jeden SIGNAL_SPEC) nebo je\n"
"    „-“, každý určený signál bude přenastaven zpět na svoji původní hodnotu.\n"
"    Je-li ARGUMENT prázdný řetězec, každý SIGNAL_SPEC bude shellem a příkazy\n"
"    z něj spuštěnými ignorován. Je-li SIGNAL_SPEC „EXIT (0)“, bude příkaz\n"
"    ARGUMENT proveden při ukončování tohoto shellu. Je-li SIGNAL_SPEC „DEBUG“,\n"
"    bude ARGUMENT proveden za každým jednoduchým příkazem. Je-li zadán přepínač\n"
"    „-p“, pak budou zobrazen příkazy navázané na každý SIGNAL_SPEC. Nejsou-li\n"
"    poskytnuty žádné argumenty nebo je-li zadán jen „-p“, vypíše trap seznam\n"
"    příkazů navázaných na všechny signály. Každý SIGNAL_SPEC je buďto jméno\n"
"    signálu z <signal.h>, nebo číslo signálu. U jmen signálů nezáleží na\n"
"    velikosti písmen a předpona SIG je nepovinná. „trap -l“ vypíše seznam\n"
"    jmen signálů a jim odpovídajících čísel. Vezměte na vědomí, že aktuálnímu\n"
"    shellu lze zaslat signál pomocí „kill -signal $$“."

#: builtins.c:1009
msgid ""
"For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    If the -t option is used, `type' outputs a single word which is one of\n"
"    `alias', `keyword', `function', `builtin', `file' or `', if NAME is an\n"
"    alias, shell reserved word, shell function, shell builtin, disk file,\n"
"    or unfound, respectively.\n"
"    \n"
"    If the -p flag is used, `type' either returns the name of the disk\n"
"    file that would be executed, or nothing if `type -t NAME' would not\n"
"    return `file'.\n"
"    \n"
"    If the -a flag is used, `type' displays all of the places that contain\n"
"    an executable named `file'.  This includes aliases, builtins, and\n"
"    functions, if and only if the -p flag is not also used.\n"
"    \n"
"    The -f flag suppresses shell function lookup.\n"
"    \n"
"    The -P flag forces a PATH search for each NAME, even if it is an alias,\n"
"    builtin, or function, and returns the name of the disk file that would\n"
"    be executed."
msgstr ""
"O každém NÁZVU řekne, jak by byl interpretován, kdyby byl použit jako\n"
"    název příkazu.\n"
"    \n"
"    Je-li použit přepínač -t, „type“ vypíše jedno slovo z těchto: „alias“,\n"
"    „keyword“, „function“, „builtin“, „file“ nebo „“, je-li NÁZEV alias,\n"
"    klíčové slovo shellu, shellová funkce, vestavěný příkaz shellu, soubor\n"
"    na disku nebo nenalezený soubor.\n"
"    \n"
"    Je-li použit přepínač -p, „type“ buď vrátí jméno souboru na disku, který\n"
"    by byl spuštěn, nebo nic, pokud „type -t NÁZEV“ by nevrátil „file“.\n"
"    \n"
"    Je-li použit přepínač -a, „type“ zobrazí všechna místa, kde se nalézá\n"
"    spustitelný program pojmenovaný „soubor“. To zahrnuje aliasy, vestavěné\n"
"    příkazy a funkce jen a pouze tehdy, když není rovněž použit přepínač -p.\n"
"    \n"
"    Přepínač -f potlačí hledání mezi funkcemi shellu.\n"
"    \n"
"    Přepínač -P vynutí prohledání PATH na každý NÁZEV, dokonce i když se\n"
"    jedná o alias, vestavěný příkaz nebo funkci, a vrátí název souboru na\n"
"    disku, který by byl spuštěn."

#: builtins.c:1036
msgid ""
"Ulimit provides control over the resources available to processes\n"
"    started by the shell, on systems that allow such control.  If an\n"
"    option is given, it is interpreted as follows:\n"
"    \n"
"        -S\tuse the `soft' resource limit\n"
"        -H\tuse the `hard' resource limit\n"
"        -a\tall current limits are reported\n"
"        -c\tthe maximum size of core files created\n"
"        -d\tthe maximum size of a process's data segment\n"
"        -e\tthe maximum scheduling priority (`nice')\n"
"        -f\tthe maximum size of files written by the shell and its children\n"
"        -i\tthe maximum number of pending signals\n"
"        -l\tthe maximum size a process may lock into memory\n"
"        -m\tthe maximum resident set size\n"
"        -n\tthe maximum number of open file descriptors\n"
"        -p\tthe pipe buffer size\n"
"        -q\tthe maximum number of bytes in POSIX message queues\n"
"        -r\tthe maximum real-time scheduling priority\n"
"        -s\tthe maximum stack size\n"
"        -t\tthe maximum amount of cpu time in seconds\n"
"        -u\tthe maximum number of user processes\n"
"        -v\tthe size of virtual memory\n"
"        -x\tthe maximum number of file locks\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource;\n"
"    the special LIMIT values `soft', `hard', and `unlimited' stand for\n"
"    the current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.\n"
"    If no option is given, then -f is assumed.  Values are in 1024-byte\n"
"    increments, except for -t, which is in seconds, -p, which is in\n"
"    increments of 512 bytes, and -u, which is an unscaled number of\n"
"    processes."
msgstr ""
"Ulimit poskytuje kontrolu nad zdroji dostupnými procesu spuštěného\n"
"    shellem (na systémech, které takovou kontrolu umožňují). Je-li nějaký\n"
"    zadán přepínač, bude interpretován následovně:\n"
"    \n"
"        -S\tpoužije se „měkké“ (soft) omezení zdroje\n"
"        -H\tpoužije se „tvrdé“ (hard) omezení zdroje\n"
"        -a\tnahlásí všechna současná omezení (limity)\n"
"        -c\tmaximální velikost vytvářených core souborů (výpis paměti programu)\n"
"        -d\tmaximální velikost datového segmentu procesu\n"
"        -e\tmaximální plánovací priorita  („nice“)\n"
"        -f\tmaximální velikost souborů zapsaných shellem a jeho potomky\n"
"        -i\tmaximální počet čekajících signálů\n"
"        -l\tmaximální velikost paměti, kterou může proces zamknout\n"
"        -m\tmaximální velikost rezidentní paměti (resident set size)\n"
"        -n\tmaximální počet otevřených deskriptorů souboru\n"
"        -p\tvelikost vyrovnávací paměti rour\n"
"        -q\tmaximální počet bajtů ve frontě posixových zpráv\n"
"        -r\tmaximální priorita plánování v reálném čase\n"
"        -s\tmaximální velikost zásobníku\n"
"        -t\tmaximální množství procesorového času v sekundách\n"
"        -u\tmaximální počet procesů uživatele\n"
"        -v\tvelikost virtuální paměti\n"
"        -x\tmaximální počet zámků na souborech\n"
"    \n"
"    Je-li zadán LIMIT, jedná se o novou hodnotu daného zdroje. Zvláštní\n"
"    hodnoty LIMITU „soft“, „hard“ a „unlimited“ znamenají současný měkký\n"
"    limit, současný tvrdý limit a žádný limit. V opačném případě bude\n"
"    vytištěna současná hodnota limitu daného zdroje. Není-li zadán žádný\n"
"    přepínač, pak se předpokládá -f. Hodnoty jsou v násobcích 1024 bajtů,\n"
"    kromě -t, která je v sekundách, -p, která je v násobcích 512 bajtů,\n"
"    a -u, což je absolutní počet procesů."

#: builtins.c:1074
msgid ""
"The user file-creation mask is set to MODE.  If MODE is omitted, or if\n"
"    `-S' is supplied, the current value of the mask is printed.  The `-S'\n"
"    option makes the output symbolic; otherwise an octal number is output.\n"
"    If `-p' is supplied, and MODE is omitted, the output is in a form\n"
"    that may be used as input.  If MODE begins with a digit, it is\n"
"    interpreted as an octal number, otherwise it is a symbolic mode string\n"
"    like that accepted by chmod(1)."
msgstr ""
"Uživatelská maska práv vytvářených souborů je nastavena na MÓD. Je-li\n"
"    MÓD vynechán nebo je-li uvedeno „-S“, bude vytištěna současná hodnota\n"
"    masky. Přepínač „-S“ učiní výstup symbolický, jinak bude výstupem\n"
"    osmičkové číslo. Je-li zadáno „-p“ a MÓD je vynechán, bude výstup ve\n"
"    formátu, který lze použít jako vstup. Začíná-li MÓD číslicí, bude\n"
"    interpretován jako osmičkové číslo, jinak jako řetězec symbolického zápisu\n"
"    práv tak, jak jej chápe chmod(1)."

#: builtins.c:1087
msgid ""
"Wait for the specified process and report its termination status.  If\n"
"    N is not given, all currently active child processes are waited for,\n"
"    and the return code is zero.  N may be a process ID or a job\n"
"    specification; if a job spec is given, all processes in the job's\n"
"    pipeline are waited for."
msgstr ""
"Počká na zadaný proces a nahlásí jeho návratový kód. Není-li N zadáno,\n"
"    bude se čekat na všechny právě aktivní procesy potomků a návratová hodnota\n"
"    bude nula. N může být ID procesu nebo identifikace úlohy. Je-li odkazováno\n"
"    na úlohu, bude se čekat na všechny procesy v koloně úlohy."

#: builtins.c:1099
msgid ""
"Wait for the specified process and report its termination status.  If\n"
"    N is not given, all currently active child processes are waited for,\n"
"    and the return code is zero.  N is a process ID; if it is not given,\n"
"    all child processes of the shell are waited for."
msgstr ""
"Počká na zadaný proces a nahlásí jeho návratový kód. Není-li N zadáno,\n"
"    bude se čekat na všechny právě aktivní procesy potomků a návratová hodnota\n"
"    bude nula. N je ID procesu. Není-li zadáno, bude se čekat na všechny\n"
"    procesy potomků tohoto shellu."

#: builtins.c:1109
msgid ""
"The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed."
msgstr ""
"Smyčka „for“ provede posloupnost příkazů pro každý prvek v seznamu položek.\n"
"    Pokud „in SLOVECH…;“ není přítomno, pak se předpokládá „in \"$@\"“. NÁZEV\n"
"    bude postupně nastaven na každý prvek ve SLOVECH a PŘÍKAZY provedeny."

#: builtins.c:1118
msgid ""
"Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1."
msgstr ""
"Ekvivalentní k\n"
"    \t(( VÝR1 ))\n"
"    \twhile (( VÝR2 )); do\n"
"    \t\tPŘÍKAZY\n"
"    \t\t(( VÝR3 ))\n"
"    \tdone\n"
"    VÝR1, VÝR2 a VÝR3 jsou aritmetické výrazy.  Chybí-li některý výraz,\n"
"    chová se, jako by byl vyhodnocen na 1."

#: builtins.c:1131
msgid ""
"The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed."
msgstr ""
"SLOVA jsou expandována a vytvoří seznam slov. Množina expandovaných slov\n"
"    je vytištěna na standardní chybový výstup, každé předchází číslo.  Není-li\n"
"    „in SLOVA“ přítomno, předpokládá se „in \"$@\"“. Pak je zobrazena výzva PS3\n"
"    a jeden řádek načten ze standardního vstupu. Pokud je řádek tvořen číslem\n"
"    odpovídajícím jednomu ze zobrazených slov, pak NÁZEV bude nastaven na toto\n"
"    slovo. Pokud je řádek prázdný, SLOVA a výzva budou znovu zobrazeny. Je-li\n"
"    načten EOF (konec souboru), příkaz končí. Načtení jakékoliv jiné hodnoty\n"
"    nastaví NÁZEV na prázdný řetězec. Načtený řádek bude uložen do proměnné\n"
"    REPLY, Po každém výběru budou provedeny PŘÍKAZY, dokud nebude vykonán\n"
"    příkaz „break“."

#: builtins.c:1147
msgid ""
"Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    The return status is the return status of PIPELINE.  The `-p' option\n"
"    prints the timing summary in a slightly different format.  This uses\n"
"    the value of the TIMEFORMAT variable as the output format."
msgstr ""
"Vykoná KOLONU a zobrazí přehled reálného času, uživatelského\n"
"    procesorového času a systémového procesorového času stráveného prováděním\n"
"    KOLONY poté, co skončí. Návratová hodnota je návratová hodnota KOLONY.\n"
"    Přepínač „-p“ zobrazí přehled časů v mírně odlišném formátu. Zde se\n"
"    použije hodnota proměnné TIMEFORMAT jakožto specifikace výstupního formátu."

#: builtins.c:1157
msgid ""
"Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns."
msgstr ""
"Provede PŘÍKAZY vybrané podle shody SLOVA se VZOREM. Znak „|“ se používá\n"
"     na oddělení násobných VZORŮ."

#: builtins.c:1164
msgid ""
"The `if COMMANDS' list is executed.  If its exit status is zero, then the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of the\n"
"    entire construct is the exit status of the last command executed, or zero\n"
"    if no condition tested true."
msgstr ""
"Provede seznam „if PŘÍKAZŮ“. Bude-li jeho návratový kód nula, pak bude\n"
"    proveden seznam „then PŘÍKAZŮ“. Jinak bude proveden popořadě každý seznam\n"
"    „elif PŘÍKAZŮ“ a bude-li jeho návratový kód nula, odpovídající seznam\n"
"    „then PŘÍKAZŮ“ bude proveden a příkaz if skončí. V opačném případě bude\n"
"    proveden seznam „else PŘÍKAZŮ“, pokud existuje. Návratová hodnota celé\n"
"    konstrukce je návratovou hodnotou posledního provedeného příkazu nebo nula,\n"
"    pokud žádná z testovaných podmínek není pravdivá."

#: builtins.c:1176
msgid ""
"Expand and execute COMMANDS as long as the final command in the\n"
"    `while' COMMANDS has an exit status of zero."
msgstr ""
"Expanduje a provádí PŘÍKAZY tak dlouho, dokud poslední příkaz ve „while“\n"
"     PŘÍKAZECH má nulový návratový kód."

#: builtins.c:1183
msgid ""
"Expand and execute COMMANDS as long as the final command in the\n"
"    `until' COMMANDS has an exit status which is not zero."
msgstr ""
"Expanduje a provádí PŘÍKAZY tak dlouho, dokud poslední příkaz ve „until“\n"
"     PŘÍKAZECH má nenulový návratový kód."

#: builtins.c:1190
msgid ""
"Create a simple command invoked by NAME which runs COMMANDS.\n"
"    Arguments on the command line along with NAME are passed to the\n"
"    function as $0 .. $n."
msgstr ""
"Vytvoří jednoduchý příkaz volaný JMÉNEM, který spustí PŘÍKAZY. Argumenty\n"
"    z příkazové řádky spolu se JMÉNEM budou předány do funkce jako $0…$n."

#: builtins.c:1198
msgid ""
"Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands."
msgstr ""
"Spustí množinu příkazů v jedné skupině. Toto je jeden ze způsobů,\n"
"    jak přesměrovat celou množinu příkazů."

#: builtins.c:1205
msgid ""
"Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'."
msgstr ""
"Ekvivalent k argumentu ÚLOHA příkazu „fg“. Obnoví pozastavenou úlohu\n"
"    nebo úlohu na pozadí. ÚLOHA může určovat buď název úlohy, nebo číslo úlohy.\n"
"    Přidání „&“ za ÚLOHU přesune úlohu na pozadí, jako by identifikátor úlohy\n"
"    byl argumentem příkazu „bg“."

#: builtins.c:1215
msgid ""
"The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to \"let EXPRESSION\"."
msgstr ""
"VÝRAZ bude vyhodnocen podle pravidel aritmetického vyhodnocování.\n"
"    Ekvivalentní k „let VÝRAZ“."

#: builtins.c:1222
msgid ""
"Returns a status of 0 or 1 depending on the evaluation of the conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries used\n"
"    by the `test' builtin, and may be combined using the following operators\n"
"    \n"
"    \t( EXPRESSION )\tReturns the value of EXPRESSION\n"
"    \t! EXPRESSION\tTrue if EXPRESSION is false; else false\n"
"    \tEXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"    \tEXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of the\n"
"    operator is used as a pattern and pattern matching is performed.  The\n"
"    && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value."
msgstr ""
"Vrátí status 0 nebo 1 podle vyhodnocení podmíněného výrazu VÝRAZ. Výrazy\n"
"    se skládají ze stejných primitiv jako u vestavěného příkazu „test“ a\n"
"    mohou být kombinovány za pomoci následujících operátorů:\n"
"    \n"
"    \t( VÝRAZ )\tVrátí hodnotu VÝRAZU\n"
"    \t! VÝRAZ\t\tPravda, pokud VÝRAZ je nepravdivý; jinak nepravda\n"
"    \tVÝR1 && VÝR2\tPravda, pokud oba VÝR1 i VÝR2 jsou pravdivé;\n"
"    \t\t\tjinak nepravda\n"
"    \tVÝR1 || VÝR2\tPravda, pokud VÝR1 nebo VÝR2 je pravdivý; jinak nepravda\n"
"    \n"
"    Jsou-li použity operátory „==“ a „!=“, řetězec napravo od operátora je\n"
"    použit jako vzor a bude uplatněno porovnávání proti vzoru. Operátory\n"
"    && a || nevyhodnocují VÝR2, pokud VÝR1 je dostatečný na určení hodnoty\n"
"    výrazu."

#: builtins.c:1240
msgid ""
"BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directries given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"BASH_VERSION\tInformace o verzi v tomto Bashi.\n"
"    CDPATH\tDvojtečkou oddělený seznam adresářů, který se prohledává\n"
"    \t\tna adresáře zadané jako argumenty u „cd“.\n"
"    GLOBIGNORE\tDvojtečkou oddělený seznam vzorů popisujících jména souborů,\n"
"    \t\tkterá budou ignorována při expanzi cest.\n"
"    HISTFILE\tJméno souboru, kde je uložena historie vašich příkazů.\n"
"    HISTFILESIZE\tMaximální počet řádků, které tento soubor smí obsahovat.\n"
"    HISTSIZE\tMaximální počet řádků historie, které jsou dostupné uvnitř\n"
"    \t\tběžícího shellu.\n"
"    HOME\tCelá cesta do vašeho domovského adresáře.\n"
"    HOSTNAME\tJméno současného stroje.\n"
"    HOSTTYPE\tDruh CPU, na kterém tento Bash běží.\n"
"    IGNOREEOF\tŘídí reakci shellu na přijetí znaku EOF (konec souboru)\n"
"    \t\tpři samotném vstupu. Je-li nastaveno, pak její hodnota udává\n"
"    \t\tpočet znaků EOF, které mohou bezprostředně následovat na prázdném\n"
"    \t\třádku, dříve než shell skončí (implicitní hodnota je 10). Není-li\n"
"    \t\tnastaveno, EOF značí konec vstupu.\n"
"    MACHTYPE\tŘetězec popisující systém, na kterém tento Bash běží.\n"
"    MAILCHECK\tJak často, v sekundách, kontroluje Bash novou poštu.\n"
"    MAILPATH\tDvojtečkou oddělený seznam názvů souborů, které Bash\n"
"    \t\tkontroluje na novou poštu.\n"
"    OSTYPE\tVerze Unixu, na kterém tento Bash běží.\n"
"    PATH\tDvojtečkou oddělený seznam adresářů, které jsou prohledávány\n"
"    \t\tna příkazy.\n"
"    PROMPT_COMMAND\tPříkaz, který je proveden před vytištěním každé\n"
"    \t\tprimární výzvy shellu.\n"
"    PS1\t\tŘetězec prvotní výzvy shellu.\n"
"    PS2\t\tŘetězec druhotné výzvy shellu.\n"
"    PWD\t\tCelé jméno cesty do aktuálního adresáře.\n"
"    SHELLOPTS\tDvojtečkou oddělený seznam zapnutých přepínačů shellu.\n"
"    TERM\tNázev druhu současného terminálu.\n"
"    TIMEFORMAT\tVýstupní formát časové statistiky zobrazované vyhrazeným\n"
"    \t\tslovem „time“.\n"
"    auto_resume\tNeprázdná hodnota znamená slovo příkazu objevující se\n"
"    \t\tna řádce automaticky, které je nejprve vyhledáno v seznamu\n"
"    \t\tprávě pozastavených úloh. Je-li tam nalezeno, daná úloha bude\n"
"    \t\tpřepnuta na popředí. Hodnota „exact“ znamená, že slovo příkazu\n"
"    \t\tse musí přesně shodovat s příkazem v seznamu pozastavených úloh.\n"
"    \t\tHodnota „substring“ znamená, že slovo příkazu se musí shodovat\n"
"    \t\ts podřetězcem úlohy. Jakákoliv jiná hodnota znamená, že příkaz\n"
"    \t\tmusí být předponou pozastavené úlohy.\n"
"    histchars\tZnaky řídící expanzi historie a rychlého nahrazování.\n"
"    \t\tPrvní znak je znak nahrazení historie, obvykle „!“. Druhý je\n"
"    \t\tznak „rychlého nahrazování“, obvykle „^“. Třetí je znak\n"
"    \t\t„komentáře historie“, obvykle „#“.\n"
"    HISTIGNORE\tDvojtečkou oddělený seznam vzorů používaný na\n"
"    \t\trozlišení, které příkazy by měly být uloženy do seznamu\n"
"    \t\thistorie.\n"

#: builtins.c:1295
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"    -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"    -n\tsuppress the normal change of directory when adding directories\n"
"    \tto the stack, so only the stack is manipulated.\n"
"    \n"
"    dir\tadds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    You can see the directory stack with the `dirs' command."
msgstr ""
"Přidá adresář na vrchol zásobníku adresářů nebo zásobník zrotuje tak,\n"
"    že nový vrchol zásobníku se stane současným pracovním adresářem. Bez\n"
"    argumentů prohodí dva vrchní adresáře.\n"
"    \n"
"    +N\tZrotuje zásobník tak, že N. adresář (počítáno zleva na seznamu\n"
"    \tzobrazovaném pomocí „dirs“, počínaje nulou) se dostane na vrchol.\n"
"    \n"
"    -N\tZrotuje zásobník tak, že N. adresář (počítáno zprava na seznamu\n"
"    \tzobrazovaném pomocí „dirs“, počínaje nulou) se dostane na vrchol.\n"
"    \n"
"    -n\tpotlačí obvyklou změnu adresáře, když se na zásobník přidávají\n"
"    \tadresáře, takže změněn bude pouze zásobník.\n"
"    \n"
"    adresář\n"
"    \tpřidá ADRESÁŘ na vrchol zásobníku adresářů a učiní jej novým\n"
"    \tsoučasným pracovním adresářem.\n"
"    \n"
"    Zásobník adresářů si můžete prohlédnout příkazem „dirs“."

#: builtins.c:1321
msgid ""
"Removes entries from the directory stack.  With no arguments,\n"
"    removes the top directory from the stack, and cd's to the new\n"
"    top directory.\n"
"    \n"
"    +N\tremoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"    -N\tremoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    -n\tsuppress the normal change of directory when removing directories\n"
"    \tfrom the stack, so only the stack is manipulated.\n"
"    \n"
"    You can see the directory stack with the `dirs' command."
msgstr ""
"Odstraní položku ze zásobníku adresářů. Bez argumentů odstraní adresář\n"
"    z vrcholu zásobníku a provede „cd“ do nového adresáře z vrchu zásobníku.\n"
"    \n"
"    +N\todstraní N. položku počítáno zleva na seznamu zobrazovaném pomocí\n"
"    \t„dirs“, počínaje nulou. Na příklad: „popd +0“ odstraní poslední\n"
"    adresář, „popd -1“ další vedle posledního.\n"
"    \n"
"    -N\todstraní N. položku počítáno zprava na seznamu zobrazovaném pomocí\n"
"    \t„dirs“, počínaje nulou. Na příklad: „popd -0“ odstraní poslední\n"
"    adresář, „popd -1“ další vedle posledního.\n"
"    \n"
"    -n\tpotlačí obvyklou změnu adresáře, když se ze zásobníku odebírají\n"
"    \tadresáře, takže změněn bude pouze zásobník.\n"
"    \n"
"    Zásobník adresářů si můžete prohlédnout příkazem „dirs“."

#: builtins.c:1344
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    The -l flag specifies that `dirs' should not print shorthand versions\n"
"    of directories which are relative to your home directory.  This means\n"
"    that `~/bin' might be displayed as `/homes/bfox/bin'.  The -v flag\n"
"    causes `dirs' to print the directory stack with one entry per line,\n"
"    prepending the directory name with its position in the stack.  The -p\n"
"    flag does the same thing, but the stack position is not prepended.\n"
"    The -c flag clears the directory stack by deleting all of the elements.\n"
"    \n"
"    +N\tdisplays the Nth entry counting from the left of the list shown by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"    -N\tdisplays the Nth entry counting from the right of the list shown by\n"
"    \tdirs when invoked without options, starting with zero."
msgstr ""
"Zobrazí seznam právě zapamatovaných adresářů. Adresáře si najdou svoji\n"
"    cestu na seznam příkazem „pushd“ a procházet seznamem zpět lze příkazem\n"
"    „popd“.    \n"
"    Příznak -l říká, aby „dirs“ nevypisoval zkrácené verze adresářů, které\n"
"    jsou relativní vašemu domovskému adresáři. To znamená, že „~/bin“ může být\n"
"    zobrazeno jako „/homes/bfox/bin“. Příznak -v způsobuje, že „dirs“ vypíše\n"
"    zásobník adresářů po jedné položce na řádek, přičemž názvu adresáře\n"
"    předřadí jeho umístění na zásobníku. Příznak -p dělá tu samou věc, ale\n"
"    umístění na zásobníku předřazeno nebude. Příznak -c vyprázdní zásobník\n"
"    adresářů tím, že smaže všechny jeho prvky.\n"
"    \n"
"    +N\tzobrazí N. položku počítáno zleva na seznamu, který zobrazuje\n"
"    \tdirs, když je vyvolán bez přepínačů, počínaje nulou.\n"
"    \n"
"    -N\tzobrazí N. položku počítáno zprava na seznamu, který zobrazuje\n"
"    \tdirs, když je vyvolán bez přepínačů, počínaje nulou."

#: builtins.c:1367
msgid ""
"Toggle the values of variables controlling optional behavior.\n"
"    The -s flag means to enable (set) each OPTNAME; the -u flag\n"
"    unsets each OPTNAME.  The -q flag suppresses output; the exit\n"
"    status indicates whether each OPTNAME is set or unset.  The -o\n"
"    option restricts the OPTNAMEs to those defined for use with\n"
"    `set -o'.  With no options, or with the -p option, a list of all\n"
"    settable options is displayed, with an indication of whether or\n"
"    not each is set."
msgstr ""
"Přepne hodnoty proměnných řídící volitelné chování. Přepínač -s znamená,\n"
"    že se každý NÁZEV_VOLBY zapne (nastaví). Přepínač -u každý NÁZEV_VOLBY\n"
"    vypne. Přepínač -q potlačí výstup. Zda je nebo není nastaven každý\n"
"    NÁZEV_VOLBY, indikuje návratový kód. Přepínač -o omezí NÁZVY_VOLEB na ty,\n"
"    které jsou definovány pro použití s „set -o“. Bez přepínačů nebo\n"
"    s přepínačem -p je zobrazen seznam všech nastavitelných voleb včetně\n"
"    indikace, zda je každá nastavena."

#: builtins.c:1380
msgid ""
"printf formats and prints ARGUMENTS under control of the FORMAT. FORMAT\n"
"    is a character string which contains three types of objects: plain\n"
"    characters, which are simply copied to standard output, character escape\n"
"    sequences which are converted and copied to the standard output, and\n"
"    format specifications, each of which causes printing of the next successive\n"
"    argument.  In addition to the standard printf(1) formats, %b means to\n"
"    expand backslash escape sequences in the corresponding argument, and %q\n"
"    means to quote the argument in a way that can be reused as shell input.\n"
"    If the -v option is supplied, the output is placed into the value of the\n"
"    shell variable VAR rather than being sent to the standard output."
msgstr ""
"printf naformátuje a vypíše ARGUMENTY podle definice FORMÁTU. FORMÁT\n"
"    je řetězec znaků, který obsahuje tři druhy objektů: obyčejné znaky, které\n"
"    jsou prostě zkopírovány na standardní výstup, posloupnosti escapových\n"
"    znaků, které jsou zkonvertovány a zkopírovány na standardní výstup a\n"
"    formátovací definice, z nichž každá způsobí vytištění dalšího argumentu.\n"
"    Doplňky ke standardním formátům printf(1): %b způsobí expanzi posloupností\n"
"    escapovaných zpětným lomítkem v odpovídajícím argumentu a %q způsobí\n"
"    oescapování argumentu takovým způsobem, že jej bude možné použít jako vstup\n"
"    shellu. Je-li zadán přepínač -v, bude výstup umístěn do proměnné shellu\n"
"    PROMĚNNÁ namísto odeslání na standardní výstup."

#: builtins.c:1396
msgid ""
"For each NAME, specify how arguments are to be completed.\n"
"    If the -p option is supplied, or if no options are supplied, existing\n"
"    completion specifications are printed in a way that allows them to be\n"
"    reused as input.  The -r option removes a completion specification for\n"
"    each NAME, or, if no NAMEs are supplied, all completion specifications."
msgstr ""
"U každého NÁZVU sdělí, jak budou argumenty doplněny. Je-li zadán\n"
"    přepínač -p nebo není-li zadán přepínač žádný, budou existující definice\n"
"    doplňování vytištěny tak. že je bude možné znovu použít jako vstup.\n"
"    Přepínač -r odstraní definici doplnění pro každý NÁZEV nebo chybí-li NÁZVY,\n"
"    odstraní všechny definice."

#: builtins.c:1408
msgid ""
"Display the possible completions depending on the options.  Intended\n"
"    to be used from within a shell function generating possible completions.\n"
"    If the optional WORD argument is supplied, matches against WORD are\n"
"    generated."
msgstr ""
"Zobrazí možná doplnění v závislosti na přepínačích. Je zamýšleno pro\n"
"    použití uvnitř shellových funkcí generujících možná doplnění. Je-li\n"
"    poskytnut volitelný argument SLOVO, budou vygenerovány shody proti SLOVU."
