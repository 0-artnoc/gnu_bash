*** ../bash-3.0/lib/readline/display.c	Thu May 27 22:57:51 2004
--- lib/readline/display.c	Mon Aug 30 11:55:02 2004
***************
*** 202,206 ****
  {
    char *r, *ret, *p;
!   int l, rl, last, ignoring, ninvis, invfl, ind, pind, physchars;
  
    /* Short-circuit if we can. */
--- 202,206 ----
  {
    char *r, *ret, *p;
!   int l, rl, last, ignoring, ninvis, invfl, invflset, ind, pind, physchars;
  
    /* Short-circuit if we can. */
***************
*** 223,226 ****
--- 223,227 ----
  
    invfl = 0;	/* invisible chars in first line of prompt */
+   invflset = 0;	/* we only want to set invfl once */
  
    for (rl = ignoring = last = ninvis = physchars = 0, p = pmt; p && *p; p++)
***************
*** 250,254 ****
  	        *r++ = *p++;
  	      if (!ignoring)
! 		rl += ind - pind;
  	      else
  		ninvis += ind - pind;
--- 251,258 ----
  	        *r++ = *p++;
  	      if (!ignoring)
! 		{
! 		  rl += ind - pind;
! 		  physchars += _rl_col_width (pmt, pind, ind);
! 		}
  	      else
  		ninvis += ind - pind;
***************
*** 260,273 ****
  	      *r++ = *p;
  	      if (!ignoring)
! 		rl++;			/* visible length byte counter */
  	      else
  		ninvis++;		/* invisible chars byte counter */
  	    }
  
! 	  if (rl >= _rl_screenwidth)
! 	    invfl = ninvis;
! 
! 	  if (ignoring == 0)
! 	    physchars++;
  	}
      }
--- 264,280 ----
  	      *r++ = *p;
  	      if (!ignoring)
! 		{
! 		  rl++;			/* visible length byte counter */
! 		  physchars++;
! 		}
  	      else
  		ninvis++;		/* invisible chars byte counter */
  	    }
  
! 	  if (invflset == 0 && rl >= _rl_screenwidth)
! 	    {
! 	      invfl = ninvis;
! 	      invflset = 1;
! 	    }
  	}
      }
***************
*** 352,356 ****
  				       &prompt_last_invisible,
  				       (int *)NULL,
! 				       (int *)NULL);
        c = *t; *t = '\0';
        /* The portion of the prompt string up to and including the
--- 359,363 ----
  				       &prompt_last_invisible,
  				       (int *)NULL,
! 				       &prompt_physical_chars);
        c = *t; *t = '\0';
        /* The portion of the prompt string up to and including the
***************
*** 359,363 ****
  						   (int *)NULL,
  						   &prompt_invis_chars_first_line,
! 						   &prompt_physical_chars);
        *t = c;
        return (prompt_prefix_length);
--- 366,370 ----
  						   (int *)NULL,
  						   &prompt_invis_chars_first_line,
! 						   (int *)NULL);
        *t = c;
        return (prompt_prefix_length);
***************
*** 418,422 ****
    register char *line;
    int c_pos, inv_botlin, lb_botlin, lb_linenum;
!   int newlines, lpos, temp, modmark;
    char *prompt_this_line;
  #if defined (HANDLE_MULTIBYTE)
--- 425,429 ----
    register char *line;
    int c_pos, inv_botlin, lb_botlin, lb_linenum;
!   int newlines, lpos, temp, modmark, n0, num;
    char *prompt_this_line;
  #if defined (HANDLE_MULTIBYTE)
***************
*** 574,577 ****
--- 581,585 ----
  #if defined (HANDLE_MULTIBYTE)
    memset (_rl_wrapped_line, 0, vis_lbsize);
+   num = 0;
  #endif
  
***************
*** 592,596 ****
--- 600,619 ----
           prompts that exceed two physical lines?
           Additional logic fix from Edward Catmur <ed@catmur.co.uk> */
+ #if defined (HANDLE_MULTIBYTE)
+       n0 = num;
+       temp = local_prompt ? strlen (local_prompt) : 0;
+       while (num < temp)
+ 	{
+ 	  if (_rl_col_width  (local_prompt, n0, num) > _rl_screenwidth)
+ 	    {
+ 	      num = _rl_find_prev_mbchar (local_prompt, num, MB_FIND_ANY);
+ 	      break;
+ 	    }
+ 	  num++;
+ 	}
+       temp = num +
+ #else
        temp = ((newlines + 1) * _rl_screenwidth) +
+ #endif /* !HANDLE_MULTIBYTE */
               ((local_prompt_prefix == 0) ? ((newlines == 0) ? prompt_invis_chars_first_line
  							    : ((newlines == 1) ? wrap_offset : 0))
***************
*** 598,602 ****
--- 621,629 ----
               
        inv_lbreaks[++newlines] = temp;
+ #if defined (HANDLE_MULTIBYTE)
+       lpos -= _rl_col_width (local_prompt, n0, num);
+ #else
        lpos -= _rl_screenwidth;
+ #endif
      }
  
