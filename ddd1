*** ../bash-20111118/lib/readline/complete.c	2011-10-02 14:18:22.000000000 -0400
--- lib/readline/complete.c	2011-11-26 16:01:20.000000000 -0500
***************
*** 31,36 ****
--- 31,38 ----
  #  include <sys/file.h>
  #endif
  
+ #include <signal.h>
+ 
  #if defined (HAVE_UNISTD_H)
  #  include <unistd.h>
  #endif /* HAVE_UNISTD_H */
***************
*** 105,110 ****
--- 107,114 ----
  
  static char *rl_quote_filename PARAMS((char *, int, char *));
  
+ static void _rl_complete_sigcleanup PARAMS((int, void *));
+ 
  static void set_completion_defaults PARAMS((int));
  static int get_y_or_n PARAMS((int));
  static int _rl_internal_pager PARAMS((int));
***************
*** 459,464 ****
--- 463,477 ----
    rl_completion_quote_character = 0;
  }
  
+ static void
+ _rl_complete_sigcleanup (sig, ptr)
+      int sig;
+      void *ptr;
+ {
+   if (sig == SIGINT)	/* XXX - for now */
+     _rl_free_match_list ((char **)ptr);
+ }
+ 
  /* Set default values for readline word completion.  These are the variables
     that application completion functions can change or inspect. */
  static void
***************
*** 1060,1073 ****
       variable rl_attempted_completion_function. */
    if (rl_attempted_completion_function)
      {
- #if 0
-       _rl_interrupt_immediately++;
- #endif
        matches = (*rl_attempted_completion_function) (text, start, end);
! #if 0
!       if (_rl_interrupt_immediately > 0)
! 	_rl_interrupt_immediately--;
! #endif
  
        if (matches || rl_attempted_completion_over)
  	{
--- 1073,1085 ----
       variable rl_attempted_completion_function. */
    if (rl_attempted_completion_function)
      {
        matches = (*rl_attempted_completion_function) (text, start, end);
!       if (RL_SIG_RECEIVED())
! 	{
! 	  _rl_free_match_list (matches);
! 	  matches = 0;
! 	  RL_CHECK_SIGNALS ();
! 	}
  
        if (matches || rl_attempted_completion_over)
  	{
***************
*** 1078,1084 ****
--- 1090,1104 ----
  
    /* XXX -- filename dequoting moved into rl_filename_completion_function */
  
+   /* rl_completion_matches will check for signals as well to avoid a long
+      delay while reading a directory. */
    matches = rl_completion_matches (text, our_func);
+   if (RL_SIG_RECEIVED())
+     {
+       _rl_free_match_list (matches);
+       matches = 0;
+       RL_CHECK_SIGNALS ();
+     }
    return matches;  
  }
  
***************
*** 1838,1847 ****
    /* nontrivial_lcd is set if the common prefix adds something to the word
       being completed. */
    nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;
- #if 1
    if (what_to_do == '!' || what_to_do == '@')
      tlen = strlen (text);
- #endif
    xfree (text);
  
    if (matches == 0)
--- 1858,1865 ----
***************
*** 1875,1884 ****
      case '!':
      case '@':
        /* Insert the first match with proper quoting. */
- #if 0
-       if (*matches[0])
- 	insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
- #else
        if (what_to_do == TAB)
          {
            if (*matches[0])
--- 1893,1898 ----
***************
*** 1893,1899 ****
  	  if (mlen >= tlen)
  	    insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);
  	}
- #endif
  
        /* If there are more matches, ring the bell to indicate.
  	 If we are in vi mode, Posix.2 says to not ring the bell.
--- 1907,1912 ----
***************
*** 1929,1935 ****
--- 1942,1955 ----
        break;
  
      case '?':
+       if (rl_completion_display_matches_hook == 0)
+ 	{
+ 	  _rl_sigcleanup = _rl_complete_sigcleanup;
+ 	  _rl_sigcleanarg = matches;
+ 	}
        display_matches (matches);
+       _rl_sigcleanup = 0;
+       _rl_sigcleanarg = 0;
        break;
  
      default:
***************
*** 1937,1942 ****
--- 1957,1963 ----
        rl_ding ();
        FREE (saved_line_buffer);
        RL_UNSETSTATE(RL_STATE_COMPLETING);
+       _rl_free_match_list (matches);
        _rl_reset_completion_state ();
        return 1;
      }
***************
*** 1978,1983 ****
--- 1999,2006 ----
       const char *text;
       rl_compentry_func_t *entry_function;
  {
+   register int i;
+ 
    /* Number of slots in match_list. */
    int match_list_size;
  
***************
*** 1995,2005 ****
    match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));
    match_list[1] = (char *)NULL;
  
- #if 0
-   _rl_interrupt_immediately++;
- #endif
    while (string = (*entry_function) (text, matches))
      {
        if (matches + 1 == match_list_size)
  	match_list = (char **)xrealloc
  	  (match_list, ((match_list_size += 10) + 1) * sizeof (char *));
--- 2018,2042 ----
    match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));
    match_list[1] = (char *)NULL;
  
    while (string = (*entry_function) (text, matches))
      {
+       if (RL_SIG_RECEIVED ())
+ 	{
+ 	  /* Start at 1 because we don't set matches[0] in this function.
+ 	     Only free the list members if we're building match list from
+ 	     rl_filename_completion_function, since we know that doesn't
+ 	     free the strings it returns. */
+ 	  if (entry_function == rl_filename_completion_function)
+ 	    {
+ 	      for (i = 1; match_list[i]; i++)
+ 		xfree (match_list[i]);
+ 	    }
+ 	  xfree (match_list);
+ 	  match_list = 0;
+ 	  match_list_size = 0;
+ 	  RL_CHECK_SIGNALS ();
+ 	}
+ 
        if (matches + 1 == match_list_size)
  	match_list = (char **)xrealloc
  	  (match_list, ((match_list_size += 10) + 1) * sizeof (char *));
***************
*** 2007,2016 ****
        match_list[++matches] = string;
        match_list[matches + 1] = (char *)NULL;
      }
- #if 0
-   if (_rl_interrupt_immediately > 0)
-     _rl_interrupt_immediately--;
- #endif
  
    /* If there were any matches, then look through them finding out the
       lowest common denominator.  That then becomes match_list[0]. */
--- 2044,2049 ----
