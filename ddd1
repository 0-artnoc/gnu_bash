*** ../bash-4.2-patched/lib/readline/readline.c	2010-07-25 17:07:40.000000000 -0400
--- lib/readline/readline.c	2013-07-21 15:52:16.000000000 -0400
***************
*** 2,6 ****
     with emacs style editing and completion. */
  
! /* Copyright (C) 1987-2009 Free Software Foundation, Inc.
  
     This file is part of the GNU Readline Library (Readline), a library
--- 2,6 ----
     with emacs style editing and completion. */
  
! /* Copyright (C) 1987-2013 Free Software Foundation, Inc.
  
     This file is part of the GNU Readline Library (Readline), a library
***************
*** 113,117 ****
  Keymap _rl_keymap = emacs_standard_keymap;
  
- 
  /* The current style of editing. */
  int rl_editing_mode = emacs_mode;
--- 113,116 ----
***************
*** 246,249 ****
--- 245,267 ----
  _rl_keyseq_cxt *_rl_kscxt = 0;
  
+ int rl_executing_key;
+ char *rl_executing_keyseq = 0;
+ int _rl_executing_keyseq_size = 0;
+ 
+ /* Timeout (specified in milliseconds) when reading characters making up an
+    ambiguous multiple-key sequence */
+ int _rl_keyseq_timeout = 500;
+ 
+ #define RESIZE_KEYSEQ_BUFFER() \
+   do \
+     { \
+       if (rl_key_sequence_length + 2 >= _rl_executing_keyseq_size) \
+ 	{ \
+ 	  _rl_executing_keyseq_size += 16; \
+ 	  rl_executing_keyseq = xrealloc (rl_executing_keyseq, _rl_executing_keyseq_size); \
+ 	} \
+     } \
+   while (0);
+         
  /* Forward declarations used by the display, termcap, and history code. */
  
***************
*** 280,283 ****
--- 298,305 ----
  int _rl_echo_control_chars = 1;
  
+ /* Non-zero means to prefix the displayed prompt with a character indicating
+    the editing mode: @ for emacs, : for vi-command, + for vi-insert. */
+ int _rl_show_mode_in_prompt = 0;
+ 
  /* **************************************************************** */
  /*								    */
***************
*** 353,356 ****
--- 375,383 ----
  #endif
  
+ #if HAVE_DECL_AUDIT_TTY && defined (ENABLE_TTY_AUDIT_SUPPORT)
+   if (value)
+     _rl_audit_tty (value);
+ #endif
+ 
    return (value);
  }
***************
*** 370,376 ****
--- 397,413 ----
    _rl_out_stream = rl_outstream;
  
+   /* Enable the meta key only for the duration of readline(), if this
+      terminal has one and the terminal has been initialized */
+   if (_rl_enable_meta & RL_ISSTATE (RL_STATE_TERMPREPPED))
+     _rl_enable_meta_key ();
+ 
    if (rl_startup_hook)
      (*rl_startup_hook) ();
  
+ #if defined (VI_MODE)
+   if (rl_editing_mode == vi_mode)
+     rl_vi_insertion_mode (1, 'i');	/* don't want to reset last */
+ #endif /* VI_MODE */
+ 
    /* If we're not echoing, we still want to at least print a prompt, because
       rl_redisplay will not do it for us.  If the calling application has a
***************
*** 395,403 ****
      }
  
- #if defined (VI_MODE)
-   if (rl_editing_mode == vi_mode)
-     rl_vi_insert_mode (1, 'i');
- #endif /* VI_MODE */
- 
    if (rl_pre_input_hook)
      (*rl_pre_input_hook) ();
--- 432,435 ----
***************
*** 438,441 ****
--- 470,478 ----
      rl_free_undo_list ();
  
+   /* Disable the meta key, if this terminal has one and we were told to use it.
+      The check whether or not we sent the enable string is in
+      _rl_disable_meta_key(); the flag is set in _rl_enable_meta_key */
+   _rl_disable_meta_key ();
+ 
    /* Restore normal cursor, if available. */
    _rl_set_insert_mode (RL_IM_INSERT, 0);
***************
*** 493,497 ****
--- 530,538 ----
        lk = _rl_last_command_was_kill;
  
+ #if defined (HAVE_POSIX_SIGSETJMP)
+       code = sigsetjmp (_rl_top_level, 0);
+ #else
        code = setjmp (_rl_top_level);
+ #endif
  
        if (code)
***************
*** 512,515 ****
--- 553,557 ----
  	  _rl_reset_argument ();
  	  rl_key_sequence_length = 0;
+ 	  rl_executing_keyseq[0] = 0;
  	}
  
***************
*** 520,524 ****
        /* look at input.c:rl_getc() for the circumstances under which this will
  	 be returned; punt immediately on read error without converting it to
! 	 a newline. */
        if (c == READERR)
  	{
--- 562,567 ----
        /* look at input.c:rl_getc() for the circumstances under which this will
  	 be returned; punt immediately on read error without converting it to
! 	 a newline; assume that rl_read_key has already called the signal
! 	 handler. */
        if (c == READERR)
  	{
***************
*** 532,536 ****
  	}
  
!       /* EOF typed to a non-blank line is a <NL>. */
        if (c == EOF && rl_end)
  	c = NEWLINE;
--- 575,581 ----
  	}
  
!       /* EOF typed to a non-blank line is a <NL>.  If we want to change this,
! 	 to force any existing line to be ignored when read(2) reads EOF,
! 	 for example, this is the place to change. */
        if (c == EOF && rl_end)
  	c = NEWLINE;
***************
*** 744,750 ****
  	  if (RL_ISSTATE (RL_STATE_MACRODEF))
  	    _rl_add_macro_char (ESC);
  	  map = FUNCTION_TO_KEYMAP (map, ESC);
  	  key = UNMETA (key);
- 	  rl_key_sequence_length += 2;
  	  return (_rl_dispatch (key, map));
  	}
--- 789,796 ----
  	  if (RL_ISSTATE (RL_STATE_MACRODEF))
  	    _rl_add_macro_char (ESC);
+ 	  RESIZE_KEYSEQ_BUFFER ();
+ 	  rl_executing_keyseq[rl_key_sequence_length++] = ESC;
  	  map = FUNCTION_TO_KEYMAP (map, ESC);
  	  key = UNMETA (key);
  	  return (_rl_dispatch (key, map));
  	}
***************
*** 766,776 ****
  	  /* Special case rl_do_lowercase_version (). */
  	  if (func == rl_do_lowercase_version)
  	    return (_rl_dispatch (_rl_to_lower (key), map));
  
  	  rl_executing_keymap = map;
  
  	  rl_dispatching = 1;
  	  RL_SETSTATE(RL_STATE_DISPATCHING);
! 	  (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
  	  RL_UNSETSTATE(RL_STATE_DISPATCHING);
  	  rl_dispatching = 0;
--- 812,828 ----
  	  /* Special case rl_do_lowercase_version (). */
  	  if (func == rl_do_lowercase_version)
+ 	    /* Should we do anything special if key == ANYOTHERKEY? */
  	    return (_rl_dispatch (_rl_to_lower (key), map));
  
  	  rl_executing_keymap = map;
+ 	  rl_executing_key = key;
+ 
+ 	  RESIZE_KEYSEQ_BUFFER();
+ 	  rl_executing_keyseq[rl_key_sequence_length++] = key;
+ 	  rl_executing_keyseq[rl_key_sequence_length] = '\0';
  
  	  rl_dispatching = 1;
  	  RL_SETSTATE(RL_STATE_DISPATCHING);
! 	  r = (*func) (rl_numeric_arg * rl_arg_sign, key);
  	  RL_UNSETSTATE(RL_STATE_DISPATCHING);
  	  rl_dispatching = 0;
***************
*** 789,793 ****
  	     shadow function that was overridden when the current keymap
  	     was created.  Return -2 to note  that. */
! 	  _rl_unget_char  (key);
  	  return -2;
  	}
--- 841,848 ----
  	     shadow function that was overridden when the current keymap
  	     was created.  Return -2 to note  that. */
! 	  if (RL_ISSTATE (RL_STATE_MACROINPUT))
! 	    _rl_prev_macro_key ();
! 	  else
! 	    _rl_unget_char  (key);
  	  return -2;
  	}
***************
*** 798,802 ****
  	     we need to back up the recursion chain and find the last
  	     subsequence that is bound to a function. */
! 	  _rl_unget_char (key);
  	  return -1;
  	}
--- 853,860 ----
  	     we need to back up the recursion chain and find the last
  	     subsequence that is bound to a function. */
! 	  if (RL_ISSTATE (RL_STATE_MACROINPUT))
! 	    _rl_prev_macro_key ();
! 	  else
! 	    _rl_unget_char (key);
  	  return -1;
  	}
***************
*** 821,831 ****
  	     will be if an arrow key has been pressed, and, if there's not,
  	     just dispatch to (what we assume is) rl_vi_movement_mode right
! 	     away.  This is essentially an input test with a zero timeout. */
  	  if (rl_editing_mode == vi_mode && key == ESC && map == vi_insertion_keymap
! 	      && _rl_input_queued (0) == 0)
  	    return (_rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key)));
  #endif
  
! 	  rl_key_sequence_length++;
  	  _rl_dispatching_keymap = FUNCTION_TO_KEYMAP (map, key);
  
--- 879,893 ----
  	     will be if an arrow key has been pressed, and, if there's not,
  	     just dispatch to (what we assume is) rl_vi_movement_mode right
! 	     away.  This is essentially an input test with a zero timeout (by
! 	     default) or a timeout determined by the value of `keyseq-timeout' */
! 	  /* _rl_keyseq_timeout specified in milliseconds; _rl_input_queued
! 	     takes microseconds, so multiply by 1000 */
  	  if (rl_editing_mode == vi_mode && key == ESC && map == vi_insertion_keymap
! 	      && _rl_input_queued ((_rl_keyseq_timeout > 0) ? _rl_keyseq_timeout*1000 : 0) == 0)
  	    return (_rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key)));
  #endif
  
! 	  RESIZE_KEYSEQ_BUFFER ();
! 	  rl_executing_keyseq[rl_key_sequence_length++] = key;
  	  _rl_dispatching_keymap = FUNCTION_TO_KEYMAP (map, key);
  
***************
*** 856,859 ****
--- 918,933 ----
  #endif
  
+ 	  /* Tentative inter-character timeout for potential multi-key
+ 	     sequences?  If no input within timeout, abort sequence and
+ 	     act as if we got non-matching input. */
+ 	  /* _rl_keyseq_timeout specified in milliseconds; _rl_input_queued
+ 	     takes microseconds, so multiply by 1000 */
+ 	  if (_rl_keyseq_timeout > 0 &&
+ 	  	(RL_ISSTATE (RL_STATE_INPUTPENDING|RL_STATE_MACROINPUT) == 0) &&
+ 	  	_rl_pushed_input_available () == 0 &&
+ 		_rl_dispatching_keymap[ANYOTHERKEY].function &&
+ 		_rl_input_queued (_rl_keyseq_timeout*1000) == 0)
+ 	    return (_rl_subseq_result (-2, map, key, got_subseq));
+ 
  	  newkey = _rl_subseq_getchar (key);
  	  if (newkey < 0)
***************
*** 876,879 ****
--- 950,954 ----
        if (map[key].function != 0)
  	{
+ 	  rl_executing_keyseq[rl_key_sequence_length] = '\0';
  	  macro = savestring ((char *)map[key].function);
  	  _rl_with_macro_input (macro);
***************
*** 885,888 ****
--- 960,964 ----
    if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap &&
        key != ANYOTHERKEY &&
+       rl_key_sequence_length == 1 &&	/* XXX */
        _rl_vi_textmod_command (key))
      _rl_vi_set_last (key, rl_numeric_arg, rl_arg_sign);
***************
*** 936,940 ****
  	 tell the caller that it should try ANYOTHERKEY for an
  	 overridden function. */
!       _rl_unget_char (key);
        _rl_dispatching_keymap = map;
        return -2;
--- 1012,1019 ----
  	 tell the caller that it should try ANYOTHERKEY for an
  	 overridden function. */
!       if (RL_ISSTATE (RL_STATE_MACROINPUT))
! 	_rl_prev_macro_key ();
!       else
! 	_rl_unget_char (key);
        _rl_dispatching_keymap = map;
        return -2;
***************
*** 943,947 ****
      {
        /* OK, back up the chain. */
!       _rl_unget_char (key);
        _rl_dispatching_keymap = map;
        return -1;
--- 1022,1029 ----
      {
        /* OK, back up the chain. */
!       if (RL_ISSTATE (RL_STATE_MACROINPUT))
! 	_rl_prev_macro_key ();
!       else
! 	_rl_unget_char (key);
        _rl_dispatching_keymap = map;
        return -1;
***************
*** 1092,1103 ****
    bind_arrow_keys ();
  
-   /* Enable the meta key, if this terminal has one. */
-   if (_rl_enable_meta)
-     _rl_enable_meta_key ();
- 
    /* If the completion parser's default word break characters haven't
       been set yet, then do so now. */
    if (rl_completer_word_break_characters == (char *)NULL)
      rl_completer_word_break_characters = (char *)rl_basic_word_break_characters;
  }
  
--- 1174,1190 ----
    bind_arrow_keys ();
  
    /* If the completion parser's default word break characters haven't
       been set yet, then do so now. */
    if (rl_completer_word_break_characters == (char *)NULL)
      rl_completer_word_break_characters = (char *)rl_basic_word_break_characters;
+ 
+ #if defined (COLOR_SUPPORT)
+   if (_rl_colored_stats)
+     _rl_parse_colors ();
+ #endif
+ 
+   rl_executing_keyseq = malloc (_rl_executing_keyseq_size = 16);
+   if (rl_executing_keyseq)
+     rl_executing_keyseq[0] = '\0';
  }
  
***************
*** 1160,1163 ****
--- 1247,1254 ----
    rl_bind_keyseq_if_unbound ("\340M", rl_forward_char);
    rl_bind_keyseq_if_unbound ("\340K", rl_backward_char);
+   rl_bind_keyseq_if_unbound ("\340G", rl_beg_of_line);
+   rl_bind_keyseq_if_unbound ("\340O", rl_end_of_line);
+   rl_bind_keyseq_if_unbound ("\340S", rl_delete);
+   rl_bind_keyseq_if_unbound ("\340R", rl_overwrite_mode);  
  #endif
  
