*** ../bash-4.2-patched/execute_cmd.c	2012-05-02 12:02:27.000000000 -0400
--- execute_cmd.c	2012-07-28 18:14:33.000000000 -0400
***************
*** 1,5 ****
  /* execute_cmd.c -- Execute a COMMAND structure. */
  
! /* Copyright (C) 1987-2010 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
--- 1,5 ----
  /* execute_cmd.c -- Execute a COMMAND structure. */
  
! /* Copyright (C) 1987-2012 Free Software Foundation, Inc.
  
     This file is part of GNU Bash, the Bourne Again SHell.
***************
*** 119,122 ****
--- 119,124 ----
  #endif
  
+ extern int job_control;	/* XXX */
+ 
  extern int close __P((int));
  
***************
*** 196,200 ****
  static int execute_connection __P((COMMAND *, int, int, int, struct fd_bitmap *));
  
! static int execute_intern_function __P((WORD_DESC *, COMMAND *));
  
  /* Set to 1 if fd 0 was the subject of redirection to a subshell.  Global
--- 198,202 ----
  static int execute_connection __P((COMMAND *, int, int, int, struct fd_bitmap *));
  
! static int execute_intern_function __P((WORD_DESC *, FUNCTION_DEF *));
  
  /* Set to 1 if fd 0 was the subject of redirection to a subshell.  Global
***************
*** 273,277 ****
  static int showing_function_line;
  
! static int line_number_for_err_trap;
  
  /* A sort of function nesting level counter */
--- 275,281 ----
  static int showing_function_line;
  
! /* $LINENO ($BASH_LINENO) for use by an ERR trap.  Global so parse_and_execute
!    can save and restore it. */
! int line_number_for_err_trap;
  
  /* A sort of function nesting level counter */
***************
*** 531,534 ****
--- 535,542 ----
    volatile int last_pid;
    volatile int save_line_number;
+ #if defined (PROCESS_SUBSTITUTION)
+   volatile int ofifo, nfifo, osize, saved_fifo;
+   volatile char *ofifo_list;
+ #endif
  
  #if 0
***************
*** 593,597 ****
  
  #if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
! 	  unlink_fifo_list ();
  #endif
  	  /* If we are part of a pipeline, and not the end of the pipeline,
--- 601,606 ----
  
  #if defined (PROCESS_SUBSTITUTION) && defined (HAVE_DEV_FD)
! 	  if (variable_context == 0)	/* wait until shell function completes */
! 	    unlink_fifo_list ();
  #endif
  	  /* If we are part of a pipeline, and not the end of the pipeline,
***************
*** 670,673 ****
--- 679,693 ----
      stdin_redir = stdin_redirects (command->redirects);
  
+ #if defined (PROCESS_SUBSTITUTION)
+   if (variable_context != 0)
+     {
+       ofifo = num_fifos ();
+       ofifo_list = copy_fifo_list (&osize);
+       saved_fifo = 1;
+     }
+   else
+     saved_fifo = 0;
+ #endif
+ 
    /* Handle WHILE FOR CASE etc. with redirections.  (Also '&' input
       redirection.)  */
***************
*** 677,680 ****
--- 697,704 ----
        redirection_undo_list = (REDIRECT *)NULL;
        dispose_exec_redirects ();
+ #if defined (PROCESS_SUBSTITUTION)
+       if (saved_fifo)
+ 	free (ofifo_list);
+ #endif
        return (last_command_exit_value = EXECUTION_FAILURE);
      }
***************
*** 752,758 ****
  
  	/* XXX - this is something to watch out for if there are problems
! 	   when the shell is compiled without job control. */
! 	if (already_making_children && pipe_out == NO_PIPE &&
! 	    last_made_pid != last_pid)
  	  {
  	    stop_pipeline (asynchronous, (COMMAND *)NULL);
--- 776,784 ----
  
  	/* XXX - this is something to watch out for if there are problems
! 	   when the shell is compiled without job control.  Don't worry about
! 	   whether or not last_made_pid == last_pid; already_making_children
! 	   tells us whether or not there are unwaited-for children to wait
! 	   for and reap. */
! 	if (already_making_children && pipe_out == NO_PIPE)
  	  {
  	    stop_pipeline (asynchronous, (COMMAND *)NULL);
***************
*** 952,956 ****
      case cm_function_def:
        exec_result = execute_intern_function (command->value.Function_def->name,
! 					     command->value.Function_def->command);
        break;
  
--- 978,982 ----
      case cm_function_def:
        exec_result = execute_intern_function (command->value.Function_def->name,
! 					     command->value.Function_def);
        break;
  
***************
*** 971,974 ****
--- 997,1010 ----
      discard_unwind_frame ("loop_redirections");
  
+ #if defined (PROCESS_SUBSTITUTION)
+   if (saved_fifo)
+     {
+       nfifo = num_fifos ();
+       if (nfifo > ofifo)
+ 	close_new_fifos (ofifo_list, osize);
+       free (ofifo_list);
+     }
+ #endif
+ 
    /* Invert the return value if we have to */
    if (invert)
***************
*** 1001,1004 ****
--- 1037,1041 ----
  #endif
      currently_executing_command = (COMMAND *)NULL;
+ 
    return (last_command_exit_value);
  }
***************
*** 1223,1227 ****
  #endif
  
!   posix_time = (command->flags & CMD_TIME_POSIX);
  
    nullcmd = (command == 0) || (command->type == cm_simple && command->value.Simple->words == 0 && command->value.Simple->redirects == 0);
--- 1260,1264 ----
  #endif
  
!   posix_time = command && (command->flags & CMD_TIME_POSIX);
  
    nullcmd = (command == 0) || (command->type == cm_simple && command->value.Simple->words == 0 && command->value.Simple->redirects == 0);
***************
*** 1505,1509 ****
      return_code = return_catch_value;
    else
!     return_code = execute_command_internal (tcom, asynchronous, NO_PIPE, NO_PIPE, fds_to_close);
  
    /* If we are asked to, invert the return value. */
--- 1542,1546 ----
      return_code = return_catch_value;
    else
!     return_code = execute_command_internal ((COMMAND *)tcom, asynchronous, NO_PIPE, NO_PIPE, fds_to_close);
  
    /* If we are asked to, invert the return value. */
***************
*** 1549,1556 ****
  static void cpl_reap __P((void));
  static void cpl_flush __P((void));
  static struct cpelement *cpl_search __P((pid_t));
! static struct cpelement *cpl_searchbyname __P((char *));
  static void cpl_prune __P((void));
  
  Coproc sh_coproc = { 0, NO_PID, -1, -1, 0, 0, 0, 0 };
  
--- 1586,1597 ----
  static void cpl_reap __P((void));
  static void cpl_flush __P((void));
+ static void cpl_closeall __P((void));
  static struct cpelement *cpl_search __P((pid_t));
! static struct cpelement *cpl_searchbyname __P((const char *));
  static void cpl_prune __P((void));
  
+ static void coproc_free __P((struct coproc *));
+ 
+ /* Will go away when there is fully-implemented support for multiple coprocs. */
  Coproc sh_coproc = { 0, NO_PID, -1, -1, 0, 0, 0, 0 };
  
***************
*** 1639,1668 ****
  cpl_reap ()
  {
!   struct cpelement *prev, *p;
  
!   for (prev = p = coproc_list.head; p; prev = p, p = p->next)
!     if (p->coproc->c_flags & COPROC_DEAD)
!       {
!         prev->next = p->next;	/* remove from list */
! 
! 	/* Housekeeping in the border cases. */
! 	if (p == coproc_list.head)
! 	  coproc_list.head = coproc_list.head->next;
! 	else if (p == coproc_list.tail)
! 	  coproc_list.tail = prev;
! 
! 	coproc_list.ncoproc--;
! 	if (coproc_list.ncoproc == 0)
! 	  coproc_list.head = coproc_list.tail = 0;
! 	else if (coproc_list.ncoproc == 1)
! 	  coproc_list.tail = coproc_list.head;		/* just to make sure */
  
  #if defined (DEBUG)
! 	itrace("cpl_reap: deleting %d", p->coproc->c_pid);
  #endif
  
! 	coproc_dispose (p->coproc);
! 	cpe_dispose (p);
!       }
  }
  
--- 1680,1722 ----
  cpl_reap ()
  {
!   struct cpelement *p, *next, *nh, *nt;
  
!   /* Build a new list by removing dead coprocs and fix up the coproc_list
!      pointers when done. */
!   nh = nt = next = (struct cpelement *)0;
!   for (p = coproc_list.head; p; p = next)
!     {
!       next = p->next;
!       if (p->coproc->c_flags & COPROC_DEAD)
! 	{
! 	  coproc_list.ncoproc--;	/* keep running count, fix up pointers later */
  
  #if defined (DEBUG)
! 	  itrace("cpl_reap: deleting %d", p->coproc->c_pid);
  #endif
  
! 	  coproc_dispose (p->coproc);
! 	  cpe_dispose (p);
! 	}
!       else if (nh == 0)
! 	nh = nt = p;
!       else
! 	{
! 	  nt->next = p;
! 	  nt = nt->next;
! 	}
!     }
! 
!   if (coproc_list.ncoproc == 0)
!     coproc_list.head = coproc_list.tail = 0;
!   else
!     {
!       if (nt)
!         nt->next = 0;
!       coproc_list.head = nh;
!       coproc_list.tail = nt;
!       if (coproc_list.ncoproc == 1)
! 	coproc_list.tail = coproc_list.head;		/* just to make sure */  
!     }
  }
  
***************
*** 1686,1689 ****
--- 1740,1762 ----
  }
  
+ static void
+ cpl_closeall ()
+ {
+   struct cpelement *cpe;
+ 
+   for (cpe = coproc_list.head; cpe; cpe = cpe->next)
+     coproc_close (cpe->coproc);
+ }
+ 
+ static void
+ cpl_fdchk (fd)
+      int fd;
+ {
+   struct cpelement *cpe;
+ 
+   for (cpe = coproc_list.head; cpe; cpe = cpe->next)
+     coproc_checkfd (cpe->coproc, fd);
+ }
+ 
  /* Search for PID in the list of coprocs; return the cpelement struct if
     found.  If not found, return NULL. */
***************
*** 1692,1700 ****
       pid_t pid;
  {
!   struct cpelement *cp;
  
!   for (cp = coproc_list.head ; cp; cp = cp->next)
!     if (cp->coproc->c_pid == pid)
!       return cp;
    return (struct cpelement *)NULL;
  }
--- 1765,1773 ----
       pid_t pid;
  {
!   struct cpelement *cpe;
  
!   for (cpe = coproc_list.head ; cpe; cpe = cpe->next)
!     if (cpe->coproc->c_pid == pid)
!       return cpe;
    return (struct cpelement *)NULL;
  }
***************
*** 1704,1708 ****
  static struct cpelement *
  cpl_searchbyname (name)
!      char *name;
  {
    struct cpelement *cp;
--- 1777,1781 ----
  static struct cpelement *
  cpl_searchbyname (name)
!      const char *name;
  {
    struct cpelement *cp;
***************
*** 1739,1743 ****
--- 1812,1823 ----
       pid_t pid;
  {
+ #if MULTIPLE_COPROCS
+   struct cpelement *p;
+ 
+   p = cpl_search (pid);
+   return (p ? p->coproc : 0);
+ #else
    return (pid == sh_coproc.c_pid ? &sh_coproc : 0);
+ #endif
  }
  
***************
*** 1746,1750 ****
--- 1826,1837 ----
       const char *name;
  {
+ #if MULTIPLE_COPROCS
+   struct cpelement *p;
+ 
+   p = cpl_searchbyname (name);
+   return (p ? p->coproc : 0);
+ #else
    return ((sh_coproc.c_name && STREQ (sh_coproc.c_name, name)) ? &sh_coproc : 0);
+ #endif
  }
  
***************
*** 1767,1771 ****
    struct coproc *cp;
  
!   cp = &sh_coproc;		/* XXX */
    coproc_init (cp);
  
--- 1854,1862 ----
    struct coproc *cp;
  
! #if MULTIPLE_COPROCS
!   cp = (struct coproc *)xmalloc (sizeof (struct coproc));
! #else
!   cp = &sh_coproc;
! #endif
    coproc_init (cp);
  
***************
*** 1773,1779 ****
--- 1864,1881 ----
    cp->c_pid = pid;
  
+ #if MULTIPLE_COPROCS
+   cpl_add (cp);
+ #endif
+ 
    return (cp);
  }
  
+ static void
+ coproc_free (cp)
+      struct coproc *cp;
+ {
+   free (cp);
+ }
+ 
  void
  coproc_dispose (cp)
***************
*** 1786,1797 ****
    FREE (cp->c_name);
    coproc_close (cp);
    coproc_init (cp);
  }
  
! /* Placeholder for now. */
  void
  coproc_flush ()
  {
    coproc_dispose (&sh_coproc);
  }
  
--- 1888,1907 ----
    FREE (cp->c_name);
    coproc_close (cp);
+ #if MULTIPLE_COPROCS
+   coproc_free (cp);
+ #else
    coproc_init (cp);
+ #endif
  }
  
! /* Placeholder for now.  Will require changes for multiple coprocs */
  void
  coproc_flush ()
  {
+ #if MULTIPLE_COPROCS
+   cpl_flush ();
+ #else
    coproc_dispose (&sh_coproc);
+ #endif
  }
  
***************
*** 1816,1820 ****
  coproc_closeall ()
  {
!   coproc_close (&sh_coproc);
  }
  
--- 1926,1934 ----
  coproc_closeall ()
  {
! #if MULTIPLE_COPROCS
!   cpl_closeall ();
! #else
!   coproc_close (&sh_coproc);	/* XXX - will require changes for multiple coprocs */
! #endif
  }
  
***************
*** 1822,1830 ****
  coproc_reap ()
  {
    struct coproc *cp;
  
!   cp = &sh_coproc;
    if (cp && (cp->c_flags & COPROC_DEAD))
      coproc_dispose (cp);
  }
  
--- 1936,1948 ----
  coproc_reap ()
  {
+ #if MULTIPLE_COPROCS
+   cpl_reap ();
+ #else
    struct coproc *cp;
  
!   cp = &sh_coproc;		/* XXX - will require changes for multiple coprocs */
    if (cp && (cp->c_flags & COPROC_DEAD))
      coproc_dispose (cp);
+ #endif
  }
  
***************
*** 1873,1877 ****
--- 1991,1999 ----
       int fd;
  {
+ #if MULTIPLE_COPROCS
+   cpl_fdchk (fd);
+ #else
    coproc_checkfd (&sh_coproc, fd);
+ #endif
  }
  
***************
*** 1908,1923 ****
    struct coproc *cp;
  
    cp = getcoprocbypid (pid);
- #if 0
-   if (cp)
-     itrace("coproc_pidchk: pid %d has died", pid);
  #endif
    if (cp)
      {
        cp->c_status = status;
        cp->c_flags |= COPROC_DEAD;
        cp->c_flags &= ~COPROC_RUNNING;
! #if 0
        coproc_dispose (cp);
  #endif
      }
--- 2030,2053 ----
    struct coproc *cp;
  
+ #if MULTIPLE_COPROCS
+   struct cpelement *cpe;
+ 
+   cpe = cpl_delete (pid);
+   cp = cpe ? cpe->coproc : 0;
+ #else
    cp = getcoprocbypid (pid);
  #endif
    if (cp)
      {
+ #if 0
+       itrace("coproc_pidchk: pid %d has died", pid);
+ #endif
        cp->c_status = status;
        cp->c_flags |= COPROC_DEAD;
        cp->c_flags &= ~COPROC_RUNNING;
! #if MULTIPLE_COPROCS
        coproc_dispose (cp);
+ #else
+       coproc_unsetvars (cp);
  #endif
      }
***************
*** 2015,2029 ****
    char *tcmd;
  
!   /* XXX -- will require changes to handle multiple coprocs */
    if (sh_coproc.c_pid != NO_PID)
!     {
! #if 0
!       internal_error ("execute_coproc: coproc [%d:%s] already exists", sh_coproc.c_pid, sh_coproc.c_name);
!       return (last_command_exit_value = EXECUTION_FAILURE);
! #else
!       internal_warning ("execute_coproc: coproc [%d:%s] still exists", sh_coproc.c_pid, sh_coproc.c_name);
! #endif
!     }
    coproc_init (&sh_coproc);
  
    command_string_index = 0;
--- 2145,2154 ----
    char *tcmd;
  
!   /* XXX -- can be removed after changes to handle multiple coprocs */
! #if !MULTIPLE_COPROCS
    if (sh_coproc.c_pid != NO_PID)
!     internal_warning ("execute_coproc: coproc [%d:%s] still exists", sh_coproc.c_pid, sh_coproc.c_name);
    coproc_init (&sh_coproc);
+ #endif
  
    command_string_index = 0;
***************
*** 2197,2202 ****
      cmd->flags |= CMD_IGNORE_RETURN;
  
- #if defined (JOB_CONTROL)
    lastpipe_flag = 0;
    begin_unwind_frame ("lastpipe-exec");
    lstdin = -1;
--- 2322,2327 ----
      cmd->flags |= CMD_IGNORE_RETURN;
  
    lastpipe_flag = 0;
+ 
    begin_unwind_frame ("lastpipe-exec");
    lstdin = -1;
***************
*** 2222,2233 ****
    if (prev >= 0)
      add_unwind_protect (close, prev);
- #endif
  
    exec_result = execute_command_internal (cmd, asynchronous, prev, pipe_out, fds_to_close);
  
- #if defined (JOB_CONTROL)
    if (lstdin > 0)
      restore_stdin (lstdin);
- #endif
  
    if (prev >= 0)
--- 2347,2355 ----
***************
*** 2252,2258 ****
      }
  
- #if defined (JOB_CONTROL)
    discard_unwind_frame ("lastpipe-exec");
- #endif
  
    return (exec_result);
--- 2374,2378 ----
***************
*** 2471,2479 ****
        /* Save this command unless it's a trap command and we're not running
  	 a debug trap. */
- #if 0
-       if (signal_in_progress (DEBUG_TRAP) == 0 && (this_command_name == 0 || (STREQ (this_command_name, "trap") == 0)))
- #else
        if (signal_in_progress (DEBUG_TRAP) == 0 && running_trap == 0)
- #endif
  	{
  	  FREE (the_printed_command_except_trap);
--- 2591,2595 ----
***************
*** 2490,2494 ****
  
        this_command_name = (char *)NULL;
!       v = bind_variable (identifier, list->word->word, 0);
        if (readonly_p (v) || noassign_p (v))
  	{
--- 2606,2617 ----
  
        this_command_name = (char *)NULL;
!       /* XXX - special ksh93 for command index variable handling */
!       v = find_variable_last_nameref (identifier);
!       if (v && nameref_p (v))
!         {
!           v = bind_variable_value (v, list->word->word, 0);
!         }
!       else
!         v = bind_variable (identifier, list->word->word, 0);
        if (readonly_p (v) || noassign_p (v))
  	{
***************
*** 2749,2752 ****
--- 2872,2877 ----
    for (i = ind, l = list; l && --i; l = l->next)
      ;
+   if (l == 0)		/* don't think this can happen */
+     return (0);
    fprintf (stderr, "%*d%s%s", len, ind, RP_SPACE, l->word->word);
    return (displen (l->word->word));
***************
*** 2889,2893 ****
        for (l = list; l && --reply; l = l->next)
  	;
!       return (l->word->word);
      }
  }
--- 3014,3018 ----
        for (l = list; l && --reply; l = l->next)
  	;
!       return (l->word->word);		/* XXX - can't be null? */
      }
  }
***************
*** 3330,3333 ****
--- 3455,3459 ----
  static char * const nullstr = "";
  
+ /* XXX - can COND ever be NULL when this is called? */
  static int
  execute_cond_node (cond)
***************
*** 3379,3384 ****
      {
        rmatch = 0;
!       patmatch = ((cond->op->word[1] == '=') && (cond->op->word[2] == '\0') &&
! 		  (cond->op->word[0] == '!' || cond->op->word[0] == '=') ||
  		  (cond->op->word[0] == '=' && cond->op->word[1] == '\0'));
  #if defined (COND_REGEXP)
--- 3505,3510 ----
      {
        rmatch = 0;
!       patmatch = (((cond->op->word[1] == '=') && (cond->op->word[2] == '\0') &&
! 		   (cond->op->word[0] == '!' || cond->op->word[0] == '=')) ||
  		  (cond->op->word[0] == '=' && cond->op->word[1] == '\0'));
  #if defined (COND_REGEXP)
***************
*** 3581,3585 ****
       WORD_LIST *words;
  {
!   WORD_LIST *w;
    struct builtin *b;
    int assoc, global;
--- 3707,3711 ----
       WORD_LIST *words;
  {
!   WORD_LIST *w, *wcmd;
    struct builtin *b;
    int assoc, global;
***************
*** 3591,3594 ****
--- 3717,3721 ----
    assoc = global = 0;
  
+   wcmd = words;
    for (w = words; w; w = w->next)
      if (w->word->flags & W_ASSIGNMENT)
***************
*** 3596,3604 ****
  	if (b == 0)
  	  {
! 	    b = builtin_address_internal (words->word->word, 0);
  	    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)
  	      return;
  	    else if (b && (b->flags & ASSIGNMENT_BUILTIN))
! 	      words->word->flags |= W_ASSNBLTIN;
  	  }
  	w->word->flags |= (W_NOSPLIT|W_NOGLOB|W_TILDEEXP|W_ASSIGNARG);
--- 3723,3738 ----
  	if (b == 0)
  	  {
! 	    /* Posix (post-2008) says that `command' doesn't change whether
! 	       or not the builtin it shadows is a `declaration command', even
! 	       though it removes other special builtin properties.  In Posix
! 	       mode, we skip over one or more instances of `command' and
! 	       deal with the next word as the assignment builtin. */
! 	    while (posixly_correct && wcmd && wcmd->word && wcmd->word->word && STREQ (wcmd->word->word, "command"))
! 	      wcmd = wcmd->next;
! 	    b = builtin_address_internal (wcmd->word->word, 0);
  	    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)
  	      return;
  	    else if (b && (b->flags & ASSIGNMENT_BUILTIN))
! 	      wcmd->word->flags |= W_ASSNBLTIN;
  	  }
  	w->word->flags |= (W_NOSPLIT|W_NOGLOB|W_TILDEEXP|W_ASSIGNARG);
***************
*** 3620,3632 ****
  	if (b == 0)
  	  {
! 	    b = builtin_address_internal (words->word->word, 0);
  	    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)
  	      return;
  	    else if (b && (b->flags & ASSIGNMENT_BUILTIN))
! 	      words->word->flags |= W_ASSNBLTIN;
  	  }
! 	if ((words->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'A'))
  	  assoc = 1;
! 	if ((words->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'g'))
  	  global = 1;
        }
--- 3754,3768 ----
  	if (b == 0)
  	  {
! 	    while (posixly_correct && wcmd && wcmd->word && wcmd->word->word && STREQ (wcmd->word->word, "command"))
! 	      wcmd = wcmd->next;
! 	    b = builtin_address_internal (wcmd->word->word, 0);
  	    if (b == 0 || (b->flags & ASSIGNMENT_BUILTIN) == 0)
  	      return;
  	    else if (b && (b->flags & ASSIGNMENT_BUILTIN))
! 	      wcmd->word->flags |= W_ASSNBLTIN;
  	  }
! 	if ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'A'))
  	  assoc = 1;
! 	if ((wcmd->word->flags & W_ASSNBLTIN) && strchr (w->word->word+1, 'g'))
  	  global = 1;
        }
***************
*** 3640,3645 ****
  {
    char *temp;
!   temp = search_for_command (pathname);
!   return (temp ? file_isdir (temp) : file_isdir (pathname));
  }
  
--- 3776,3785 ----
  {
    char *temp;
!   int ret;
! 
!   temp = search_for_command (pathname, 0);
!   ret = (temp ? file_isdir (temp) : file_isdir (pathname));
!   free (temp);
!   return ret;
  }
  
***************
*** 3665,3668 ****
--- 3805,3810 ----
    command_line = (char *)0;
  
+   QUIT;
+ 
    /* If we're in a function, update the line number information. */
    if (variable_context && interactive_shell && sourcelevel == 0)
***************
*** 3981,3985 ****
  
    if (command_line == 0)
!     command_line = savestring (the_printed_command_except_trap);
  
  #if defined (PROCESS_SUBSTITUTION)
--- 4123,4127 ----
  
    if (command_line == 0)
!     command_line = savestring (the_printed_command_except_trap ? the_printed_command_except_trap : "");
  
  #if defined (PROCESS_SUBSTITUTION)
***************
*** 4042,4050 ****
    char *error_trap;
  
- #if 0
-   /* XXX -- added 12/11 */
-   terminate_immediately++;
- #endif
- 
    error_trap = 0;
    old_e_flag = exit_immediately_on_error;
--- 4184,4187 ----
***************
*** 4128,4136 ****
      }
  
- #if 0
-   /* XXX -- added 12/11 */
-   terminate_immediately--;
- #endif
- 
    return (result);
  }
--- 4265,4268 ----
***************
*** 4160,4164 ****
    if (funcnest_max > 0 && funcnest >= funcnest_max)
      {
!       internal_error ("%s: maximum function nesting level exceeded (%d)", var->name, funcnest);
        funcnest = 0;	/* XXX - should we reset it somewhere else? */
        jump_to_top_level (DISCARD);
--- 4292,4296 ----
    if (funcnest_max > 0 && funcnest >= funcnest_max)
      {
!       internal_error (_("%s: maximum function nesting level exceeded (%d)"), var->name, funcnest);
        funcnest = 0;	/* XXX - should we reset it somewhere else? */
        jump_to_top_level (DISCARD);
***************
*** 4252,4260 ****
    shell_fn = find_function_def (this_shell_function->name);
    sfile = shell_fn ? shell_fn->source_file : "";
!   array_push (funcname_a, this_shell_function->name);
  
!   array_push (bash_source_a, sfile);
    t = itos (executing_line_number ());
!   array_push (bash_lineno_a, t);
    free (t);
  #endif
--- 4384,4392 ----
    shell_fn = find_function_def (this_shell_function->name);
    sfile = shell_fn ? shell_fn->source_file : "";
!   array_push ((ARRAY *)funcname_a, this_shell_function->name);
  
!   array_push ((ARRAY *)bash_source_a, sfile);
    t = itos (executing_line_number ());
!   array_push ((ARRAY *)bash_lineno_a, t);
    free (t);
  #endif
***************
*** 4331,4336 ****
    /* These two variables cannot be unset, and cannot be affected by the
       function. */
!   array_pop (bash_source_a);
!   array_pop (bash_lineno_a);
  
    /* FUNCNAME can be unset, and so can potentially be changed by the
--- 4463,4468 ----
    /* These two variables cannot be unset, and cannot be affected by the
       function. */
!   array_pop ((ARRAY *)bash_source_a);
!   array_pop ((ARRAY *)bash_lineno_a);
  
    /* FUNCNAME can be unset, and so can potentially be changed by the
***************
*** 4666,4670 ****
  #endif /* RESTRICTED_SHELL */
  
!   command = search_for_command (pathname);
  
    if (command)
--- 4798,4802 ----
  #endif /* RESTRICTED_SHELL */
  
!   command = search_for_command (pathname, 1);
  
    if (command)
***************
*** 4765,4768 ****
--- 4897,4902 ----
      {
  parent_return:
+       QUIT;
+ 
        /* Make sure that the pipes are closed in the parent. */
        close_pipes (pipe_in, pipe_out);
***************
*** 4993,4996 ****
--- 5127,5131 ----
  #if defined (HAVE_HASH_BANG_EXEC)
  	  READ_SAMPLE_BUF (command, sample, sample_len);
+ 	  sample[sample_len - 1] = '\0';
  	  if (sample_len > 2 && sample[0] == '#' && sample[1] == '!')
  	    {
***************
*** 5045,5049 ****
        if (check_binary_file (sample, sample_len))
  	{
! 	  internal_error (_("%s: cannot execute binary file"), command);
  	  return (EX_BINARY_FILE);
  	}
--- 5180,5184 ----
        if (check_binary_file (sample, sample_len))
  	{
! 	  internal_error (_("%s: cannot execute binary file: %s"), command, strerror (i));
  	  return (EX_BINARY_FILE);
  	}
***************
*** 5098,5104 ****
  
  static int
! execute_intern_function (name, function)
       WORD_DESC *name;
!      COMMAND *function;
  {
    SHELL_VAR *var;
--- 5233,5239 ----
  
  static int
! execute_intern_function (name, funcdef)
       WORD_DESC *name;
!      FUNCTION_DEF *funcdef;
  {
    SHELL_VAR *var;
***************
*** 5114,5117 ****
--- 5249,5260 ----
      }
  
+   /* Posix interpretation 383 */
+   if (posixly_correct && find_special_builtin (name->word))
+     {
+       internal_error (_("`%s': is a special builtin"), name->word);
+       last_command_exit_value = EX_BADUSAGE;
+       jump_to_top_level (ERREXIT);
+     }
+ 
    var = find_function (name->word);
    if (var && (readonly_p (var) || noassign_p (var)))
***************
*** 5122,5126 ****
      }
  
!   bind_function (name->word, function);
    return (EXECUTION_SUCCESS);
  }
--- 5265,5273 ----
      }
  
! #if defined (DEBUGGER)
!   bind_function_def (name->word, funcdef);
! #endif
! 
!   bind_function (name->word, funcdef->command);
    return (EXECUTION_SUCCESS);
  }
