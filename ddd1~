*** ../bash-3.2-patched/lib/sh/getcwd.c	2004-07-21 17:15:19.000000000 -0400
--- lib/sh/getcwd.c	2007-12-31 19:26:36.000000000 -0500
***************
*** 27,30 ****
--- 27,34 ----
  #endif /* _AIX && RISC6000 && !__GNUC__ */
  
+ #if defined (__QNX__)
+ #  undef HAVE_LSTAT
+ #endif
+ 
  #include <bashtypes.h>
  #include <errno.h>
***************
*** 59,62 ****
--- 63,93 ----
  #endif
  
+ /* If the d_fileno member of a struct dirent doesn't return anything useful,
+    we need to check inode number equivalence the hard way.  Return 1 if
+    the inode corresponding to PATH/DIR is identical to THISINO. */
+ #if defined (BROKEN_DIRENT_D_INO)
+ static int
+ _path_checkino (dotp, name, thisino)
+      char *dotp;
+      char *name;
+      ino_t thisino;
+ {
+   char *fullpath;
+   int r, e;
+   struct stat st;
+ 
+   e = errno;
+   fullpath = sh_makepath (dotp, name, MP_RMDOT);
+   if (stat (fullpath, &st) < 0)
+     {
+       errno = e;
+       return 0;
+     }
+   free (fullpath);
+   errno = e;
+   return (st.st_ino == thisino);
+ }
+ #endif
+     
  /* Get the pathname of the current working directory,
     and put it in SIZE bytes of BUF.  Returns NULL if the
***************
*** 170,174 ****
--- 201,209 ----
  		(d->d_name[1] == '.' && d->d_name[2] == '\0')))
  	    continue;
+ #if !defined (BROKEN_DIRENT_D_INO)
  	  if (mount_point || d->d_fileno == thisino)
+ #else
+ 	  if (mount_point || _path_checkino (dotp, d->d_name, thisino))
+ #endif
  	    {
  	      char *name;
***************
*** 252,268 ****
    {
      size_t len = pathbuf + pathsize - pathp;
      if (buf == NULL)
        {
! 	if (len < (size_t) size)
! 	  len = size;
! 	buf = (char *) malloc (len);
  	if (buf == NULL)
  	  goto lose2;
        }
!     else if ((size_t) size < len)
!       {
! 	errno = ERANGE;
! 	goto lose2;
!       }
      (void) memcpy((PTR_T) buf, (PTR_T) pathp, len);
    }
--- 287,305 ----
    {
      size_t len = pathbuf + pathsize - pathp;
+     if (buf == NULL && size <= 0)
+       size = len;
+ 
+     if ((size_t) size < len)
+       {
+ 	errno = ERANGE;
+ 	goto lose2;
+       }
      if (buf == NULL)
        {
! 	buf = (char *) malloc (size);
  	if (buf == NULL)
  	  goto lose2;
        }
! 
      (void) memcpy((PTR_T) buf, (PTR_T) pathp, len);
    }
