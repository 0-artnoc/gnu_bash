*** braces.c.orig	Fri Sep 17 18:42:36 2004
--- braces.c	Sat Jan 28 19:24:14 2006
***************
*** 81,94 ****
    char *preamble, *postamble, *amble;
    size_t alen;
    char **tack, **result;
!   int i, j, c;
  
    DECLARE_MBSTATE;
  
    /* Find the text of the preamble. */
    tlen = strlen (text);
    i = 0;
!   c = brace_gobbler (text, tlen, &i, '{');
  
    preamble = (char *)xmalloc (i + 1);
    strncpy (preamble, text, i);
--- 81,121 ----
    char *preamble, *postamble, *amble;
    size_t alen;
    char **tack, **result;
!   int i, j, c, c1;
  
    DECLARE_MBSTATE;
  
    /* Find the text of the preamble. */
    tlen = strlen (text);
    i = 0;
!   /* Make sure that when we exit this loop, c == 0 or text[i] begins a
!      valid brace expansion sequence. */
!   do
!     {
!       c = brace_gobbler (text, tlen, &i, '{');	/* } */
!       c1 = c;
!       /* Verify that c begins a valid brace expansion word.  If it doesn't, we
! 	 go on.  Loop stops when there are no more open braces in the word. */
!       if (c)
! 	{
! 	  start = j = i + 1;	/* { */
! 	  c = brace_gobbler (text, tlen, &j, '}');
! 	  if (c == 0)		/* it's not */
! 	    {
! 	      i++;
! 	      c = c1;
! 	      continue;
! 	    }
! 	  else			/* it is */
! 	    {
! 	      c = c1;
! 	      break;
! 	    }
! 	}
!       else
! 	break;
!     }
!   while (c);
  
    preamble = (char *)xmalloc (i + 1);
    strncpy (preamble, text, i);
***************
*** 361,366 ****
--- 388,398 ----
     index of the character matching SATISFY.  This understands about
     quoting.  Return the character that caused us to stop searching;
     this is either the same as SATISFY, or 0. */
+ /* If SATISFY is `}', we are looking for a brace expression, so we
+    should enforce the rules that govern valid brace expansions:
+ 	1) to count as an arg separator, a comma or `..' has to be outside
+ 	   an inner set of braces.	 
+ */
  static int
  brace_gobbler (text, tlen, indx, satisfy)
       char *text;
***************
*** 368,374 ****
       int *indx;
       int satisfy;
  {
!   register int i, c, quoted, level, pass_next;
  #if defined (SHELL)
    int si;
    char *t;
--- 400,406 ----
       int *indx;
       int satisfy;
  {
!   register int i, c, quoted, level, commas, pass_next;
  #if defined (SHELL)
    int si;
    char *t;
***************
*** 376,381 ****
--- 408,414 ----
    DECLARE_MBSTATE;
  
    level = quoted = pass_next = 0;
+   commas = (satisfy == '}') ? 0 : 1;
  
    i = *indx;
    while (c = text[i])
***************
*** 436,442 ****
  	}
  #endif
  
!       if (c == satisfy && level == 0 && quoted == 0)
  	{
  	  /* We ignore an open brace surrounded by whitespace, and also
  	     an open brace followed immediately by a close brace preceded
--- 469,475 ----
  	}
  #endif
  
!       if (c == satisfy && level == 0 && quoted == 0 && commas > 0)
  	{
  	  /* We ignore an open brace surrounded by whitespace, and also
  	     an open brace followed immediately by a close brace preceded
***************
*** 456,461 ****
--- 489,499 ----
  	level++;
        else if (c == '}' && level)
  	level--;
+       else if (satisfy == '}' && c == brace_arg_separator && level == 0)
+ 	commas++;
+       else if (satisfy == '}' && STREQN (text+i, BRACE_SEQ_SPECIFIER, 2) &&
+       		text[i+2] != satisfy && level == 0)
+ 	commas++;
  
        ADVANCE_CHAR (text, tlen, i);
      }
