*** ../../../bash-20081120/lib/readline/display.c	2008-11-13 09:55:19.000000000 -0500
--- display.c	2008-11-28 23:37:26.000000000 -0500
***************
*** 497,501 ****
    register char *line;
    int inv_botlin, lb_botlin, lb_linenum, o_cpos;
!   int newlines, lpos, temp, n0, num;
    char *prompt_this_line;
  #if defined (HANDLE_MULTIBYTE)
--- 497,501 ----
    register char *line;
    int inv_botlin, lb_botlin, lb_linenum, o_cpos;
!   int newlines, lpos, temp, n0, num, prompt_lines_estimate;
    char *prompt_this_line;
  #if defined (HANDLE_MULTIBYTE)
***************
*** 664,668 ****
       the first physical line of the prompt.
       wrap_offset - prompt_invis_chars_first_line is the number of invis
!      chars on the second line. */
  
    /* what if lpos is already >= _rl_screenwidth before we start drawing the
--- 664,671 ----
       the first physical line of the prompt.
       wrap_offset - prompt_invis_chars_first_line is the number of invis
!      chars on the second (or, more generally, last) line. */
! 
!   /* This is zero-based, used to set the newlines */
!   prompt_lines_estimate = lpos / _rl_screenwidth;
  
    /* what if lpos is already >= _rl_screenwidth before we start drawing the
***************
*** 702,710 ****
  
        /* Now account for invisible characters in the current line. */
!       /* XXX - this assumes that all of the invisible characters are before
! 	 the line wrap. */
        temp += ((local_prompt_prefix == 0) ? ((newlines == 0) ? prompt_invis_chars_first_line
! 							     : ((newlines == 1) ? wrap_offset : 0))
! 					  : ((newlines == 0) ? wrap_offset :0));
               
        inv_lbreaks[++newlines] = temp;
--- 705,713 ----
  
        /* Now account for invisible characters in the current line. */
!       /* XXX - this assumes that the invisible characters may be split, but only
! 	 between the first and the last lines. */
        temp += ((local_prompt_prefix == 0) ? ((newlines == 0) ? prompt_invis_chars_first_line
! 							     : ((newlines == prompt_lines_estimate) ? wrap_offset : prompt_invis_chars_first_line))
! 					  : ((newlines == 0) ? wrap_offset : 0));
               
        inv_lbreaks[++newlines] = temp;
***************
*** 969,973 ****
  		 is an absolute cursor position in a multibyte locale.  See
  		 if compensating here is the right thing, or if we have to
! 		 change update_line itself.  There is one case in which
  		 update_line adjusts _rl_last_c_pos itself (so it can pass
  		 _rl_move_cursor_relative accurate values); it communicates
--- 972,976 ----
  		 is an absolute cursor position in a multibyte locale.  See
  		 if compensating here is the right thing, or if we have to
! 		 change update_line itself.  There are several cases in which
  		 update_line adjusts _rl_last_c_pos itself (so it can pass
  		 _rl_move_cursor_relative accurate values); it communicates
***************
*** 1609,1614 ****
  	     _rl_term_IC or _rl_term_ic will screw up the screen because of the
  	     invisible characters.  We need to just draw them. */
! 	  if (*ols && (!_rl_horizontal_scroll_mode || _rl_last_c_pos > 0 ||
! 			lendiff <= prompt_visible_length || !current_invis_chars))
  	    {
  	      insert_some_chars (nfd, lendiff, col_lendiff);
--- 1612,1626 ----
  	     _rl_term_IC or _rl_term_ic will screw up the screen because of the
  	     invisible characters.  We need to just draw them. */
! 	  /* The same thing happens if we're trying to draw before the last
! 	     invisible character in the prompt string and we're not drawing
! 	     the entire prompt string. */
! 	  if (*ols && ((_rl_horizontal_scroll_mode &&
! 			_rl_last_c_pos == 0 &&
! 			lendiff > prompt_visible_length &&
! 			current_invis_chars > 0) == 0) &&
! 		      (((MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
! 		        current_line == 0 && wrap_offset &&
! 		        ((nfd - new) <= prompt_last_invisible) &&
! 		        (col_lendiff < prompt_visible_length)) == 0))
  	    {
  	      insert_some_chars (nfd, lendiff, col_lendiff);
***************
*** 1631,1635 ****
  		 adjust _rl_last_c_pos to account for wrap_offset and set
  		 cpos_adjusted to let the caller know. */
! 	      if (current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
  		{
  		  _rl_last_c_pos -= wrap_offset;
--- 1643,1647 ----
  		 adjust _rl_last_c_pos to account for wrap_offset and set
  		 cpos_adjusted to let the caller know. */
! 	      if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
  		{
  		  _rl_last_c_pos -= wrap_offset;
***************
*** 1652,1655 ****
--- 1664,1675 ----
  		twidth = temp - lendiff;
  	      _rl_last_c_pos += twidth;
+ 	      /* If nfd begins before any invisible characters in the prompt,
+ 		 adjust _rl_last_c_pos to account for wrap_offset and set
+ 		 cpos_adjusted to let the caller know. */
+ 	      if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
+ 		{
+ 		  _rl_last_c_pos -= wrap_offset;
+ 		  cpos_adjusted = 1;
+ 		}
  	    }
  	}
***************
*** 1663,1666 ****
--- 1683,1694 ----
  	     characters) we need to adjust _rl_last_c_pos, since it represents
  	     a physical character position. */
+ 	  if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
+ 		current_line == prompt_last_screen_line && wrap_offset &&
+ 		wrap_offset != prompt_invis_chars_first_line &&
+ 		((nfd-new) < (prompt_last_invisible-(current_line*_rl_screenwidth))))
+ 	    {
+ 	      _rl_last_c_pos -= wrap_offset - prompt_invis_chars_first_line;
+ 	      cpos_adjusted = 1;
+ 	    }
  	}
      }
***************
*** 1728,1732 ****
--- 1756,1769 ----
  	    col_lendiff = lendiff;
  
+ #if 0
  	  if (col_lendiff)
+ #else
+ 	  /* If we've already printed over the entire width of the screen,
+ 	     including the old material, then col_lendiff doesn't matter and
+ 	     space_to_eol will insert too many spaces.  XXX - maybe we should
+ 	     adjust col_lendiff based on the difference between _rl_last_c_pos
+ 	     and _rl_screenwidth */
+ 	  if (col_lendiff && (_rl_last_c_pos < _rl_screenwidth))
+ #endif
  	    {	  
  	      if (_rl_term_autowrap && current_line < inv_botlin)
***************
*** 1863,1867 ****
  	   _rl_last_v_pos == prompt_last_screen_line &&
  	   wrap_offset != woff &&
! 	   new > (prompt_last_invisible-_rl_screenwidth-wrap_offset)))
  	{
  	  dpos -= woff;
--- 1900,1905 ----
  	   _rl_last_v_pos == prompt_last_screen_line &&
  	   wrap_offset != woff &&
! 	   new > (prompt_last_invisible-(_rl_screenwidth*_rl_last_v_pos)-wrap_offset)))
! 	   /* XXX last comparison might need to be >= */
  	{
  	  dpos -= woff;
