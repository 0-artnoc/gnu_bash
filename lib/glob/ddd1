*** /fs2/chet/bash/bash-20110317/lib/glob/xmbsrtowcs.c	2011-03-14 14:29:02.000000000 -0400
--- xmbsrtowcs.c	2011-03-22 16:06:47.000000000 -0400
***************
*** 35,40 ****
--- 35,42 ----
  
  #if HANDLE_MULTIBYTE
  
+ #define WSBUF_INC 32
+ 
  #ifndef FREE
  #  define FREE(x)	do { if (x) free (x); } while (0)
  #endif
***************
*** 171,180 ****
        /* Compute the number of produced wide-characters. */
        tmp_p = p;
        tmp_state = state;
!       wcslength = mbsnrtowcs (NULL, &tmp_p, nms, 0, &tmp_state);
  
        /* Conversion failed. */
!       if (wcslength == 0 || wcslength == (size_t)-1)
  	{
  	  free (wsbuf);
  	  *destp = NULL;
--- 173,193 ----
        /* Compute the number of produced wide-characters. */
        tmp_p = p;
        tmp_state = state;
! 
!       if (nms == 0 && *p == '\\')	/* special initial case */
! 	nms = wcslength = 1;
!       else
! 	wcslength = mbsnrtowcs (NULL, &tmp_p, nms, 0, &tmp_state);
! 
!       if (wcslength == 0)
! 	{
! 	  tmp_p = p;		/* will need below */
! 	  tmp_state = state;
! 	  wcslength = 1;	/* take a single byte */
! 	}
  
        /* Conversion failed. */
!       if (wcslength == (size_t)-1)
  	{
  	  free (wsbuf);
  	  *destp = NULL;
***************
*** 186,192 ****
  	{
  	  wchar_t *wstmp;
  
! 	  wsbuf_size = wcnum+wcslength+1;	/* 1 for the L'\0' or the potential L'\\' */
  
  	  wstmp = (wchar_t *) realloc (wsbuf, wsbuf_size * sizeof (wchar_t));
  	  if (wstmp == NULL)
--- 199,206 ----
  	{
  	  wchar_t *wstmp;
  
! 	  while (wsbuf_size < wcnum+wcslength+1) /* 1 for the L'\0' or the potential L'\\' */
! 	    wsbuf_size += WSBUF_INC;
  
  	  wstmp = (wchar_t *) realloc (wsbuf, wsbuf_size * sizeof (wchar_t));
  	  if (wstmp == NULL)
***************
*** 199,208 ****
  	}
  
        /* Perform the conversion. This is assumed to return 'wcslength'.
!        * It may set 'p' to NULL. */
        n = mbsnrtowcs(wsbuf+wcnum, &p, nms, wsbuf_size-wcnum, &state);
  
!       wcnum += wcslength;
  
        if (mbsinit (&state) && (p != NULL) && (*p == '\\'))
  	{
--- 213,230 ----
  	}
  
        /* Perform the conversion. This is assumed to return 'wcslength'.
! 	 It may set 'p' to NULL. */
        n = mbsnrtowcs(wsbuf+wcnum, &p, nms, wsbuf_size-wcnum, &state);
  
!       /* Compensate for taking single byte on wcs conversion failure above. */
!       if (wcslength == 1 && (n == 0 || n == (size_t)-1))
! 	{
! 	  state = tmp_state;
! 	  p = tmp_p;
! 	  wsbuf[wcnum++] = *p++;
! 	}
!       else
!         wcnum += wcslength;
  
        if (mbsinit (&state) && (p != NULL) && (*p == '\\'))
  	{
***************
*** 230,237 ****
     If conversion is failed, the return value is (size_t)-1 and the values
     of DESTP and INDICESP are NULL. */
  
- #define WSBUF_INC 32
- 
  size_t
  xdupmbstowcs (destp, indicesp, src)
      wchar_t **destp;	/* Store the pointer to the wide character string */
--- 252,257 ----
